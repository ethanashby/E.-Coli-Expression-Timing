---
title: "Analysis of *E. coli* Time Course RNA-Seq Data"
author: Ethan Ashby, Annie Cohen, Lian Morales, Prof. Jo Hardin,
  Prof. Dan Stoebel, Prof. Danae Schulz
date: "9/17/2019"
output:
  pdf_document: default
  html_document:
    toc: true
---

# Table of Contents
1. Introduction  
\indent 1.1 Background on *E. coli*  
\indent 1.2 RNA-Seq   
\indent 1.3 Our data
2. Normalization
3. Differential Expression  
\indent 3.1 DESeq2   
\indent 3.2 ImpulseDE2   
\indent 3.3 maSigPro  
\indent 3.4 Find the intersection
4. Visualization  
\indent 4.1 Tidying our data   
\indent 4.2 ggplot2  
\indent 4.3 Shiny App
5. Analysis  
\indent 5.1 PAM Clustering  
\indent 5.2 Gene Ontology Analysis   
\indent 5.3 Gene Set Enrichment Analysis
6. References  

# **1** Introduction

### **1.1** Background on *E. coli*
E. coli possesses a general stress response to a variety of environmental stresses (Battesti *et al* 2011, Hengge 2011) ranging from osmotic shock to nutrient starvation. According to preliminary data from Professor Daniel Stoebel, a key transcription factor coordinating this response is RpoS, which regulates one quarter of the bacteria's genome. Simple interpretations of transcriptional networks often invoke an analogy of an on/off switch, in which the presence of a stimulus turns some genes on and other genes off. However, these simple interpretations don't adequately describe the complex, dyanmic processes underlying many transcriptional responses to stimuli. Currently, there exists a limited understanding regarding the dynamic nature of transcriptional responses, and the well-annotated, heavily-studied genome of E. coli presents an excellent model to study these intricate regulatory circuits. Past research has determined three different profiles for genes in relation to RpoS. Linear genes' expression increases linearly with an increase in RpoS. Genes are considered sensitive if low levels of RpoS cause them to react more than expected in the linear profile and insensitive genes are less expressed with low levels of RpoS than linear genes. This research examines whether genes that have previously been identified as linear, sensitive, or insensitive have similar profiles of expression over time under cell stress conditions.

### **1.2** RNA-Seq
RNA-Seq is the process of extracting, fragmenting, amplifying, sequencing, and mapping RNA to a reference gene in order to determine gene expression levels. Sequencing of RNA data allows us to determine how RpoS regulates genes in response to a stressor such as starvation. We use RNA-Seq to compare the gene expression levels across treatments and time points. We are interested in both the differences in expression between our treatment samples, wildtype (WT), and our control (dRpoS or knockout RpoS), as well as the differential expression of WT from 0 to 150 minutes of starvation.

### **1.3** Our data
The data we recieved from Professor Stoebel and his lab was a count matrix, with 37 columns. The column names specify the strain, timepoint, treatment, and replicate of the sample. "JH_01" or "JH_02" specifies the strain of *E. coli*, where "JH_01" is the wildtype under starvation, our treatment, and "JH_02" is delta-RpoS, our control in which RpoS is removed from the cells, under starvation. "A", "B", and "C" denotes the biological replicate and the number following it indicates the time point: "01" is 0, "02" is 30, "03" is 60, "04" is 90, "05" is 120, and "06" is 150 minutes. The original data came with a column called "Geneid", which denotes the specific gene. However, we needed a matrix of only count data in order to normalize our data, so we assigned this column as the row names and then deleted the column. In order to compare these genes with external gene lists, we parse the `Geneid` column into `genename`, which is a 3-4 digit character string, usually containing one capital letter.
$~$
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(tidyr)
library(shiny)
library(dplyr)
library(DESeq2)
library(readr)
library(stringr)
library(ImpulseDE2)
library(maSigPro)
library(VennDiagram)
library(NbClust)
library(topGO)
library(org.EcK12.eg.db)
library(shiny)
library(fgsea)
```

```{r import data, warning=FALSE, echo=FALSE}
# Import read count data
ec_rawcounts <- read.table("LB_Time_Course_GCA_000005845.2_ASM584v2_genomic_counts.txt",
                           header = TRUE)

# ID gene names using Madison's parsing code
rownames(ec_rawcounts) <- ec_rawcounts$Geneid
bnum = "b[0-9]{4}"
ec_rawcounts$GeneidBackup = ec_rawcounts$Geneid
ec_rawcounts <- ec_rawcounts %>% 
  separate(GeneidBackup, c("feature", "rest"), sep="[:]")
ec_rawcounts <- ec_rawcounts %>% 
  filter(feature %in% c("CDS")) 
genename = ":[a-z]{3}.."
ec_cds <- ec_rawcounts %>% 
  filter(feature %in% c("CDS")) 
ec_rawcounts$genename <- str_extract(ec_rawcounts$Geneid, genename)
ec_rawcounts$bnum <- str_extract(ec_rawcounts$Geneid, bnum)
ec_rawcounts <- ec_rawcounts %>% 
  separate(genename, into = c("colon", "genename"), sep = ":") %>%
  dplyr::select(-c(colon, rest, feature, bnum))

# De-dupe genenames
ec_rawcounts <- distinct(ec_rawcounts, genename, .keep_all = TRUE)

# Assign Geneid as rownames and delete variable
rownames(ec_rawcounts) <- ec_rawcounts$genename
ec_rawcounts <- ec_rawcounts %>% 
  dplyr::select(-c(Geneid, genename)) 

# filter for non-expressed genes
ec_rawcounts <- subset(ec_rawcounts, rowSums(ec_rawcounts[,1:36]) > 0)
```

```{r}
head(ec_rawcounts[,1:6],6)
```
$~$

# **2** Normalization
Normalization is an extremely influential step in the process of determining differentially expressed genes. It is necessary in order to minimize external factors such as gene length and sequencing depth. If a gene is longer, there is a higher probability of having more reads because of its longer sequence. Similarly, if one sample has disproportionately more reads than another, it will return a false positive. Therefore, we must normalize for both gene length and sequencing depth.

We tested out many normalization methods including `DESeq2` and `edgeR`. `DESeq2` is a normalization and differential expression analysis method that divides counts by sample specific size factors that are calculated as the median of the ratios of read counts to the geometric mean. `EdgeR` is similarly both a normalization and differential expression analysis method that employs the trimmed mean method (TMM), where gene expression is adjusted by a size factor that takes into account the fold change and relative expression level to its sample (Ciaran et. al). Through a comparison of size factors, we determined that the two methods produced very similar normalized counts. We ultimately decided to use `DESeq2` because of its abundant documentation.

$~$

```{r DESeq2 prep, echo = FALSE}
# Create a design matrix to Prepare for DESeq2
ec_coldata <- data.frame(names = colnames(ec_rawcounts)) %>%
  separate(names, c("treat", "rep_time"), "_") %>%
  mutate(rep = ifelse(substr(rep_time,start=1,stop = 1) == "A", 1, 
                        ifelse(substr(rep_time,start=1,stop = 1) == "B", 2, 3))) %>%
  mutate(time = ifelse(substr(rep_time,start=3,stop = 3) == "1", 0,
                      ifelse(substr(rep_time,start=3,stop = 3) == "2", 30,
                             ifelse(substr(rep_time,start=3,stop = 3) == "3", 60,
                                    ifelse(substr(rep_time,start=3,stop = 3) == "4", 90,
                                           ifelse(substr(rep_time,start=3,stop = 3) == "5", 120, 150)))))) %>%
  mutate(treat = ifelse(treat == "JH01", "WT","dRpoS")) %>%
  mutate(timetreat = paste(treat,time,sep = "")) %>%
  dplyr::select(-rep_time)
rownames(ec_coldata) <- colnames(ec_rawcounts)
```

`DESeq2` normalizes data within the differential expression analysis function pipeline, so we first run the `DESeq()` function and then extract the normalized counts.

```{r run DESeq2 for normalization, cache = TRUE, message=FALSE, warning=FALSE}
# Create DESeq dataframe
ec_dds <- DESeqDataSetFromMatrix(ec_rawcounts, colData = ec_coldata, 
                                 design = ~ timetreat)

# Run DESeq and extract normalized counts
ec_dds_de <- DESeq(ec_dds)
ec_normcounts <- as.data.frame(counts(ec_dds_de, normalized=TRUE))

head(ec_normcounts[1:6],6)
```
$~$

# **3** Differential Expression

Differential expression measures whether or not the gene expression of the same gene in different groups or treatments is significantly different. We apply three different differential expression analysis methods below to determine a list of differentially expressed genes in our data se.

### **3.1** DESeq2

According to Mistry, Meeta, *et al.* (2017), `DESeq2` determines differential expression by:  
1. Normalization of the raw counts by determining size factors and adjusting each sample by the size factor.   
2. Measuring gene-wise dispersions, where dispersion, $\alpha$, measures the variability within biological replicates of the same sample: $\text {Var} = \mu + \alpha\mu^2$.   
3. Adjusting dispersion estimates to fit a curve created by the distribution of dispersion estimates. Use `plotDispEsts()` to see fit estimates for yourself.  
4. Comparing normalized counts with a negative binomial distribution with the sample mean, $\mu_j$, and gene-wise dispersion parameter, $\alpha_j$ to determine the significance of differential expression.

Because we already ran `DESeq()` above, we can now extract the significant results. We chose a p-value of 0.01 to be consistent across all of our work. `DESeq2` is a two-sample comparison method, but we want to accurately determine differentially expressed genes across *all* the time points. Therefore, we compute:   
1. A list of differentially expressed genes between the treatment group (wild-type *E. coli*) at 0 minutes and 150 minutes.  
2. A list of differentially expressed genes between the treatment group and the control (delta-RpoS *E. coli*), both at 150 minutes.  
3. The intersection of the gene lists, or the genes that appear in both lists, which we use as our differentially expressed gene list from `DESeq2`.

```{r}
ggplot()
```

```{r extract DESeq2 results, results='hide', message=FALSE, warning=FALSE}
EC_sig_genes <- c()

# Determine the genes that are differentially expressed between WT0 and WT150
de_results <- results(ec_dds_de, contrast = c("timetreat", "WT150","WT0"))
# Filter for a p-value less than 0.01
resSig <- de_results[ which(de_results$padj < 0.01 ), ]
resSig$genename <- rownames(resSig)
ind <- match(rownames(ec_normcounts),resSig$genename)
ec_normcounts$sig <- resSig$genename[ind]
EC_sig_genes$WT_compare <- ec_normcounts %>%
 filter(!is.na(ec_normcounts$sig))


# Determine the genes that are differentially expressed between WT150 and dRpoS150
de_results <- results(ec_dds_de, contrast = c("timetreat", "WT150","dRpoS150"))
# Again, filter by p-value.
resSig <- de_results[ which(de_results$padj < 0.01 ), ]
resSig$genename <- rownames(resSig)
ind <- match(rownames(ec_normcounts),resSig$genename)
ec_normcounts$sig <- resSig$genename[ind]
EC_sig_genes$treat_compare <- ec_normcounts %>%
 filter(!is.na(ec_normcounts$sig))

# Find the intersection of the two lists of differentially expressed genes
EC_sig_genes <- intersect(EC_sig_genes$WT_compare$sig, EC_sig_genes$treat_compare$sig)
```

### **3.2** ImpulseDE2

ImpulseDE2 is a serial method for differential expression that models data based on the impulse model, which has parameters $t_1, t_2, h_0, h_1, \text{and } b.$ The impulse model has a spike, characterized by its beginning height, $h_0$, inflection point, $t_1$, its height, $h_1$, and its slope at $t_1$, $b$. Then the model decreases into its steady state, characterized by the second inflection point, $t_2$, and its final height, $h_2$. The expression profiles of our data hint at a sigmoid trajectory, where the first four parameters ($h_0,t,\beta,h_1$) are the same, but $h_1$ is the final expression.

```{r echo = FALSE}
knitr::include_graphics("Sig_Model.png")
```

According to Fischer et al., ImpulseDE2 determines differential expression by:  
**1.** running DESeq2 and adjusting gene-wise dispersion estimates from DESeq2 to fit a curve;  
**2.** computing size factors and normalizing counts;  
**3.** fitting null and alternative model to each of the genes;  
**4.** fitting sigmoid model to the treatment condition -- in our case, samples containing the RpoS translation factor;   
**5.** and determining differential expression based on these models fits to each gene using a log-likelihood ratio (Fischer et al. 2018).  

```{r prep ImpulseDE2}
# Set up design matrix with 
ec_design <- data.frame(Sample=colnames(ec_rawcounts),
                        Condition=c(rep("case",6), rep("control",6), rep("case",6), 
                                    rep("control",6), rep("case",6), 
                                    rep("control",6)), 
                        Time=rep(c(0,30,60,90,120,150),6))
```

```{r run ImpulseDE2, results='hide', cache = TRUE, message=FALSE, warning=FALSE}
# Set `boolCaseCtrl = TRUE` because our data has both case and control conditions, 
#`scaQThres = 0.01` specifies the level of significance, 
#`scaNProc = 8` speeds up the function's runtime, 
#and `boolIdentifyTransients = TRUE` indicates that we are also fitting the sigmoidal model.
impulse_ecoli <- ImpulseDE2::runImpulseDE2(as.matrix(ec_rawcounts), 
                                           ec_design, boolCaseCtrl=TRUE,
                                           vecConfounders=NULL, scaQThres = 0.01,
                                           scaNProc = 8, 
                                           boolIdentifyTransients = TRUE)
```

### **3.3** maSigPro

maSigPro is another serial method that determines genes with significant expression differences over time and between conditions. According to Conesa and Nueda (2017), the package performs differential expression analysis by:

**1.** defining a regression model for the data with the  experimental conditions identified by dummy variables;  
**2.** using least-squared method to adjust the model;  
**3.** selecting differentially expressed genes controlling for false discovery rates;  
**4.** and applying stepwise regression to determine differential expression between groups (Conesa and Nueda 2017).

```{r prep maSigPro}
# Set up design
Time <- rep(c(0,30,60,90,120,150),6)
Replicate <- rep(1:3, 12)
Control <- c(rep(0, 6), rep(1, 6), rep(0, 6), rep(1, 6), rep(0, 6), rep(1,6))
d_Rpos <- c(rep(1, 6), rep(0, 6), rep(1, 6), rep(0, 6), rep(1, 6), rep(0, 6))
ec_design <- cbind(Time, Replicate, Control, d_Rpos)
rownames(ec_design) <- colnames(ec_rawcounts)

# Get DESeq2 normalized counts and create a design matrix
ec_normcounts <- as.data.frame(counts(ec_dds_de, normalized=TRUE))
ec_design <- make.design.matrix(ec_design, degree=5)
```


```{r run maSigPro, results='hide', cache = TRUE, message=FALSE, warning=FALSE}
# perform a regression fit for our gene expression data. 
# Set `Q = 0.01` for our significance level, 
# set `MT.adjust = "BH"` to adjust our p-values using the Benajamini & Holderberg correction method
fits <- p.vector(ec_normcounts, ec_design, Q=0.01, MT.adjust = "BH", 
                 min.obs=6, counts=TRUE)

# perform a stepwise regression fit for our gene expression data.
# Set `step.method = "backward"` and `alfa = 0.01` to specify significance level
tsep <- T.fit(fits, step.method = "backward", alfa=0.01)

# Get significant genes between delta_RpoS and Control
sigs <- get.siggenes(tsep, rsq = 0.6, vars = "groups")
maSigProGenes <- sigs$summary$d_RposvsControl
```


### **3.4** Find the Intersection

In order to balance our sensitivity with false discovery rates, we decided to consider genes differentially expressed if they were identified in at least 2 of the 3 methods.

First, we made lists of genes from all of the combinations of intersections between each method and then took the union of that list.

```{r calc intersections, message = FALSE, warning = FALSE}
# Intersect each gene list with another method
DS_IM <- distinct(data.frame("genename" = intersect(EC_sig_genes,
                                                    impulse_ecoli$vecDEGenes)))
IM_MA <- distinct(data.frame("genename" = intersect(impulse_ecoli$vecDEGenes,
                                                    maSigProGenes)))
MA_DS <- distinct(data.frame("genename" = intersect(maSigProGenes, EC_sig_genes)))

# Take the union of all three of these intersections, making sure to delete duplicate genes.
EC_DEGs <- distinct(bind_rows(DS_IM, IM_MA, MA_DS))
```

Next we can visualize this overlap with the `vennDiagram` package.

```{r plot intersection, echo=FALSE}
# Calculate the intersection of all three methods' gene lists
all_intersect <- intersect(intersect(EC_sig_genes, 
                                     impulse_ecoli$vecDEGenes), maSigProGenes)

# Calculate the size of each gene list including the intersection lists
DS <- length(EC_sig_genes)
IM <- length(impulse_ecoli$vecDEGenes)
MA <- length(maSigProGenes)
all_length <- length(all_intersect)
DS_IM_length <- length(DS_IM$genename)
IM_MA_length <- length(IM_MA$genename)
MA_DS_length <- length(MA_DS$genename)

# Plot venn diagram
grid.newpage()
draw.triple.venn(area1 = DS, area2 = IM, area3 = MA, 
                 n12= DS_IM_length, n13 = MA_DS_length, 
                 n23 = IM_MA_length, n123 = all_length, 
                 category = c("DESeq2", "ImpulseDE2", "MaSigPro"))
```

# **4** Visualization
### **4.1** Tidying Our Data

```{r join DEG counts}
# Join list of differentially expressed gene names with their normalized counts
ec_normcounts$genename <- rownames(ec_normcounts)
EC_DEGs <- left_join(EC_DEGs, ec_normcounts, by = "genename")

head(EC_DEGs[,1:7])
```

As you can see from the preview of our data, it is currently in a format where each gene has one row with all of the treatments and time points as columns. However, in order to plot our gene expression data, we want each gene at each time point and condition to have a row. We must tidy our data!

To do so, we use `tidyr` and `dplyr` functions.

```{r tidy DEGs}
EC_counts_gath <- EC_DEGs %>%
  # Gather count data for each sample by gene
  tidyr::gather(-genename, key="sample", value = "rawcount") %>%
  # Separate columns into treat and rep_time
  tidyr::separate(sample, c("treat", "rep_time"), "_") %>%
  # Create rep column from rep_time column
  dplyr::mutate(rep = ifelse(substr(rep_time,start=1,stop = 1) == "A", 1, 
                        ifelse(substr(rep_time,start=1,stop = 1) == "B", 2, 3))) %>%
  # Create time column from rep_time column
  dplyr::mutate(time = ifelse(substr(rep_time,start=3,stop = 3) == "1", 0,
                      ifelse(substr(rep_time,start=3,stop = 3) == "2", 30,
                             ifelse(substr(rep_time,start=3,stop = 3) == "3", 60,
                                    ifelse(substr(rep_time,start=3,stop = 3) == "4", 90,
                                           ifelse(substr(rep_time,start=3,stop = 3) == "5", 120, 150)))))) %>%
  # Rename treatment with more descriptive value
  dplyr::mutate(treat = ifelse(treat == "JH01", "WT","dRpoS")) %>%
  # Delete rep_time combo column
  dplyr::select(-c(rep_time))
                                      
EC_counts_ave <- EC_counts_gath %>%
  # Group data frame by genename, treatment, and time
  dplyr::group_by(genename, treat, time) %>%
  # Take the average of the rawcounts across the grouped variables
  dplyr::summarise(avecount = mean(rawcount)) %>%
  # Select only WT (our case) average count data
  filter(treat == "WT")

# Rename
colnames(EC_counts_ave) <- c("genename", "treat", "time", "avecount")
```

### **4.2** ggplot2

Finally, we can plot the tidy data using `ggplot()`.

```{r plot DEGs}
EC_counts_ave %>%
  # We also apply a `log2()` transformation to the y-axis of our expression data in order to view all of the genes on one plot.
  ggplot(aes(x=time, y=log2(avecount))) +
  # We use `geom_line()`, with the parameter `color = genename` 
  # in order to color the gene names separately and create a line plot with each gene's expression
  geom_line(aes(color = genename), alpha = 0.4) +
  # Make sure to specify `legend.position = "none"`
  theme(legend.position = "none")
```

In our case, these plots are not extremely helpful because they are so overcrowded and it is difficult to see any trends. In Section 5, we will jump into clustering methods and other analyses that can identify specific gene profiles.

### **4.3** Shiny App

Shiny is an R package that allows us to create interactive web apps inside of R. While our Shiny code is not interactive or compatible with the HTML export format, this code runs within R and creates a pop-up app that allows the viewer to visualize the gene expression data. Shiny is especially helpful when trying to determine optimal cut-offs for p-values or fold changes, or when switching between comparisons of the same data.

```{r run Shiny App, results = 'hide', echo = FALSE}
ui <- fluidPage(
  sidebarPanel(
  selectInput(inputId = "pval", label = "Choose your p-value cut-off", c(0.001,0.005,0.01,0.05,0.1)),
  numericInput(inputId = "fc", label = "Choose your Fold Change cut-off", min = 0, max = 10, value = 2),
  selectInput(inputId = "amt", label = "Choose your comparison", c("0", "30", "60", "90", "120", "150", "all"), selected = "all"),
  selectInput(inputId = "trans", label = "Transform y-axis by log2?", c("Yes", "No"), selected = "all")),
  mainPanel(plotOutput(outputId = "line", hover =  "plot_hover"),
            verbatimTextOutput("plot_hover"))
)

server <- function(input, output, session) {
  
  output$line <- renderPlot({

  contrast_vect = c(0,30,60,90,120,150)
  dRpoS_list = c("dRpoS0","dRpoS30","dRpoS60","dRpoS90","dRpoS120","dRpoS150")
  WT_list = c("WT0","WT30","WT60","WT90","WT120","WT150")

# Analyze contrasts depending on `amt` parameter
  if (input$amt == "all") {
    contrast_list = c()
    
    for (i in 1:6) {
      de_results <- results(ec_dds_de, contrast = c("timetreat",dRpoS_list[i],WT_list[i]))
      resSig <- de_results[ which(de_results$padj < input$pval ), ]
      resSig <- resSig[ which(abs(resSig$log2FoldChange) > input$fc ), ]
      resSig$gene <- rownames(resSig)
      ind <- match(ec_norm_counts$genename,resSig$gene)
      ec_norm_counts$sig <- resSig$gene[ind]
      contrast_list[[i]] <- ec_norm_counts %>%
       filter(!is.na(ec_norm_counts$sig)) %>%
       select(-sig) %>%
       mutate(contrast = contrast_vect[i])
    }
    norm_counts_contrast <- bind_rows(contrast_list[[1]],contrast_list[[2]],contrast_list[[3]],contrast_list[[4]],contrast_list[[5]],contrast_list[[6]])
  }
  
  else {
    idx = ifelse(input$amt == "0",1,
                      ifelse(input$amt == "30", 2,
                            ifelse(input$amt == "60", 3,
                                   ifelse(input$amt == "90", 4,
                                          ifelse(input$amt == "120", 5,6)))))

    de_results <- results(ec_dds_de, contrast = c("timetreat",dRpoS_list[idx], WT_list[idx]))
    resSig <- de_results[ which(de_results$padj < input$pval ), ]
    resSig <- resSig[ which(abs(resSig$log2FoldChange) > input$fc ), ]
    resSig$gene <- rownames(resSig)
    ind <- match(ec_norm_counts$genename,resSig$gene)
    ec_norm_counts$sig <- resSig$gene[ind]
    norm_counts_contrast <- ec_norm_counts %>%
     filter(!is.na(ec_norm_counts$sig)) %>%
     select(-sig) %>%
     mutate(contrast = as.numeric(input$amt))
  }

# Tidy data
  ec_counts_gath <- norm_counts_contrast %>%
    gather(-c(genename,contrast), key="sample", value = "rawcount") %>%
    separate(sample, c("treat", "rep_time"), "_") %>%
    mutate(rep = ifelse(substr(rep_time,start=1,stop = 1) == "A", 1, 
                          ifelse(substr(rep_time,start=1,stop = 1) == "B", 2, 3))) %>%
    mutate(time = ifelse(substr(rep_time,start=3,stop = 3) == "1", 0,
                        ifelse(substr(rep_time,start=3,stop = 3) == "2", 30,
                               ifelse(substr(rep_time,start=3,stop = 3) == "3", 60,
                                      ifelse(substr(rep_time,start=3,stop = 3) == "4", 90,
                                             ifelse(substr(rep_time,start=3,stop = 3) == "5", 120, 150)))))) %>%
    mutate(treat = ifelse(treat == "JH01", "WT","dRpoS")) %>%
    select(-c(rep_time))
                                        
  ec_counts_ave <- ec_counts_gath %>%
    group_by(genename, contrast, treat, time) %>%
    dplyr::summarise(avecount = mean(rawcount)) %>%
    mutate(gtreat = paste(genename,treat,sep = "")) %>%
    filter(treat == "WT")

# Plotting the data with the user chosen parameters
  # Log transformed plots facet wrapped by contrast
  if (input$trans == "Yes") {
    if (input$amt == "all") {
      ec_counts_ave %>%
        ggplot(aes(x = time)) +
        geom_line(aes(y = log2(avecount), color = gtreat, linetype = treat), alpha = 0.5) +
        geom_vline(aes(xintercept = contrast)) +
        facet_wrap(~contrast) +
        theme(legend.position = "none",panel.background = element_blank(), axis.title = element_text(size = 16)) +
        labs(x = "time (min)", y = expression("log"[2]~"(avg count)"))
    }
  # No facet wrap
    else {
      ec_counts_ave %>%
        filter(contrast == input$amt) %>%
        ggplot(aes(x=time)) +
        geom_line(aes(y=log2(avecount), color = gtreat, linetype = treat), alpha = 0.5) +
        geom_vline(aes(xintercept = contrast)) +
        theme(legend.position = "none",panel.background = element_blank(), axis.title = element_text(size = 16)) +
        labs(x = "time (min)", y = expression("log"[2]~"(avg count)"))
    }
  }
  else {
  if (input$amt == "all") {
      ec_counts_ave %>%
        ggplot(aes(x = time)) +
        geom_line(aes(y = avecount, color = gtreat, linetype = treat), alpha = 0.5) +
        geom_vline(aes(xintercept = contrast)) +
        facet_wrap(~contrast) +
        theme(legend.position = "none",panel.background = element_blank(), axis.title = element_text(size = 16)) +
        labs(x = "time (min)", y = expression("avg count"))
    }
  # No facet wrap
    else {
      ec_counts_ave %>%
        filter(contrast == input$amt) %>%
        ggplot(aes(x=time)) +
        geom_line(aes(y=avecount, color = gtreat, linetype = treat), alpha = 0.5) +
        geom_vline(aes(xintercept = contrast)) +
        theme(legend.position = "none",panel.background = element_blank(), axis.title = element_text(size = 16)) +
        labs(x = "time (min)", y = expression("avg count"))
    }
  }
  })
  
# Hover for coordinates
  
  output$plot_hover <- renderText({
   paste("Expression Coordinates: ", input$plot_hover$x, ", ", input$plot_hover$y) 
  })
}

shinyApp(ui = ui, server = server)
```

# **5** Analysis
### **5.1** PAM Clustering 

Partitioning Around Medoids (PAM) is a clustering method iteratively groups genes into clusters of genes with similar profiles. For our code, we input a dissimilarity matrix, which is the transposed matrix of the correlation between each gene, based on their counts. We use the transpose of the count matrix because we want all of the genes as columns in order to calculate the correlation. To calculate correlation, we specified the method as "spearman", however "pearson" returns similar results. The PAM method determines clusters by:  
**1.** choosing k center genes (medoids);  
**2.** assigning all of the rest of the genes to the closest medoids;  
**3.** calculating new medoids from these clusters -- in our case, this is based off of the dissimilarity matrix provided;  
**4.** repeating steps 2 and 3 until the clusters and medoids stay the same between iterations.  

First, we compute the optimal k number of clusters. This package `NbClust` runs through 30 different tests that each determine the optimal k and plots the distribution of all 30 of the optimal k results in order to determine the most common result and the *most* optimal k.

```{r calc optimal k, cache = TRUE, message=FALSE, warning=FALSE}
rownames(EC_DEGs) <- EC_DEGs$genename
EC_DEGs <- EC_DEGs %>%
  dplyr::select(-genename)

# Set `diss = NULL` because our data is not a dissimilarity matrix. 
# We set `distance = euclidean` because euclidean distance is the distance measurement 
# used by the kmeans method, which we specify as the method
k_test <- NbClust(data = EC_DEGs, diss = NULL, distance = "euclidean", 
                  min.nc = 2, max.nc = 20, method = "kmeans")
```

Take the results of this function with a grain of salt because it uses a different clustering method than the PAM method we use. While this program determines k = 3 to be the optimal number of clusters, we used k = 6 so that we did not miss any unique profiles. [This is a potential area for more research looking into the best k and the outcomes of the clusters and the significance of their GO terms depending on the number of clusters.] Then we use the PAM method to cluster the DEGs' count data.

```{r PAM clustering, warning=FALSE}
k = 6

# Calculate the dissimilarity matrix
dissimilarity_matrix <- 1 - cor(t(EC_DEGs), method = "spearman")

# Run the pam() function which clusters the data
# `pamonce = 3` speeds up the function by maximizing short cuts
EC_DESeq_clusters <- cluster::pam(x = dissimilarity_matrix, k = k, pamonce = 3)

# Create a data table with the cluster name and genename
gene_cluster <- data.frame("cluster" = EC_DESeq_clusters$clustering, 
                           "genename" = names(EC_DESeq_clusters$clustering))

# Make a data frame with the names of the medoid for each of the k clusters
EC_PAM_medoids <- data.frame("genename" = rownames(EC_DESeq_clusters$medoids))

ec_norm_counts <- ec_normcounts %>%
  mutate("genename" = rownames(ec_normcounts))

# Join the normalized counts with the clusters of genes by their genename
EC_cluster_df <- left_join(gene_cluster, ec_norm_counts, by = "genename")
```

Now, we will standardize our data using the `Mfuzz` package's `standardise()` function. The function standardizes the data so that each gene has a mean expression of 0 and a standard deviation of 1. We standardize our data with the Fuzzy package in order to visualize and understand the profiles within each cluster.

```{r Mfuzz standardization, warning=FALSE, message=FALSE}
cluster_standard <- EC_cluster_df %>%
  dplyr::select(-cluster)
rownames(cluster_standard) <- cluster_standard$genename
cluster_standard <- cluster_standard %>%
  dplyr::select(-genename)

# Create a phenotype data frame, which describes the conditions/columns of the mnain data frame.
metadata <- data.frame(labelDescription = c("treat", "rep", "time", "timetreat"))
phenoData <- new("AnnotatedDataFrame", data=ec_coldata, varMetadata=metadata)

# Convert the gene expression data frame to a matrix
clusters <- as.matrix(cluster_standard)

# Create an object of type `ExpressionSet`
eset <- Biobase::ExpressionSet(assayData = clusters, phenoData = phenoData)

# Plug `eset` into the `standardise()` function
# and extract the standardized matrix and convert it into a data frame
cluster_standardized <- Mfuzz::standardise(eset = eset)
standard_clusters <- data.frame(cluster_standardized@assayData$exprs)
standard_clusters$genename <- rownames(standard_clusters)

# Join the cluster data with the standardized expression counts
clusters <- left_join(standard_clusters, gene_cluster, by = "genename")
```

Then, we can use the tidying pipeline (see Section 4.1 for more information) to tidy the standardized data.

```{r tidy cluster data}
EC_counts_gath <- clusters %>%
  gather(-c(genename, cluster), key="sample", value = "rawcount") %>%
  separate(sample, c("treat", "rep_time"), "_") %>%
  mutate(rep = ifelse(substr(rep_time,start=1,stop = 1) == "A", 1, 
                        ifelse(substr(rep_time,start=1,stop = 1) == "B", 2, 3))) %>%
  mutate(time = ifelse(substr(rep_time,start=3,stop = 3) == "1", 0,
                      ifelse(substr(rep_time,start=3,stop = 3) == "2", 30,
                             ifelse(substr(rep_time,start=3,stop = 3) == "3", 60,
                                    ifelse(substr(rep_time,start=3,stop = 3) == "4", 90,
                                           ifelse(substr(rep_time,start=3,stop = 3) == "5", 120, 150)))))) %>%
  mutate(treat = ifelse(treat == "JH01", "WT","dRpoS")) %>%
  dplyr::select(-c(rep_time))
                                      
EC_counts_sum <- EC_counts_gath %>%
  group_by(genename, cluster, treat, time) %>%
  dplyr::summarise(avecount = mean(rawcount)) %>%
  filter(treat == "WT") %>%
  filter(!is.na(cluster))
colnames(EC_counts_sum) <- c("genename", "cluster", "treat", "time", "avecount")
```

Next, we extract the medoid genes and tidy the medoid gene expression data in order to plot the medoids on top of the gene clusters.

```{r tidy medoid data, warning=FALSE}
# Create a data frame that joins the medoid gene names
# and their standardized expression values
EC_medoid_df <- left_join(EC_PAM_medoids, clusters, by = "genename") %>%
  dplyr::select(-cluster) %>%
  mutate(cluster = c(1:k))

# Tidy medoid data (pipeline detailed in section 4.1)
EC_counts_gath_med <- EC_medoid_df %>%
  gather(-c(genename, cluster), key="sample", value = "rawcount") %>%
  separate(sample, c("treat", "rep_time"), "_") %>%
  mutate(rep = ifelse(substr(rep_time,start=1,stop = 1) == "A", 1, 
                        ifelse(substr(rep_time,start=1,stop = 1) == "B", 2, 3))) %>%
  mutate(time = ifelse(substr(rep_time,start=3,stop = 3) == "1", 0,
                      ifelse(substr(rep_time,start=3,stop = 3) == "2", 30,
                             ifelse(substr(rep_time,start=3,stop = 3) == "3", 60,
                                    ifelse(substr(rep_time,start=3,stop = 3) == "4", 90,
                                           ifelse(substr(rep_time,start=3,stop = 3) == "5", 120, 150)))))) %>%
  mutate(treat = ifelse(treat == "JH01", "WT","dRpoS")) %>%
  dplyr::select(-c(rep_time))
                                      
EC_counts_sum_med <- EC_counts_gath_med %>%
  group_by(genename, cluster, treat, time) %>%
  dplyr::summarise(avecount = mean(rawcount)) %>%
  filter(treat == "WT")
colnames(EC_counts_sum_med) <- c("genename", "cluster", "treat", "time", "avecount")
```

Now we can plot our clusters using `ggplot`.

```{r plot clusters}
EC_counts_sum %>%
  #Because we have standardized our data using the `Mfuzz` package,
  # we do not need to  transform the y-axis - just use `avecount`
  ggplot(aes(x=time, y=avecount)) +
  # We set `group = genename` and `color = as.factor(cluster)` 
  # in order to keep each gene separated and color by cluster. 
  # set alpha to a decimal smaller than 1 in order to see the overlap of genes within each cluster.
  geom_line(aes(group = genename, color = as.factor(cluster)), 
            lineend = "round" , alpha = 0.3) +
  # We use `facet_wrap()` to separate the clusters into different plots, 
  # with the same scale
  facet_wrap(~factor(cluster, labels = c("Cluster 1", "Cluster 2", 
                                         "Cluster 3", "Cluster 4", 
                                         "Cluster 5", "Cluster 6"))) +
  # Plot the medoids on top of each cluster.
  geom_line(data = EC_counts_sum_med, aes(x=time, y=avecount, group = genename), size = 1) +
  theme(legend.position = "none", panel.background = element_blank(), 
        strip.text = element_text(size = 20), 
        axis.title = element_text(size = 13), axis.text = element_text(size = 10))
```

And we create a list of data frames that contain each clusters list of genes.

```{r cluster lists}
cluster_genes <- data.frame("genename" = gene_cluster$genename)
rownames(cluster_genes) <- cluster_genes$genename
cluster_genes <- left_join(cluster_genes, gene_cluster, by = "genename") %>%
  filter(!is.na(genename))
rownames(cluster_genes) <- cluster_genes$genename

# List of data frames with gene names for each cluster called `EC_cluster`
EC_cluster <- c()
EC_cluster$cluster1 <- cluster_genes %>%
  filter(cluster == 1) %>%
  dplyr::select(genename)
EC_cluster$cluster2 <- cluster_genes %>%
  filter(cluster == 2) %>%
  dplyr::select(genename)
EC_cluster$cluster3 <- cluster_genes %>%
  filter(cluster == 3) %>%
  dplyr::select(genename)
EC_cluster$cluster4 <- cluster_genes %>%
  filter(cluster == 4) %>%
  dplyr::select(genename)
EC_cluster$cluster5 <- cluster_genes %>%
  filter(cluster == 5) %>%
  dplyr::select(genename)
EC_cluster$cluster6 <- cluster_genes %>%
  filter(cluster == 6) %>%
  dplyr::select(genename)
```

### **5.2** Gene Ontology Analysis

Gene Ontology (GO) analysis is a tool used in order to determine whether specified groups of genes have unique biological significance. Gene Ontology Analysis relies on a list of GO terms, which is a list of all of the genetic functions within the organism and the respective genes involved in each of those functions (Alexa and Rahnenfuhrer, 2019). For each of the specified groups of genes, the analysis determines whether the list of genes is disproportionately distributed across genetic functions. Compared to the null (uniform) distribution of the group's genes across all genetic functions, are the group's genes significantly enriched within specific functions?

To answer this question, we use a package called `TopGO` which has a database with all of *E. coli*'s GO terms. We can specify the statistical method used to determine whether a GO term is significant within a group of genes. Below, I provide code for the Fisher method, but the other option, a Kolmogorov-Smirnov test, is a simple substitution. GO terms are classified within three different categories: Biological Processes, Molecular Functions, and Cellular Components. After consultation with Professor Stoebel, Biological Process appears to be the most relevant in this research. However, the other two types have positives that could be more useful in other work: Molecular Function can offer specific, molecular-level information and Cellular Component can provide broad information about cell parts and structure.

```{r TopGO on clusters, message=FALSE, warning=FALSE, cache=TRUE}
# Create a function that runs GO analysis, 
# with the two parameters being the type of GO and the cluster number.
go_enrich <- function(go_type, k) {
  # Create a function within the function that 
  # returns a logical list marking whether or not a gene is in cluster k
  selection <- function(k) {
    gene_clust <- cluster_genes$cluster == k
    return(gene_clust)
  }
  # Create a factor with 2 levels: 
  # (1) integer versions (TRUE = 1 and FALSE = 0) of the logical result 
  # from the above `selection()` function 
  # and (2) their respective gene name
  GeneList <- factor(as.integer(selection(k)))
  names(GeneList) <- cluster_genes$genename
  
  # Map gene IDs to GO terms, both from database. 
  # Set `whichOnto = go_type` so that the function specifies the type of GO terms 
  # and set `ID = "symbol"` because our gene data is identified 
  # by their symbol, the four letter combination associated with each gene
  annot <- annFUN.org(whichOnto = go_type, 
                      feasibleGenes = NULL, mapping = "org.EcK12.eg", ID = "symbol")
  
  # Create a `topGOdata` object. Again, specify `ontology = go_type`. 
  # Set `allGenes = GeneList` which is our factor object with 1s and 0s and gene names. 
  # Then we set `annot = annFUN.GO2genes` and `GO2genes = annot`, 
  # our previous object of mapped gene IDs and their GO terms.
  GOdata <- new("topGOdata", ontology=go_type, allGenes=GeneList,
                annot=annFUN.GO2genes, GO2genes = annot, 
                geneSelectionFun = selection, nodeSize = 5)
  
  # Run the GO analysis, specifying the algorithm and statistic. 
  # If a Kolmogorov-Smirnov test is preferred, 
  # change `statistic = "fisher"` to `statistic = "ks"` and rename object as `resultKS`.
  resultFis <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Generate a table with the results ranked by their p-value. 
  # If a Kolmogorov-Smirnov test is preferred, 
  # change `fisherPval = "resultFis"` to `ksPval = "resultKS"`
  goEnrich <- GenTable(GOdata, fisherPval = resultFis, topNodes = 30)
  
  # Create a column that identifies the genes from the cluster 
  # within each GO term. Mostly NULL values
  ind <- match(goEnrich$GO.ID, names(annot))
  goEnrich$Gene <- annot[ind]
  return(goEnrich)
}

# Run the `go_enrich` function for each type within each cluster 
# and bind the results, specifying the type of GO term in each case
bp <- go_enrich("BP", 1) %>%
  mutate("Type" = "Biological Process")
mf <- go_enrich("MF", 1) %>%
  mutate("Type" = "Molecular Function")
cc <- go_enrich("CC", 1) %>%
  mutate("Type" = "Cellular Component")
cluster1_genes <- bind_rows(bp, mf, cc)

bp <- go_enrich("BP", 2) %>%
  mutate("Type" = "Biological Process")
mf <- go_enrich("MF", 2) %>%
  mutate("Type" = "Molecular Function")
cc <- go_enrich("CC", 2) %>%
  mutate("Type" = "Cellular Component")
cluster2_genes <- bind_rows(bp, mf, cc)

bp <- go_enrich("BP", 3) %>%
  mutate("Type" = "Biological Process")
mf <- go_enrich("MF", 3) %>%
  mutate("Type" = "Molecular Function")
cc <- go_enrich("CC", 3) %>%
  mutate("Type" = "Cellular Component")
cluster3_genes <- bind_rows(bp, mf, cc)

bp <- go_enrich("BP", 4) %>%
  mutate("Type" = "Biological Process")
mf <- go_enrich("MF", 4) %>%
  mutate("Type" = "Molecular Function")
cc <- go_enrich("CC", 4) %>%
  mutate("Type" = "Cellular Component")
cluster4_genes <- bind_rows(bp, mf, cc)

bp <- go_enrich("BP", 5) %>%
  mutate("Type" = "Biological Process")
mf <- go_enrich("MF", 5) %>%
  mutate("Type" = "Molecular Function")
cc <- go_enrich("CC", 5) %>%
  mutate("Type" = "Cellular Component")
cluster5_genes <- bind_rows(bp, mf, cc)

bp <- go_enrich("BP", 6) %>%
  mutate("Type" = "Biological Process")
mf <- go_enrich("MF", 6) %>%
  mutate("Type" = "Molecular Function")
cc <- go_enrich("CC", 6) %>%
  mutate("Type" = "Cellular Component")
cluster6_genes <- bind_rows(bp, mf, cc)

# Create a list of data frames with the results from each of the clusters
GO_clusters <- c()
GO_clusters$cl1 <- cluster1_genes
GO_clusters$cl2 <- cluster2_genes
GO_clusters$cl3 <- cluster3_genes
GO_clusters$cl4 <- cluster4_genes
GO_clusters$cl5 <- cluster5_genes
GO_clusters$cl6 <- cluster6_genes
```

### **5.3** Gene Set Enrichment Analysis

Gene Set Enrichment Analysis (GSEA) is a tool that allows us to test whether or not a determined set of genes is enriched in a list of genes with different levels of differential expression, noted by a test statistic. GSEA requires this list of genes to have a ranking statistic. In our case, we used a p-value statistic which describes the significance of the gene's differential expression. GSEA results with high positive enrichment scores indicate enrichment at the top of the ranked gene list, while large negative enrichment scores indicate enrichment at the bottom of the list.

We compared each the 6 clusters to the lists of sensitive, insensitive, and linear genes to determine whether the sensitive, insensitive, or linear genes were enriched in any of our clusters. That is, for example, were there more sensitive genes in cluster 1 than would be expected under a uniform distribution of sensitive genes? Our results were not very significant, however further analysis could potentially check other gene sets for enrichment.

```{r GSEA sensitivity enrichment in clusters, warning = FALSE, message = FALSE}

# create data frame for ranked list with all genenames and pvalues
# I used the gene list output by DESeq2 because this list has
# an adjusted pvalue associated with each gene
# and seemed to capture a lot of the genes from the venn diagram
ec_Stat <- data.frame("genename" = resSig$genename, "padj" = resSig$padj)

stat_all <- ec_Stat$padj
names(stat_all) <- ec_Stat$genename
  
cluster1 <- left_join(EC_cluster$cluster1,ec_Stat, by = "genename") %>%
  filter(!is.na(genename))
stat_cluster1 <- cluster1$padj
names(stat_cluster1) <- cluster1$genename

cluster2 <- left_join(EC_cluster$cluster2,ec_Stat, by = "genename") %>%
  filter(!is.na(genename))
stat_cluster2 <- cluster2$padj
names(stat_cluster2) <- cluster2$genename

cluster3 <- left_join(EC_cluster$cluster3,ec_Stat, by = "genename") %>%
  filter(!is.na(genename))
stat_cluster3 <- cluster3$padj
names(stat_cluster3) <- cluster3$genename

cluster4 <- left_join(EC_cluster$cluster4,ec_Stat, by = "genename") %>%
  filter(!is.na(genename))
stat_cluster4 <- cluster4$padj
names(stat_cluster4) <- cluster4$genename

cluster5 <- left_join(EC_cluster$cluster5,ec_Stat, by = "genename") %>%
  filter(!is.na(genename))
stat_cluster5 <- cluster5$padj
names(stat_cluster5) <- cluster5$genename

cluster6 <- left_join(EC_cluster$cluster6,ec_Stat, by = "genename") %>%
  filter(!is.na(genename))
stat_cluster6 <- cluster6$padj
names(stat_cluster6) <- cluster6$genename

sens <- read_csv("past_sensitivity.csv") %>%
  dplyr::select(c(geneName,bNum, 
                  `Differentially expressed between 0% and 100% RpoS`,
                  `Direction of regulation`, sensitivity)) %>%
  filter(`Differentially expressed between 0% and 100% RpoS` == TRUE) %>%
  dplyr::select(-`Differentially expressed between 0% and 100% RpoS`)

sens_name <- c()
sens_name$sensitive <- sens$geneName[which(sens$sensitivity=="sensitive")]
sens_name$insensitive <- sens$geneName[which(sens$sensitivity=="insensitive")]
sens_name$linear <- sens$geneName[which(sens$sensitivity=="linear")]

fgsea(sens_name, stat_all, minSize = 1, maxSize = 500, nperm = 10000)
fgsea(sens_name, stat_cluster1, minSize = 1, maxSize = 500, nperm = 10000)
fgsea(sens_name, stat_cluster2, minSize = 1, maxSize = 500, nperm = 10000)
fgsea(sens_name, stat_cluster3, minSize = 1, maxSize = 500, nperm = 10000)
fgsea(sens_name, stat_cluster4, minSize = 1, maxSize = 500, nperm = 10000)
fgsea(sens_name, stat_cluster5, minSize = 1, maxSize = 500, nperm = 10000)
fgsea(sens_name, stat_cluster6, minSize = 1, maxSize = 500, nperm = 10000)
```

# 6 References

```{r}
citation("dplyr")
```

Alexa A, Rahnenfuhrer J (2019). topGO: Enrichment Analysis for Gene Ontology. R package version 2.36.0.

Battesti, et al. “The RpoS-Mediated General Stress Response in Escherichia Coli.” Annual Reviews, 2011, www.annualreviews.org/doi/10.1146/annurev-micro-090110-102946.

Conesa A and Nueda MJ (2017). maSigPro: Significant Gene Expression Profile Differences in Time Course Gene Expression Data. R package version 1.50.0, http://bioinfo.cipf.es/.

Evans, Ciaran, et al. “Selecting between-Sample RNA-Seq Normalization Methods from the Perspective of Their Assumptions.” OUP Academic, Oxford University Press, 27 Feb. 2017, academic.oup.com/bib/article/19/5/776/3056951.

Fischer, David S., et al. “Impulse Model-Based Differential Expression Analysis of Time Course Sequencing Data.” BioRxiv, Cold Spring Harbor Laboratory, 1 Jan. 2017, doi.org/10.1101/113548.

Hadley Wickham, Romain François, Lionel Henry and Kirill Müller (2019). dplyr: A
  Grammar of Data Manipulation. R package version 0.8.3.
  https://CRAN.R-project.org/package=dplyr

Hengge, Regine. “Stationary-Phase Gene Regulation in Escherichia Coli&nbsp;§.” EcoSal Plus, America,   www.asmscience.org/content/journal/ecosalplus/10.1128/ecosalplus.5.6.3.

Mistry, Meeta, et al. “Gene-Level Differential Expression Analysis with DESeq2.” Introduction to      DGE, 12 May 2017, hbctraining.github.io/DGE_workshop/lessons/04_DGE_DESeq2_analysis.html.

Struyf, Anja, Mia Hubert, & Peter Rousseeuw. "Clustering in an Object-Oriented Environment." Journal   of Statistical Software [Online], 1.4 (1997): 1 - 30. Web. 17 Sep. 2019

Ross, Zev. “R Powered Web Applications with Shiny (a Tutorial and Cheat Sheet with 40 Example         Apps).” Technical Tidbits From Spatial Analysis &amp; Data Science, 13 Sept. 2017,                  zevross.com/blog/2016/04/19/r-powered-web-applications-with-shiny-a-tutorial-and-cheat-sheet-with-   40-example-apps/.
