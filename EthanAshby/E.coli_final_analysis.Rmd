---
title: Application of Sigmoidal Models to Elucidate the Timing of the RpoS Regulon
  in an E. Coli Stress Response
author: Ethan Ashby^1,4^, Annie Cohen^2,4^, Lian Morales^3,4^, Prof. Jo Hardin^1^,
  Prof. Dan Stoebel^3^, Prof. Danae Schulz^3^
output:
  pdf_document: default
  html_document:
    df_print: paged
fig_width: 6
---
Affiliation: ^1^ Pomona College, ^2^ Scripps College, ^3^ Harvey Mudd College, ^4^ NSF Data Science REU at HMC

## Abstract
  *E. coli* possesses a general stress response that coordinates physiological responses to a variety of stressful stimuli including cell starvation during exponential growth. A key transcription factor in the general stress response, RpoS, is involved in the transcription of approximately one quarter of *E. coli's* genome. Groups of genes were previously classified by their kinetics with respect to RpoS concentration: genes with expressions that increase linearly with RpoS concentration ('linear' genes), genes that are transcribed *more* than anticipated under the linear hypothesis at low RpoS concentrations ('sensitive' genes), genes that are transcribed *less* than anticipated under the linear hypothesis at low RpoS concentrations ('insensitive' genes). Fong *et al.* proposed that the graded RpoS sensitivity of these genes could function as a mechanism to control the *timing* of genes invovled in *E. coli's* response to stress (Fong *et al* 2017). To address this question, DEGs were determined using a thoughtfully-constructed pipeline, and gene-wise sigmoidal models were fit to significant *E. coli* expression trajectories using ImpulseDE2. The variability and noise robustness of the models' parameters were assessed by simulations. Analysis of the biologically meaningful "onset time" parameter did not demonstrate a statistically nor biologically significant difference between the onset times for sensitive and insensitive genes. Implications and future research directions are discussed.

## Introduction
  E. coli possesses a general stress response to a variety of environmental stresses (Battesti *et al* 2011, Hengge 2011) ranging from osmotic shock to nutrient starvation. A key transcription factor coordinating this response is RpoS, which regulates one quarter of the bacteria's genome (preliminary data from Professor Dan Stoebel). Simple interpretations of transcriptional networks often invoke an analogy of an on/off switch, in which the presence of a stimulus turns some genes on and other genes off. However, these simple interpretations don't adequately describe the complex, dyanmic processes underlying many transcriptional responses to stimuli. Currently, there exists a limited understanding regarding the dynamic nature of transcriptional responses, and the well-annotated, heavily-studied genome of E. coli presents an excellent model to study these intricate regulatory circuits.
  
  The RpoS regulon is not a static, 'switch-like' network; rather, the RpoS regulon is a highly complex regulatory circuit influenced by several factors including the duration/degree of stress (Lange and Hengge-Aronis 1994), processes like transcription, translation, and mRNA degradation (Lange and Hengge-Aronis 1994), other proteins (Pratt and Silhavy 1998), competition between transcription factors for RNA polymerase (Farewell *et al.* 1998), and even strain type (Hryckowian *et al.* 2014, Chiang *et al.* 2011). Fong and colleagues previously showed that several genes' expression increases linearly with Rpos concentration: these were dubbed 'linear' genes. However, several genes didn't follow this linear trend. Several genes were transcribed *more* than anticipated under the linear hypothesis at low RpoS concentrations: these were called 'sensitive' genes. Other genes were transcribed *less* than anticipated under the linear hypothesis at low RpoS concentrations: these were dubbed 'insensitive' genes (Figure 1) (Fong *et al* 2017). Fong and colleagues hypothesized that sensitivity to Rpos could be a mechanism to control the **timing** of genes involved in the general stress response.
  
  ![(A) osmY: a linear gene (B) astA: a sensitive gene, (C) gadC: an insenstive gene. Figure obtained from Fong *et al.* 2017](./Steobel_figure_sens_insens_linear.png)
  
  We aimed to investigate this hypothesis using an *in silico* tool, ImpulseDE2. ImpulseDE2 is a serial Time Course (TC) Differential Expression tool which fits impulse/sigmoidal models to expression trajectories and compares these dynamics models to constant/reduced models to determine differential expression over time or between time courses. The key advantage of ImpulseDE2 is that its models are parametrized by *biologically meaningful* parameters (ex. onset time), allowing researchers to leverage the parameter values to directly address biological questions (Figure 2).
  
  ![Sigmoid model for expression trajectories, parametrized by initial expression level (h0), onset time (t), onset slope (beta), and peak expression level (h1)](./Sig Model.png)
  
  We applied ImpulseDE2 to an time course (TC) RNA-Seq dataset generated by Professor Dan Stoebel. Two strains of *E. coli* - a WT strain and another strain, designated delta_RpoS, with the *rpos* gene knocked out - were allowed to grow exponentially for 150 minutes, inducing cell starvation and RpoS production (Figure 3). A thoughtful pipeline employing best-performing time course differential expression methods (DESeq2, NEXT maSigPro, and ImpulseDE2) was run on the dataset to identify differentially expressed genes. The onset time (t) parameter fitted by ImpulseDE2 was extracted for monotonically differentially expressed genes, and simulations were conducted to better understand and visualize the effects of dispersion, sample size, and outliers on all sigmoidal parameters. Then, statistical tests were applied to the timing parameters of sensitive and insensitive genes to test the hypothesis that graded sensitivity to RpoS coordinates the timing of gene expression in response to stress.


```{r, cache=TRUE, eval=T, echo=F}
#visualize RpoS kinetics
library(ggplot2)
rposconc<-read.csv("meanExpToStationaryRpoSLevels.csv", header=T)
ggplot(rposconc, aes(x=Time, y=meanRpoS, color=Trial))+geom_point(aes(size=meanDensity))+ggtitle("RpoS Kinetics During Cell Starvation")+labs(subtitle="3 replicates per trial, 3 trials")+ylab("meanRpoS conc. (M)")
```
Figure 3: RpoS kinetics over 150 min starvation time course.


## Methods
### Data Pre-Processing
RNA-Seq data was obtained in the form of read count data. Parsing code developed by Madison Hobbes was used to parse the gene identifiers, extract sequence type, gene names, and other useful information to subset the data.
Since this experiment focuses on the kinetics of gene expression, the read count data was filtered for Coding Sequences (CDS's). Rows with NA counts and 0 counts were filtered out, and duplicate genes were resolved.

```{r, cache=TRUE, include=FALSE, eval=TRUE}
#load required packages and functions
library(DESeq2)
library(tidyverse)
library(ImpulseDE2)
library(maSigPro)
library(Mfuzz)
library(cluster)
library(factoextra)
library(VennDiagram)
library(ggplot2)
library(gridExtra)
library(grid)
library(gridGraphics)
library(reshape2)
library(gdata)
foo<-function(){}
sigmoid_function<-function(b, h_0, h_1, t_1, t){
h_0 + (h_1-h_0)*(1/(1+exp(1)^(-b*(t-t_1))))
}

#read in data
allCounts <- read.csv("LB_Time_Course_GCA_000005845.2_ASM584v2_genomic_counts.tsv", header = T, sep = "\t")
```

```{r, echo=F, cache=TRUE, include=FALSE, eval=TRUE}
#collect the geneids
allCounts$GeneidBackup = allCounts$Geneid
# note that the geneids here are really long and contain a lot of information. We are going to parse those out, and first... make a separate column for gene feature (CDS, AS_CDS, IGR, etc).
```

```{r, include=F, cache=TRUE, include=FALSE, eval=TRUE}
allCounts <- allCounts %>% separate(GeneidBackup, c("feature", "rest"), sep="[:]")
allCounts %>% group_by(feature) %>% summarise(number_of_genes = n())
# Now, we must extract the genenames from each Geneid. However, each feature has a slightly different pattern, and we will need to do the features separately. 

# IGR's (this includes AS_IGRSs): 
# IGR stands for intergenic region which means a region between coding sequences or different types of RNA. Therefore, we'll have a start.bnum and end.bnum as well as a start.genename and end.genename. Note that not all genes will have a bnum (only CDS/AS_CDS do)
bnum = "b[0-9]{4}" # what do bnumbers look like?
genename = ",[a-z]{3}[A-Z,]." # what does a genename look like? this is regexp lingo
rna.name = ",rna[0-9].." # what does an RNA name look like?
igr <- allCounts %>% filter(feature %in% c("IGR", "AS_IGR"))
igr$GeneidBackup = igr$Geneid # store the Geneid
igr <- igr %>% separate(GeneidBackup, c("Geneid1", "Geneid2"), sep = "[/]") # separate the first part of the Geneid which talks about the IGR's start gene (Geneid1) and the last part of the IGR Geneid which talks about that IGR's end gene (Geneid2). 
igr$feature1 <- separate(igr, Geneid1, c("feature1", "rest"), sep = "[,]")$feature1
igr$feature1 <- separate(igr, feature1, c("rest", "feature1"), sep = "[()]")$feature1 #start feature
igr$feature2 <- separate(igr, Geneid2, c("feature2", "rest"), sep = "[,]")$feature2
igr$start.gene <- case_when( #start gene name: many possibilities!
    igr$feature1 == "CDS" ~ str_extract(igr$Geneid1, genename), #if the start feature was CDS, then the name is going to be genename style, so we extract a genename-type thing from Geneid1
    TRUE ~ str_extract(igr$Geneid1, rna.name)) #otherwise, it's going to have an RNA-style name, so we extract the rna.name from Geneid1
igr$end.gene <- case_when( #end gene neame: similar to above!
    igr$feature2 == "CDS" ~ str_extract(igr$Geneid2, genename), # if the end feature was CDS, then we're looking for a genename-type bit from Geneid2
    TRUE ~ str_extract(igr$Geneid2, rna.name)) #otherwise, it must be an RNA-style label of some sort. 
igr$start.bnum <- case_when(
    igr$feature1 == "CDS" ~ str_extract(igr$Geneid1, bnum), #bnums only exist for CDS, so we check if the feature is CDS before extracting a bnum from Geneid1
    TRUE ~ "none") # if not CDS, then no bnum exists so we can put "none"
igr$end.bnum <- case_when(
    igr$feature2 == "CDS" ~ str_extract(igr$Geneid2, bnum), #same thing as above but for end bnum
    TRUE ~ "none")
# now get rid of all those pesky commas that got into our start.gene labels. I could have not included the punctuation in my regex pattern, but then str_extract() might have gotten confused with a less specific pattern
igr <- igr %>% separate(start.gene, into = c("comma", "start.gene"), sep = "[,]") %>% select(-comma) %>% separate(end.gene, into = c("comma", "end.gene"), sep = "[,]") %>% select(-comma)
allCounts <- full_join(igr, allCounts) #add this new information to allCounts!
```

```{r, echo=F, warning = F, message = F, include=F, cache=TRUE, eval=TRUE}
# CDS
# have bnum and genename columns
# left join to allCounts
genename = ":[a-z]{3}.." #new genename pattern
#bnum pattern stays the same
cds <- allCounts %>% filter(feature %in% c("AS_CDS", "CDS")) 
cds$genename <- str_extract(cds$Geneid, genename) #extract those genenames!
cds$bnum <- str_extract(cds$Geneid, bnum) # extract them bnums!
#get rid of the pesky colon that was part of the pattern
cds <- cds %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  select(-colon)
allCounts <- full_join(allCounts, cds) #add the new info to allCounts
```

```{r, echo=F, warning = F, message = F, include=F, cache=TRUE, eval=TRUE}
#ncRNA
#ncRNA doesn't have bnums, but id's which we'll put in the genename column
rna.name = ":rna[0-9].." #new rna.name pattern
rna <- allCounts %>% filter(feature %in% c("ncRNA", "AS_ncRNA"))
rna$genename <- str_extract(rna$Geneid, rna.name) #record those rna.names
rna <- rna %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  select(-colon) #get rid of colon
allCounts <- full_join(allCounts, rna) #update allCounts with ncRNA names!
#rRNA
rRNA <- allCounts %>% filter(feature %in% c("rRNA", "AS_rRNA"))
rRNA$genename <- str_extract(rRNA$Geneid, rna.name) #same rna.name pattern exists as above, so extract those rna.names! And store the result as genename - I know. This is just for convenience's sake so we have a common column to refer to when we want the short hand name for a gene. 
rRNA <- rRNA %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  select(-colon) #get rid of that colon
allCounts <- full_join(allCounts, rRNA) #update allCounts
#tRNA -- analogous to rRNA above. 
tRNA <- allCounts %>% filter(feature %in% c("tRNA", "AS_tRNA"))
tRNA$genename <- str_extract(tRNA$Geneid, rna.name)
tRNA <- tRNA %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  select(-colon)
allCounts <- full_join(tRNA, allCounts)
# remove the NA rows we just created by full_joining while adding the ncRNA, rRNA, tRNA genenames
allCounts <- filter(allCounts, feature %in% c("IGR", "AS_IGR") | genename != "NA")

#filter by CDS, NA, 0 sums, resolve duplicates
ecounts<-allCounts %>% filter(feature=="CDS")
ecounts<-ecounts[rowSums(is.na(ecounts)) != ncol(ecounts), ]
ecounts<-subset(ecounts, rowSums(ecounts[,2:37])>0)
ecounts<- ecounts %>% dplyr::distinct(genename, .keep_all=TRUE)
rownames(ecounts)<-ecounts$genename
ecounts<-ecounts[,2:37]
head(ecounts)
```

### Identifying Differentially Expressed Genes
  Three *in silico* differential expression tools were employed to identify DEGs between the WT and delta_RpoS time courses. Previous research shows that two-sample comparisons using DESeq2 and serial tools maSigPro and ImpulseDE2 are the best performing methods to identify differentially expressed genes in TC experiments. Morever, combining gene lists generated by multiple tools reduces false positives without compromising sensitivity and is thus recommended for optimal DEG identification in TC experiments (Spies *et al.* 2019). 
  
  **DESeq2** is an algorithm that models the read counts using a negative binomial distribution and uses a trimmed mean method (TMM) to normalize the read count data across between-sample effects. DESeq2's main innovation is its Bayesian Shrunken Dispersion and LFC estimates, which improve stability and interpretability of these estimates (Love *et al* 2014). DESeq2 is one of the most widely accepted and empolyed algorithms for differential expression analysis. However, DESeq2 is not built to analyze serial (time course) data, and its categorical treatment of serial data leads to loss in predictive power. Thus, DESeq2 alone is an insufficient method to identify DEGs in TC experiments.
  
  **NEXT maSigPro** (Nueda *et al.* 2014) is a differential expression algorithm designed to analyze serial/TC RNA-Seq data. maSigPro models the gene expression value using polynomial regression with a NB Generalized Linear Model. The model's parameters are fit using maximum likelihood, and the log likelihood ratio test is applied to the full model and the null model (a flat/alternative model fit to a control time course). In the second step of maSigPro, the goodness of fit, R^2^, is computed for each optimized gene model, allowing filtering based on genes with clear expression trends. maSigPro requires data to be normalized *a priori* (we used the TMM method implemented through DESeq2) and contains a naive dispersion estimate of 10, which according to the authors does not have a substantial impact on downstream DEG identification (Nueda *et al.* 2014). maSigPro is a robust DE tool designed for analysis and interpretation of serial/TC RNA-Seq data.
  
  **ImpulseDE2** (Fischer *et al.* 2018) is another differential expression algorithm designed to analyze serial/TC RNA-Seq data. ImpulseDE2 fits impulse/sigmoidal models to the read count data by estimating the parameters using the Broyden–Fletcher– Goldfarb–Shanno algorithm.  Gene-wise dispersion estimates are generated using the bayesian shrinkage approach used in DESeq2. Differential expression is assessed using the log likelihood ratio test comparing the likelihood of the alternative and null (flat or control fit) models.
  
  Using a shiny app created by Annie Cohen, we noticed that many of E. Coli's DEGs appeared montonically differentially expessed. To capture this global expression change, we ran the categorical DE tool DESeq2 a two-sample contrast across the delta_Rpos and WT strains at the final time point (150min), when expression differences between the two time courses were putatively maximized. maSigPro was run with default arguments and results were filtered by R^2^ of 0.6 to obtain DEGs with cognizable expression trends. ImpulseDE2 was run with defaults and with the specification to differentiate between transient (impulse) and monotonic (sigmoidal/linear) DEGs.
  
  ![Shiny App image illustrating the monotonic change in expression for the majority of DEGs](./annie_shiny.jpg)
  
  Genes that were identified as significantly differentially expressed at a Benjamini-Hochberg corrected p value of less than 0.01 by two or more tools were included in our DEG list. 1126 genes were identified as DE (Figure 4).
  
  ![Venn Diagram showing DEG overlap between the three DE tools. Genes identified by 2+ tools (n=1126) were labeled as DE and subjected to further analysis](./DEG Venn E. Coli.png)
```{r DE Tools, cache=TRUE, eval=T, echo=FALSE, warning=F, message=F, error=F}
####################################################################################################################
#DESeq2
####################################################################################################################
colidesign<-data.frame(time=as.factor(rep(c("0", "30", "60", "90", "120", "150"), 6)), rep=as.factor(c(rep(1, 12), rep(2,12), rep(3,12))), treatment=as.factor(c(rep("WT",6), rep("treat",6), rep("WT",6), rep("treat",6), rep("WT",6), rep("treat",6))))

ddsecoliCountTable <- DESeqDataSetFromMatrix(
  countData = ecounts,
  colData = colidesign,
  design = ~ time + treatment +treatment:time)

#ID'ed 1090 DEGs w/ padj<0.01
ecolidds<-DESeq(ddsecoliCountTable)
res<-results(ecolidds, contrast=list(c("treatment_WT_vs_treat","time150.treatmentWT")))
res<-res[complete.cases(res),]
res<- res[res$padj<0.01,]

#####
#ImpulseDE2
#####
stoebeldesign<-data.frame(Sample=colnames(ecounts), Condition=c(rep("case",6), rep("control",6), rep("case",6), rep("control",6), rep("case",6), rep("control",6)), Time=rep(c(0,30,60,90,120,150),6))

impulse_ecoli<-ImpulseDE2::runImpulseDE2(as.matrix(ecounts), stoebeldesign, boolCaseCtrl=TRUE, vecConfounders=NULL, scaQThres = 0.01, boolIdentifyTransients = TRUE)


###################################################################################################################################
#Serial expression tool: NEXT maSigPro
###################################################################################################################################

#set up design
Time<-rep(c(0,30,60,90,120,150),6)
Replicate<-rep(1:3, 12)
Control<-c(rep(0, 6), rep(1, 6), rep(0, 6), rep(1, 6), rep(0, 6), rep(1,6))
delta_Rpos<-c(rep(1, 6), rep(0, 6), rep(1, 6), rep(0, 6), rep(1, 6), rep(0, 6))
edesign<-cbind(Time, Replicate, Control, delta_Rpos)
rownames(edesign)<-colnames(ecounts)

#run maSigPro on DESeq2 Normalized Counts, theta=10, Q=0.01
normecounts<-as.data.frame(counts(ecolidds, normalized=TRUE))
stobdesign<-make.design.matrix(edesign, degree=5)

#ID DEGs
fits<-p.vector(normecounts, stobdesign, Q=0.01, MT.adjust = "BH", min.obs=6, counts=TRUE)
#variable selection procedure to ID variables for each gene
tsep<-T.fit(fits, step.method = "backward", alfa=0.01)

#Get sig genes between delta_RpoS and Control
sigs <- get.siggenes(tsep, rsq = 0.6, vars = "groups")
maSigProGenes<-sigs$summary$delta_RposvsControl

area1 <- length(intersect(rownames(res),maSigProGenes))
area2<- length(intersect(impulse_ecoli$vecDEGenes,rownames(res)))
area3 <- length(intersect(maSigProGenes, impulse_ecoli$vecDEGenes))
area123<-length(intersect(intersect(maSigProGenes, impulse_ecoli$vecDEGenes), intersect(maSigProGenes,rownames(res))))

#draw venn diagram of DEG overlaps
draw.triple.venn(area1= length(rownames(res)), area2 = length(maSigProGenes), area3= length(impulse_ecoli$vecDEGenes), n12=area1, n23=area3, n13=area2, n123=area123, category = c("DESeq2 (0h-150 min)","maSigPro (serial)", "ImpulseDE2 (serial)"), lty = rep("blank",3), fill = c("light blue", "light green", "pink"))
```

```{r DEGs, cache=TRUE, eval=T}
###################################################################################################################
#Generate final DEG list: 1126 genes
###################################################################################################################
ecoli_DEGs<-unique(c(intersect(rownames(res),maSigProGenes), intersect(impulse_ecoli$vecDEGenes,rownames(res)), intersect(maSigProGenes, impulse_ecoli$vecDEGenes)))
```

### Simulations for Assessment of Sigmoidal Model Parameters
Simulations were conducted to understand the effects of dispersion, sample size, and outliers on the sigmoid model's parameters. The basic simulation structure takes in mean read counts estimated from the fit of a sigmoidal model to a real *E. coli* expression trajectory, and generates 100 simulated expression trajectories by adding NB noise to each profile. The amount of noise added to each profile depends on the DESeq2-estimated dispersion parameter obtained for each gene. Then, sigmoidal models are fit to the simulated trajectories using ImpulseDE2, and the distribution of simulated parameters are compared to the initial parameter values.

## Results2
###Visualizing onset times for DEGs and Insensitive & Sensitive Genes
For genes identfied as differentially expressed, onset timing parameters were extracted and plotted in a density plot (Figure 4). The bimodality/trimodality of the plot suggests that there are groups of *E. coli* genes with similar onset kinetics. Interestingly, onset time params for genes identified as *transiently* differentially expressed show strong bim

```{r Visualizing t params: mono, impulse, sens, insens, cache=TRUE, eval=T}
#########
#Visualize t params from monotonic genes, impulse genes
#########
DEmono<- impulse_ecoli$dfImpulseDE2Results[impulse_ecoli$dfImpulseDE2Results$isMonotonous==TRUE,] %>% filter(padj<0.01)
DEtrans<-impulse_ecoli$dfImpulseDE2Results[impulse_ecoli$dfImpulseDE2Results$isTransient==TRUE,] %>% filter(padj<0.01)
DEother<-impulse_ecoli$dfImpulseDE2Results %>% filter(padj<0.01) %>% filter(isTransient==FALSE) %>% filter(isMonotonous==FALSE)

#Find sensitive and insensitive genes
sensitivity<-read.xls("Sensitivity.xlsx")
#split the dataframe by sensitivity level
sensitivity<-split(sensitivity, sensitivity$sensitivity)
sensitive<-sensitivity$sensitive
linear<-sensitivity$linear
insensitive<-sensitivity$insensitive

#pull out sigmoid params for each of the monotonic DEGs
monoDE<-DEmono$Gene
monoparamsmat<-matrix(ncol=4, nrow=length(monoDE))
for (i in 1:length(monoDE)){
   monoparamsmat[i,]<-impulse_ecoli@lsModelFits[["case"]][[monoDE[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
monoparamsdf<-as.data.frame(monoparamsmat)
colnames(monoparamsdf)<-c("beta", "h0", "h1", "t")
rownames(monoparamsdf)<-monoDE

#sensitive params
sensvec<-na.omit(sensitive$geneName)
sensitivedf<-as.data.frame(matrix(ncol=4, nrow=length(sensvec)))
for (i in 1:length(sensvec)){
  index=match(sensvec[i], rownames(monoparamsdf))
  sensitivedf[i,]<-monoparamsdf[index,]}
colnames(sensitivedf)<-c("beta", "h0", "h1", "t")

#insenstive params
insensvec<-na.omit(insensitive$geneName)
insensitivedf<-as.data.frame(matrix(ncol=4, nrow=length(insensvec)))
for (i in 1:length(insensvec)){
  index=match(insensvec[i], rownames(monoparamsdf))
  insensitivedf[i,]<-monoparamsdf[index,]} 
colnames(insensitivedf)<-c("beta", "h0", "h1", "t")

#t params of montonic genes, looks somewhat bi/trimodal
ggplot(monoparamsdf, aes(x=t))+geom_density(color="blue", fill="cyan")+ xlim(50,75)+ggtitle("Distribution of sigmoid t params of 740 monotonic E. coli DEGs")

#t1 params of transient genes... definitely bimodal
transDE<-na.omit(DEtrans$Gene)
transparamsmat<-matrix(ncol=6, nrow=length(transDE))
for (i in 1:length(transDE)){
   transparamsmat[i,]<-impulse_ecoli@lsModelFits[["case"]][[transDE[i]]][["lsImpulseFit"]][["vecImpulseParam"]]}
transparamsdf<-as.data.frame(transparamsmat)
colnames(transparamsdf)<-c("beta", "h0", "h1", "h2", "t1", "t2")
rownames(transparamsdf)<-transDE
ggplot(transparamsdf, aes(x=t1))+geom_density(color="blue", fill="cyan", alpha=0.5)+ xlim(0,100)+ggtitle("Distribution of 40 impulse t1 params of monotonic E. coli DEGs")

#pull out t/t1 params of all sensitive genes, plot distribution of onset times for sensitive
sens_on<-matrix(ncol=1,nrow=0)
for (i in 1:length(sensitive$geneName)){
  if (sensitive$geneName[i] %in% rownames(monoparamsdf)){
    index=match(sensitive$geneName[i], rownames(monoparamsdf))
    sens_on<-rbind(sens_on, monoparamsdf$t[index])}
  if (sensitive$geneName[i] %in% rownames(transparamsdf)){
    index=match(sensitive$geneName[i], rownames(transparamsdf))
    sens_on<-rbind(sens_on, transparamsdf$t1[index])}
  if (sensitive$geneName[i] %in% linear$geneName){
    foo()
  }}
sens_on<-as.data.frame(sens_on)
colnames(sens_on)<-"On_times"
ggplot(sens_on, aes(x=On_times))+geom_density(color="blue", fill="cyan", alpha=0.5)+ xlim(50,100)+ggtitle("Distribution of onset times for 90 Sensitive E. coli DEGs")

#pull out t/t1 params of all insensitive genes, plot distribution of onset times for insensitive
insens_on<-matrix(ncol=1,nrow=0)
for (i in 1:length(insensitive$geneName)){
  if (insensitive$geneName[i] %in% rownames(monoparamsdf)){
    index=match(insensitive$geneName[i], rownames(monoparamsdf))
    insens_on<-rbind(insens_on, monoparamsdf$t[index])}
  if (insensitive$geneName[i] %in% rownames(transparamsdf)){
    index=match(insensitive$geneName[i], rownames(transparamsdf))
    insens_on<-rbind(insens_on, transparamsdf$t1[index])}
  if (insensitive$geneName[i] %in% linear$geneName){
    foo()
  }}
insens_on<-as.data.frame(insens_on)
colnames(insens_on)<-"On_times"
ggplot(insens_on, aes(x=On_times))+geom_density(color="red", fill="magenta", alpha=0.5)+ xlim(50,100)+ggtitle("Distribution of onset times for 18 Insensitive E. coli DEGs")

#rbind all the onset times, plot densities of onset times for both sensitive and insensitive
sens_on$type<-rep("Sensitive", dim(sens_on)[1])
insens_on$type<-rep("Insensitive", dim(insens_on)[1])
on_times<-rbind(sens_on, insens_on)
#plot the densities of the onset times
ggplot(on_times, aes(x=On_times, color=type, fill=type))+geom_density(alpha=0.5)+ xlim(50,100)+ggtitle("Distribution of onset times for 90 Sensitive & 18 Insensitive E. coli DEGs")

#Run Wilcox Rank Sum test on these t params, trimming off outliers (>70) for sens_on
wilcox.test(sens_on$On_times[sens_on$On_times<70], insens_on$On_times, alternative="two.sided", mu=0, var.equal=FALSE, conf.level=0.95)
#nearly significant... not significant at the p=0.05 level

#extract peak t params for later plotting
sens_peak<-density(sens_on$On_times)$x[which.max(density(sens_on$On_times)$y)]
insens_peak<-density(insens_on$On_times)$x[which.max(density(insens_on$On_times)$y)]
```

###Simulations
To better understand the effects of dispersion, sample size, and outliers on the sigmoid model's biologically-meaningful parameters, simulations were conducted based off real, gene-wise data from *E. coli* DEGs. 

### Effect of Dispersion on Sigmoid Parameters
The simulation pipeline was conducted under three conditions: with the *a priori* DESeq2-shrunken dispersion parameter estimates, a 100-fold *increase* in the dispersion parameter estimate (i.e. a 100-fold reduction in the noise caused by dispersion), and 100-fold *decrease* in the dispersion parameter estimate (i.e. a 100-fold increase in the noise caused by dispersion). 

With unchanged dispersion, beta, t, h0, and h1 all appeared highly reproducible, as the initial parameter values were relatively central to the distributions of simulated values. All expression trajectories were highly correlated (>0.94) to the initial trajectory

```{r Normal Dispersion Sim, cache=T, eval=TRUE, echo=FALSE, message=FALSE}
##############################################################################################################
#Simulate Sigmoid/Impulse E. Coli Data to better understand parameter confidence & upholster timing conclusions
##############################################################################################################

###################
#gadB simulation (no params changed)
###################
#times
times<-rep(c(0,30,60,90,120,150),6)

#design for sigmoid simulation through ImpulseDE2
sigmoid_design<-data.frame(Sample=colnames(ecolidds)[grep("JH01", colnames(ecolidds))], Condition=c(rep("case",18)), Time=rep(c(0,30,60,90,120,150),3))

###Ex. select one gene (gadB), extract impulse fit, and generate 100 simulated trajectories based off that one gene. Then plot all the trajectories and data on same plot. Plot distributions of sigmoid params for simulated data as well. May take a couple mins
set.seed(10)
genes<-c('gadB')
for (k in 1:length(genes)){
geneparams<-monoparamsdf[match(genes[k], rownames(monoparamsdf)),]

###extract means at each TP, scale by size factor
size_facs<-sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]
means<-sigmoid_function(as.numeric(geneparams[1]), as.numeric(geneparams[2]), as.numeric(geneparams[3]), as.numeric(geneparams[4]), unique(times))
repmeans<-c(rep(means, 3))

#index to find dispersion for gadB
disp_index=match(genes[k], names(impulse_ecoli@vecDispersions))
disp<-as.numeric(impulse_ecoli@vecDispersions[disp_index])

#generate simulated read count data for 100 trajectories w/ proper NB noise
differentially_expressed<-matrix(ncol=18, nrow=100)
for (i in 1:18){
  expressions<-c()
  expressions<-c(expressions, rnbinom(n=100, mu=repmeans[i], size=disp))
  differentially_expressed[,i]<-round(expressions*as.numeric(size_facs[i]))
}
  differentially_expressed<-as.matrix(differentially_expressed)
  colnames(differentially_expressed)<-colnames(ecolidds)[grep("JH01", colnames(ecolidds))]
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))
  
  #set manual dispersions
  dispersions<-rep(disp, 100)
  names(dispersions)<-paste(rep("gene", 100), seq(1,100))
  
  #fit impulse models
  sim_sigmoid<-ImpulseDE2::runImpulseDE2(differentially_expressed, sigmoid_design, boolCaseCtrl=FALSE, vecConfounders=NULL, boolIdentifyTransients=TRUE, scaNProc=12, scaQThres = 0.01, vecDispersionsExternal = dispersions, vecSizeFactorsExternal = size_facs)

  #extract simulated params
  sim_params_to_plot<-matrix(ncol=4, nrow=100)
  for (i in 1:100){
    sim_params_to_plot[i,]<-sim_sigmoid@lsModelFits[["case"]][[rownames(sim_sigmoid$dfImpulseDE2Results, 100)[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
  colnames(sim_params_to_plot)<-c("beta", "h0", "h1", "t")
  sim_params_to_plot<-as.data.frame(sim_params_to_plot)

  #create empirical cdfs of simulated param values to compare initial values to
  betadens<-ecdf(sim_params_to_plot$beta)
  tdens<-ecdf(sim_params_to_plot$t)
  peakdens<-dens<-ecdf(sim_params_to_plot$h1-sim_params_to_plot$h0)
  
  
#plot distributions of params
b<-ggplot(sim_params_to_plot, aes(x=beta, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$beta, color="red", show.legend = TRUE)+ggtitle(paste("Param Dist. of 100 E coli genes simulated from", genes[k], "w/ disp.=", round(disp, 2), sep=" "))+labs(subtitle=paste("Params: beta", round(as.numeric(geneparams[1]), digits=2), ",", names(geneparams[2]), round(as.numeric(geneparams[2]), digits=2), ",", names(geneparams[3]), round(as.numeric(geneparams[3]), digits=2), ",", names(geneparams[4]), round(as.numeric(geneparams[4]), digits=2)))+theme(plot.title = element_text(size = 9, face = "bold"), plot.subtitle = element_text(size = 7, face = "italic"))+xlim(round(range(monoparamsdf$beta)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(betadens(as.numeric(geneparams[1])), "quantile", sep = " "), color="red", size=3)
c<-ggplot(sim_params_to_plot, aes(x=t, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$t, color="blue")+xlim(round(range(monoparamsdf$t)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(tdens(as.numeric(geneparams[4])), "quantile", sep = " "), color="blue", size=3)
d<-ggplot(sim_params_to_plot, aes(x=h1-h0, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$h1-geneparams$h0, color="green")+xlim(-80000, 80000)+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(peakdens(as.numeric(geneparams[3])-as.numeric(geneparams[2])), "quantile", sep = " "), color="darkgreen", size=3)

#plot all expression trajectories on the same plot
plot_trajectories<-matrix(nrow=6, ncol=101)
rownames(plot_trajectories)<-unique(times)
colnames(plot_trajectories)<-c("init", paste(rep("gene", 100), seq(1,100)))
plot_trajectories[,1]<-means
for (i in 1:100){
  tmpsim<-sim_params_to_plot[i,]
  plot_trajectories[,i+1]<-sigmoid_function(tmpsim$beta, tmpsim$h0, tmpsim$h1, tmpsim$t, unique(times))
}

scores<-rep(cor(plot_trajectories, method="spearman")[,1], each=6)

counts_to_plot<-ecounts[match(genes[k], rownames(ecounts)),grep("JH01", colnames(ecounts))]*size_facs
counts_to_plot<-rbind(counts_to_plot, differentially_expressed)
counts_to_plot<-as.data.frame(t(counts_to_plot))
counts_to_plot$time<-times[1:18]

df <- melt(counts_to_plot ,  id.vars = 'time', variable.name = 'series')

plot_trajectories<-as.data.frame(plot_trajectories)
plot_trajectories$time<-unique(times)
plot_trajectories <- melt(plot_trajectories ,  id.vars = 'time', variable.name = 'series')
plot_trajectories$score<-scores

e<-ggplot(plot_trajectories[plot_trajectories$series!="init",], aes(x=time,y=log2(value),group=series)) + theme(legend.position ="none") + geom_line(aes(color=score), alpha=0.5, size=0.5)+ scale_color_gradient(low = "yellow", high = "red", name="Score", breaks=waiver(), position="right", space="Lab", guide="colourbar", aesthetics = "colour")+geom_line(data=plot_trajectories[plot_trajectories$series=="init",], aes(x=time, y=log2(value)),size=1, alpha=1)+theme_bw()+ggtitle(paste(genes[k], ": Plots of all expression trajectories (init in black)", sep=" ")) + geom_jitter(data=df, aes(x=time, y=log2(value)), alpha=0.3, color="gray47",size=0.5)+scale_x_continuous("time", breaks=c(0,30,60,90,120,150), labels=c(0,30,60,90,120,150))+geom_vline(xintercept=monoparamsdf[genes[k],]$t, linetype="dashed", color="darkblue", size=0.5)+geom_vline(xintercept=median(sim_params_to_plot$t), linetype="dashed", color="magenta")
print(grid.arrange(b, c, d, ncol=1))
print(e)
summary(sim_params_to_plot)
}
```

Increasing the dispersion-based noise lead to profound variability in the resulting simulated trajectories. The slope parameter (beta) was most affected by the additional noise, the initial value occupied the 9th quantile of the distribution of simulated parameters; this distribution had a profound right skew suggestive of high variabilities in the slopes of expression. Amplitude parameters h0 and h1 were also affected by the dispersion-based noise, as the distribution of their difference (h1-h0) profoundly shifted left from the initial value (over 30,000 units). However, the effect of dispersion-based noise was minimal in the onset time (t) parameter; the distribution of simulated onset times did not profoundly shift or widen, and the median simulated parameter and the initial parameter were separated by less than one minute. Thus, t appears to be the parameter most robust to dispersion-based noise in the sigmoidal model, an encouraging finding for RNA-seq experiments with few replicates hoping to address timing-related questions.

```{r More noise, cache=T, eval=T, echo=FALSE, message=FALSE}
###########
#Dispersion parameter decreased 100-fold
###########

set.seed(10)
genes<-c('gadB')
for (k in 1:length(genes)){
geneparams<-monoparamsdf[match(genes[k], rownames(monoparamsdf)),]

###extract means at each TP, scale by size factor
size_facs<-sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]
means<-sigmoid_function(as.numeric(geneparams[1]), as.numeric(geneparams[2]), as.numeric(geneparams[3]), as.numeric(geneparams[4]), unique(times))
repmeans<-c(rep(means, 3))

#index to find dispersion for gadB
disp_index=match(genes[k], names(impulse_ecoli@vecDispersions))
disp<-as.numeric(impulse_ecoli@vecDispersions[disp_index])

#generate simulated read count data for 100 trajectories w/ proper NB noise, add one to each count to ensure no rows of all zero counts
differentially_expressed<-matrix(ncol=18, nrow=100)
for (i in 1:18){
  expressions<-c()
  expressions<-c(expressions, rnbinom(n=100, mu=repmeans[i], size=disp/100)+1)
  differentially_expressed[,i]<-round(expressions*as.numeric(size_facs[i]))
}
  differentially_expressed<-as.matrix(differentially_expressed)
  colnames(differentially_expressed)<-colnames(ecolidds)[grep("JH01", colnames(ecolidds))]
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))
  
  #set manual dispersions
  dispersions<-rep(disp/100, 100)
  names(dispersions)<-paste(rep("gene", 100), seq(1,100))
  
  #fit impulse models
  sim_sigmoid<-ImpulseDE2::runImpulseDE2(differentially_expressed, sigmoid_design, boolCaseCtrl=FALSE, vecConfounders=NULL, boolIdentifyTransients=TRUE, scaNProc=12, scaQThres = 0.01, vecDispersionsExternal = dispersions, vecSizeFactorsExternal = size_facs)

  #extract simulated params
  sim_params_to_plot<-matrix(ncol=4, nrow=100)
  for (i in 1:100){
    sim_params_to_plot[i,]<-sim_sigmoid@lsModelFits[["case"]][[rownames(sim_sigmoid$dfImpulseDE2Results, 100)[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
  colnames(sim_params_to_plot)<-c("beta", "h0", "h1", "t")
  sim_params_to_plot<-as.data.frame(sim_params_to_plot)

  #create empirical cdfs of simulated param values to compare initial values to
  betadens<-ecdf(sim_params_to_plot$beta)
  tdens<-ecdf(sim_params_to_plot$t)
  peakdens<-dens<-ecdf(sim_params_to_plot$h1-sim_params_to_plot$h0)
  
  
#plot distributions of params
b<-ggplot(sim_params_to_plot, aes(x=beta, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$beta, color="red", show.legend = TRUE)+ggtitle(paste("Param Dist. of 100 E coli genes simulated from", genes[k], "w/ disp.=", round(disp/100, 2), sep=" "))+labs(subtitle=paste("Params: beta", round(as.numeric(geneparams[1]), digits=2), ",", names(geneparams[2]), round(as.numeric(geneparams[2]), digits=2), ",", names(geneparams[3]), round(as.numeric(geneparams[3]), digits=2), ",", names(geneparams[4]), round(as.numeric(geneparams[4]), digits=2)))+theme(plot.title = element_text(size = 9, face = "bold"), plot.subtitle = element_text(size = 7, face = "italic"))+xlim(round(range(monoparamsdf$beta)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(betadens(as.numeric(geneparams[1])), "quantile", sep = " "), color="red", size=3)
c<-ggplot(sim_params_to_plot, aes(x=t, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$t, color="blue")+xlim(round(range(monoparamsdf$t)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(tdens(as.numeric(geneparams[4])), "quantile", sep = " "), color="blue", size=3)
d<-ggplot(sim_params_to_plot, aes(x=h1-h0, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$h1-geneparams$h0, color="green")+xlim(-80000, 80000)+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(peakdens(as.numeric(geneparams[3])-as.numeric(geneparams[2])), "quantile", sep = " "), color="darkgreen", size=3)

#plot all expression trajectories on the same plot
plot_trajectories<-matrix(nrow=6, ncol=101)
rownames(plot_trajectories)<-unique(times)
colnames(plot_trajectories)<-c("init", paste(rep("gene", 100), seq(1,100)))
plot_trajectories[,1]<-means
for (i in 1:100){
  tmpsim<-sim_params_to_plot[i,]
  plot_trajectories[,i+1]<-sigmoid_function(tmpsim$beta, tmpsim$h0, tmpsim$h1, tmpsim$t, unique(times))
}

scores<-rep(cor(plot_trajectories, method="spearman")[,1], each=6)

counts_to_plot<-ecounts[match(genes[k], rownames(ecounts)),grep("JH01", colnames(ecounts))]*size_facs
counts_to_plot<-rbind(counts_to_plot, differentially_expressed)
counts_to_plot<-as.data.frame(t(counts_to_plot))
counts_to_plot$time<-times[1:18]

df <- melt(counts_to_plot ,  id.vars = 'time', variable.name = 'series')

plot_trajectories<-as.data.frame(plot_trajectories)
plot_trajectories$time<-unique(times)
plot_trajectories <- melt(plot_trajectories ,  id.vars = 'time', variable.name = 'series')
plot_trajectories$score<-scores

e<-ggplot(plot_trajectories[plot_trajectories$series!="init",], aes(x=time,y=log2(value),group=series)) + theme(legend.position ="none") + geom_line(aes(color=score), alpha=0.5, size=0.5)+ scale_color_gradient(low = "yellow", high = "red", name="Score", breaks=waiver(), position="right", space="Lab", guide="colourbar", aesthetics = "colour")+geom_line(data=plot_trajectories[plot_trajectories$series=="init",], aes(x=time, y=log2(value)),size=1, alpha=1)+theme_bw()+ggtitle(paste(genes[k], ": Plots of all expression trajectories (init in black), dispersion decreased 100-fold", sep=" ")) + geom_jitter(data=df, aes(x=time, y=log2(value)), alpha=0.3, color="gray47",size=0.5)+scale_x_continuous("time", breaks=c(0,30,60,90,120,150), labels=c(0,30,60,90,120,150))+geom_vline(xintercept=monoparamsdf[genes[k],]$t, linetype="dashed", color="darkblue", size=0.5)+geom_vline(xintercept=median(sim_params_to_plot$t), linetype="dashed", color="magenta")
print(grid.arrange(b, c, d, ncol=1))
print(e)
summary(sim_params_to_plot)
}
```

```{r less noise, cache=T, eval=FALSE, echo=FALSE, message=FALSE}
##########
#Dispersion parameter decreased 100-fold
##########

#NOTE: Excluded from analysis, because it's less informative. Increasing sample size will give us more confidence in the amplitude parameters, but these simulations will overfit the sigmoid curves to the data, causing shifts in beta and t away from the initial values that aren't informative of our model.

set.seed(10)
genes<-c('gadB')
for (k in 1:length(genes)){
geneparams<-monoparamsdf[match(genes[k], rownames(monoparamsdf)),]

###extract means at each TP, scale by size factor
size_facs<-sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]
means<-sigmoid_function(as.numeric(geneparams[1]), as.numeric(geneparams[2]), as.numeric(geneparams[3]), as.numeric(geneparams[4]), unique(times))
repmeans<-c(rep(means, 3))

#index to find dispersion for gadB
disp_index=match(genes[k], names(impulse_ecoli@vecDispersions))
disp<-as.numeric(impulse_ecoli@vecDispersions[disp_index])

#generate simulated read count data for 100 trajectories w/ proper NB noise
differentially_expressed<-matrix(ncol=18, nrow=100)
for (i in 1:18){
  expressions<-c()
  expressions<-c(expressions, rnbinom(n=100, mu=repmeans[i], size=disp*100))
  differentially_expressed[,i]<-round(expressions*as.numeric(size_facs[i]))
}
  differentially_expressed<-as.matrix(differentially_expressed)
  colnames(differentially_expressed)<-colnames(ecolidds)[grep("JH01", colnames(ecolidds))]
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))
  
  #set manual dispersions
  dispersions<-rep(disp*100, 100)
  names(dispersions)<-paste(rep("gene", 100), seq(1,100))
  
  #fit impulse models
  sim_sigmoid<-ImpulseDE2::runImpulseDE2(differentially_expressed, sigmoid_design, boolCaseCtrl=FALSE, vecConfounders=NULL, boolIdentifyTransients=TRUE, scaNProc=12, scaQThres = 0.01, vecDispersionsExternal = dispersions, vecSizeFactorsExternal = size_facs)

  #extract simulated params
  sim_params_to_plot<-matrix(ncol=4, nrow=100)
  for (i in 1:100){
    sim_params_to_plot[i,]<-sim_sigmoid@lsModelFits[["case"]][[rownames(sim_sigmoid$dfImpulseDE2Results, 100)[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
  colnames(sim_params_to_plot)<-c("beta", "h0", "h1", "t")
  sim_params_to_plot<-as.data.frame(sim_params_to_plot)

  #create empirical cdfs of simulated param values to compare initial values to
  betadens<-ecdf(sim_params_to_plot$beta)
  tdens<-ecdf(sim_params_to_plot$t)
  peakdens<-dens<-ecdf(sim_params_to_plot$h1-sim_params_to_plot$h0)
  
  
#plot distributions of params
b<-ggplot(sim_params_to_plot, aes(x=beta, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$beta, color="red", show.legend = TRUE)+ggtitle(paste("Param Dist. of 100 E coli genes simulated from", genes[k], "w/ disp.=", round(disp*100, 2), sep=" "))+labs(subtitle=paste("Params: beta", round(as.numeric(geneparams[1]), digits=2), ",", names(geneparams[2]), round(as.numeric(geneparams[2]), digits=2), ",", names(geneparams[3]), round(as.numeric(geneparams[3]), digits=2), ",", names(geneparams[4]), round(as.numeric(geneparams[4]), digits=2)))+theme(plot.title = element_text(size = 9, face = "bold"), plot.subtitle = element_text(size = 7, face = "italic"))+xlim(round(range(monoparamsdf$beta)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(betadens(as.numeric(geneparams[1])), "quantile", sep = " "), color="red", size=3)
c<-ggplot(sim_params_to_plot, aes(x=t, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$t, color="blue")+xlim(round(range(monoparamsdf$t)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(tdens(as.numeric(geneparams[4])), "quantile", sep = " "), color="blue", size=3)
d<-ggplot(sim_params_to_plot, aes(x=h1-h0, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$h1-geneparams$h0, color="green")+xlim(-80000, 80000)+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(peakdens(as.numeric(geneparams[3])-as.numeric(geneparams[2])), "quantile", sep = " "), color="darkgreen", size=3)

#plot all expression trajectories on the same plot
plot_trajectories<-matrix(nrow=6, ncol=101)
rownames(plot_trajectories)<-unique(times)
colnames(plot_trajectories)<-c("init", paste(rep("gene", 100), seq(1,100)))
plot_trajectories[,1]<-means
for (i in 1:100){
  tmpsim<-sim_params_to_plot[i,]
  plot_trajectories[,i+1]<-sigmoid_function(tmpsim$beta, tmpsim$h0, tmpsim$h1, tmpsim$t, unique(times))
}

scores<-rep(cor(plot_trajectories, method="spearman")[,1], each=6)

counts_to_plot<-ecounts[match(genes[k], rownames(ecounts)),grep("JH01", colnames(ecounts))]*size_facs
counts_to_plot<-rbind(counts_to_plot, differentially_expressed)
counts_to_plot<-as.data.frame(t(counts_to_plot))
counts_to_plot$time<-times[1:18]

df <- melt(counts_to_plot ,  id.vars = 'time', variable.name = 'series')

plot_trajectories<-as.data.frame(plot_trajectories)
plot_trajectories$time<-unique(times)
plot_trajectories <- melt(plot_trajectories ,  id.vars = 'time', variable.name = 'series')
plot_trajectories$score<-scores

e<-ggplot(plot_trajectories[plot_trajectories$series!="init",], aes(x=time,y=log2(value),group=series)) + theme(legend.position ="none") + geom_line(aes(color=score), alpha=0.5, size=0.5)+ scale_color_gradient(low = "yellow", high = "red", name="Score", breaks=waiver(), position="right", space="Lab", guide="colourbar", aesthetics = "colour")+geom_line(data=plot_trajectories[plot_trajectories$series=="init",], aes(x=time, y=log2(value)),size=1, alpha=1)+theme_bw()+ggtitle(paste(genes[k], ": Plots of all expression trajectories (init in black), dispersion increased 100-fold", sep=" ")) + geom_jitter(data=df, aes(x=time, y=log2(value)), alpha=0.3, color="gray47",size=0.5)+scale_x_continuous("time", breaks=c(0,30,60,90,120,150), labels=c(0,30,60,90,120,150))+geom_vline(xintercept=monoparamsdf[genes[k],]$t, linetype="dashed", color="darkblue", size=0.5)+geom_vline(xintercept=median(sim_params_to_plot$t), linetype="dashed", color="magenta")
print(grid.arrange(b, c, d, ncol=1))
print(e)
plot(seq(0,150,1), log(sigmoid_function(b=as.numeric(geneparams[1]), h_0=as.numeric(geneparams[2]), h_1=as.numeric(geneparams[3]), t_1=as.numeric(geneparams[4]), t=seq(0,150,1))), type="l", col="red")
lines(seq(0,150,1), log(sigmoid_function(b=sim_params_to_plot[3,1], h_0=sim_params_to_plot[3,2], h_1=sim_params_to_plot[3,3], t_1=sim_params_to_plot[3,4], seq(0,150,1))))
}
```

### Effect of more TPs on Sigmoid Parameters

For the following simulation, gadB's sigmoid model was extracted and mean read counts were calculated at time points (TPs) 0, 15, 30, 45, 55, 60, 65, 70, 75, 80, 85, 90, 120, 135, and 150 minutes to simulate data collection at more time points. Simulated data at these time points were generated and sigmoid models were fit. As anticipated, the increase in number of time points afforded better resolution in the onset time (t) and slope (beta) parameters: the width of these distributions of simulated values shrunk and were both centered around the initial values. To illustrate, the addition of more TPs resulted in a difference between initial onset time and median simulated onset time of 0.218 mins, an improvement over previous simulations with fewer time points. This simulation affirms the importance of increasing number of time points in discerning the timing of gene expression using RNA-Seq. 

```{r Sample Size Sims, cache=T, eval=TRUE, echo=FALSE, message=FALSE}

#############################################################################################
#Examine effect of more time points
#############################################################################################

#build new design and new times
Times<-rep(c(0,15,30,45,55,60,65,70,75,80,85,90,120,135,150), 3)
design_more_TPs<-data.frame(Sample=c("JH01_A01","JH01_A02", "JH01_A03", "JH01_A04", "JH01_A05", "JH01_A06", "JH01_A07", "JH01_A08", "JH01_A09", "JH01_A010","JH01_A011","JH01_A012", "JH01_A013", "JH01_A014", "JH01_A015", "JH01_B01","JH01_B02","JH01_B03","JH01_B04","JH01_B05","JH01_B06","JH01_B07","JH01_B08","JH01_B09","JH01_B10","JH01_B11","JH01_B12","JH01_B13","JH01_B14","JH01_B15","JH01_C01","JH01_C02","JH01_C03","JH01_C04","JH01_C05","JH01_C06","JH01_C07","JH01_C08","JH01_C09","JH01_C010","JH01_C11","JH01_C12","JH01_C13","JH01_C14","JH01_C15" ), Condition=rep("case",45), Time=Times)

set.seed(11)
genes<-c("gadB")
for (k in 1:length(genes)){
  geneparams<-monoparamsdf[match(genes[k], rownames(monoparamsdf)),]
  ###extract means at each TP, scale by size factor
  means<-sigmoid_function(as.numeric(geneparams[1]), as.numeric(geneparams[2]), as.numeric(geneparams[3]), as.numeric(geneparams[4]), unique(Times))
  repmeans<-rep(means, 3)
  #let's generate some random sizeFactors ensuring no negative/0 size factors
  size_facs<-rnorm(45, mean=mean(sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]), sd=sd(sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]))
  for (i in 1:length(size_facs)){
  if (size_facs[i]<0.5) {size_facs[i]=min(sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))])}}
  names(size_facs)<-design_more_TPs$Sample
  
#index to find dispersion for gadB
disp_index=match(genes[k], names(impulse_ecoli@vecDispersions))
disp<-as.numeric(impulse_ecoli@vecDispersions[disp_index])

#generate simulated read count data for 100 trajectories w/ proper NB noise
differentially_expressed<-matrix(ncol=45, nrow=100)
for (i in 1:45){
  expressions<-c()
  expressions<-c(expressions, rnbinom(n=100, mu=repmeans[i], size=disp))
  differentially_expressed[,i]<-round(expressions*as.numeric(size_facs[i]))
}
  differentially_expressed<-as.matrix(differentially_expressed)
  colnames(differentially_expressed)<-names(size_facs)
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))
  colnames(differentially_expressed)<-design_more_TPs$Sample
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))

  #set manual dispersions
  dispersions<-rep(disp, 100)
  names(dispersions)<-paste(rep("gene", 100), seq(1,100))
  
  #fit impulse models
  sim_plus<-ImpulseDE2::runImpulseDE2(differentially_expressed, design_more_TPs, boolCaseCtrl=FALSE, boolIdentifyTransients=TRUE, vecConfounders=NULL, scaNProc=12, scaQThres = 0.01, vecDispersionsExternal = dispersions, vecSizeFactorsExternal = size_facs)

  #extract simulated params
  sim_params_to_plot<-matrix(ncol=4, nrow=100)
  for (i in 1:100){
    sim_params_to_plot[i,]<-sim_plus@lsModelFits[["case"]][[rownames(sim_plus$dfImpulseDE2Results, 100)[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
  colnames(sim_params_to_plot)<-c("beta", "h0", "h1", "t")
  sim_params_to_plot<-as.data.frame(sim_params_to_plot)
  
  betadens<-ecdf(sim_params_to_plot$beta)
  tdens<-ecdf(sim_params_to_plot$t)
  peakdens<-dens<-ecdf(sim_params_to_plot$h1-sim_params_to_plot$h0)

b<-ggplot(sim_params_to_plot, aes(x=beta, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$beta, color="red", show.legend = TRUE)+ggtitle(paste("Param Dist. of 100 E coli genes simulated from", genes[k], "w/ disp.=", round(disp/100, 2), sep=" "))+labs(subtitle=paste("Params: beta", round(as.numeric(geneparams[1]), digits=2), ",", names(geneparams[2]), round(as.numeric(geneparams[2]), digits=2), ",", names(geneparams[3]), round(as.numeric(geneparams[3]), digits=2), ",", names(geneparams[4]), round(as.numeric(geneparams[4]), digits=2)))+theme(plot.title = element_text(size = 9, face = "bold"), plot.subtitle = element_text(size = 7, face = "italic"))+xlim(round(range(monoparamsdf$beta)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(betadens(as.numeric(geneparams[1])), "quantile", sep = " "), color="red", size=3)
c<-ggplot(sim_params_to_plot, aes(x=t, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$t, color="blue")+xlim(round(range(monoparamsdf$t)))+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(tdens(as.numeric(geneparams[4])), "quantile", sep = " "), color="blue", size=3)
d<-ggplot(sim_params_to_plot, aes(x=h1-h0, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$h1-geneparams$h0, color="green")+xlim(-80000, 80000)+annotate(geom="text", -Inf, Inf, hjust=-3, vjust=0.99, label=paste(peakdens(as.numeric(geneparams[3])-as.numeric(geneparams[2])), "quantile", sep = " "), color="darkgreen", size=3)  

plot_trajectories<-matrix(nrow=15, ncol=101)
rownames(plot_trajectories)<-unique(Times)
colnames(plot_trajectories)<-c("init", paste(rep("gene", 100), seq(1,100)))
plot_trajectories[,1]<-means
for (i in 1:100){
  tmpsim<-sim_params_to_plot[i,]
  plot_trajectories[,i+1]<-sigmoid_function(tmpsim$beta, tmpsim$h0, tmpsim$h1, tmpsim$t, unique(Times))
}

scores<-rep(cor(plot_trajectories, method="spearman")[,1], each=15)

counts_to_plot<-repmeans*size_facs
counts_to_plot<-rbind(counts_to_plot, differentially_expressed)
counts_to_plot<-as.data.frame(t(counts_to_plot))
counts_to_plot$time<-Times[1:45]

df <- melt(counts_to_plot ,  id.vars = 'time', variable.name = 'series')

plot_trajectories<-as.data.frame(plot_trajectories)
plot_trajectories$time<-unique(Times)
plot_trajectories <- melt(plot_trajectories ,  id.vars = 'time', variable.name = 'series')
plot_trajectories$score<-scores

e<-ggplot(plot_trajectories[plot_trajectories$series!="init",], aes(x=time,y=log2(value),group=series)) + theme(legend.position ="none") + geom_line(aes(color=score), alpha=0.5, size=0.5)+ scale_color_gradient(low = "yellow", high = "red", name="Score", breaks=waiver(), position="right", space="Lab", guide="colourbar", aesthetics = "colour")+geom_line(data=plot_trajectories[plot_trajectories$series=="init",], aes(x=time, y=log2(value)),size=1, alpha=1)+theme_bw()+ggtitle(paste(genes[k], ": Plots of all expression trajectories (init in black), dispersion decreased 100-fold", sep=" ")) + geom_jitter(data=df, aes(x=time, y=log2(value)), alpha=0.3, color="gray47",size=0.5)+scale_x_continuous("time", breaks=c(0,15,30,45,60,75,90,105,120,135,150), labels=c(0,15,30,45,60,75,90,105,120,135,150))+geom_vline(xintercept=monoparamsdf[genes[k],]$t, linetype="dashed", color="darkblue", size=0.5)+geom_vline(xintercept=median(sim_params_to_plot$t), linetype="dashed", color="magenta")
print(grid.arrange(b, c, d, ncol=1))
print(e)
summary(sim_params_to_plot)
}

#plot distributions of monotonic t params
ggplot(monoparamsdf, aes(x=t))+geom_density(color="blue", fill="cyan")+ xlim(50,75)+ggtitle("Distribution of sigmoid t params of 740 monotonic E. coli DEGs")
```
In addition, according to the distribution of monotonic onset time parameters, around 92% of the DEGs have onset times between 55 and 75 minutes. Thus, concentrating RNA extractions at TPs between 55 and 75 minutes could yield more sensitive resolution.

### Effect of outliers on Sigmoid Parameters


### Sigmoid parameters of Sensitive and Insensitive Genes
```{r Sigmoid Sensitive/Insenstive Sims, cache=TRUE, eval=FALSE}
#pull out 5 monotonic sensitive, 5 monotonic insensitive genes, 1 monotonic linear gene
set.seed(11)
genes<-c(as.vector(sample(sensitive$geneName[sensitive$geneName %in% monoDE], 5)), as.vector(sample(insensitive$geneName[insensitive$geneName %in% monoDE], 5)), as.vector(sample(linear$geneName[linear$geneName %in% monoDE], 1)))
pdf("sens_insens_linear.pdf", onefile = TRUE)
for (k in 1:length(genes)){
geneparams<-monoparamsdf[match(genes[k], rownames(monoparamsdf)),]

###extract means at each TP, scale by size factor
size_facs<-sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]
means<-sigmoid_function(as.numeric(geneparams[1]), as.numeric(geneparams[2]), as.numeric(geneparams[3]), as.numeric(geneparams[4]), unique(times))
repmeans<-c(rep(means, 3))

#index to find dispersion for talB
disp_index=match(genes[k], names(impulse_ecoli@vecDispersions))
disp<-as.numeric(impulse_ecoli@vecDispersions[disp_index])

#generate simulated read count data for 100 trajectories w/ proper NB noise
differentially_expressed<-matrix(ncol=18, nrow=100)
for (i in 1:18){
  expressions<-c()
  expressions<-c(expressions, rnbinom(n=100, mu=repmeans[i], size=disp))
  differentially_expressed[,i]<-round(expressions*as.numeric(size_facs[i]))
}
  differentially_expressed<-as.matrix(differentially_expressed)
  colnames(differentially_expressed)<-colnames(ecolidds)[grep("JH01", colnames(ecolidds))]
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))
  
  #set manual dispersions
  dispersions<-rep(disp, 100)
  names(dispersions)<-paste(rep("gene", 100), seq(1,100))
  
  #fit impulse models
  sim_sigmoid<-ImpulseDE2::runImpulseDE2(differentially_expressed, sigmoid_design, boolCaseCtrl=FALSE, vecConfounders=NULL, boolIdentifyTransients=TRUE, scaNProc=12, scaQThres = 0.01, vecDispersionsExternal = dispersions, vecSizeFactorsExternal = size_facs)

  #extract simulated params
  sim_params_to_plot<-matrix(ncol=4, nrow=100)
  for (i in 1:100){
    sim_params_to_plot[i,]<-sim_sigmoid@lsModelFits[["case"]][[rownames(sim_sigmoid$dfImpulseDE2Results, 100)[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
  colnames(sim_params_to_plot)<-c("beta", "h0", "h1", "t")
  sim_params_to_plot<-as.data.frame(sim_params_to_plot)

#plot distributions of params
b<-ggplot(sim_params_to_plot, aes(x=beta, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$beta, color="red")+ggtitle(paste("Param Dist. of 100 E coli genes simulated from", genes[k], "w/ disp.=", round(disp, 2), sep=" "))+labs(subtitle=paste("Params: beta", round(as.numeric(geneparams[1]), digits=2), ",", names(geneparams[2]), round(as.numeric(geneparams[2]), digits=2), ",", names(geneparams[3]), round(as.numeric(geneparams[3]), digits=2), ",", names(geneparams[4]), round(as.numeric(geneparams[4]), digits=2)))+theme(plot.title = element_text(size = 14, face = "bold"), plot.subtitle = element_text(size = 12, face = "italic"))+xlim(round(range(monoparamsdf$beta)))
c<-ggplot(sim_params_to_plot, aes(x=t, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$t, color="blue")+xlim(50,100)
d<-ggplot(sim_params_to_plot, aes(x=h1-h0, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$h1-geneparams$h0, color="green")+xlim(round(range(monoparamsdf$h1-monoparamsdf$h0)))

#plot all expression trajectories on the same plot
plot_trajectories<-matrix(nrow=6, ncol=101)
rownames(plot_trajectories)<-unique(times)
colnames(plot_trajectories)<-c("init", paste(rep("gene", 100), seq(1,100)))
plot_trajectories[,1]<-means
for (i in 1:100){
  tmpsim<-sim_params_to_plot[i,]
  plot_trajectories[,i+1]<-sigmoid_function(tmpsim$beta, tmpsim$h0, tmpsim$h1, tmpsim$t, unique(times))
}

scores<-rep(cor(plot_trajectories, method="spearman")[,1], each=6)

counts_to_plot<-ecounts[match(genes[k], rownames(ecounts)),grep("JH01", colnames(ecounts))]*size_facs
counts_to_plot<-rbind(counts_to_plot, differentially_expressed)
counts_to_plot<-as.data.frame(t(counts_to_plot))
counts_to_plot$time<-times[1:18]

df <- melt(counts_to_plot ,  id.vars = 'time', variable.name = 'series')

plot_trajectories<-as.data.frame(plot_trajectories)
plot_trajectories$time<-unique(times)
plot_trajectories <- melt(plot_trajectories ,  id.vars = 'time', variable.name = 'series')
plot_trajectories$score<-scores

e<-ggplot(plot_trajectories[plot_trajectories$series!="init",], aes(x=time,y=log2(value),group=series)) + theme(legend.position ="none") + geom_line(aes(color=score), alpha=0.5, size=0.5)+ scale_color_gradient(low = "yellow", high = "red", name="Score", breaks=waiver(), position="right", space="Lab", guide="colourbar", aesthetics = "colour")+geom_line(data=plot_trajectories[plot_trajectories$series=="init",], aes(x=time, y=log2(value)),size=1, alpha=1)+theme_bw()+ggtitle(paste(genes[k], ": Plots of all expression trajectories (init in black)", sep=" ")) + geom_jitter(data=df, aes(x=time, y=log2(value)), alpha=0.3, color="gray47",size=0.5)+scale_x_continuous("time", breaks=c(0,30,60,90,120,150), labels=c(0,30,60,90,120,150))+geom_vline(xintercept=monoparamsdf[genes[k],]$t, linetype="dashed", color="darkblue", size=0.5)+geom_vline(xintercept=sens_peak, linetype="dashed", color="blue")+geom_vline(xintercept=insens_peak, linetype="dashed", color="red")
print(grid.arrange(b, c, d, ncol=1))
print(e)}
```

```{r Exploratory Analysis}

#Go thru monoparamsdf and ascribe sensitive, insensitive, linear to genes
monoparamsdf$sens<-rep(NA, dim(monoparamsdf)[1])
monoparamsdf$sens[match(rownames(monoparamsdf)[rownames(monoparamsdf) %in% sensitive$geneName], rownames(monoparamsdf))]<-"Sensitive"
monoparamsdf$sens[match(rownames(monoparamsdf)[rownames(monoparamsdf) %in% insensitive$geneName], rownames(monoparamsdf))]<-"Insensitive"
monoparamsdf$sens[match(rownames(monoparamsdf)[rownames(monoparamsdf) %in% linear$geneName], rownames(monoparamsdf))]<-"linear"
ggplot(monoparamsdf, aes(x=t, y=log(h1/h0), color=sens))+geom_jitter(size=1)
ggplot(monoparamsdf, aes(x=t, y=log(h1/h0), color=sens))+geom_jitter(size=1)+xlim(50,150)+ylim(-10,10)

###fuzzy clustering based on scaled mean expression profiles

library(Mfuzz)
library(cluster)
size_facs<-sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]
cluster_data<-matrix(ncol=6,nrow=dim(monoparamsdf)[1])
for (i in 1:dim(monoparamsdf)[1]){
  index<-match(rownames(monoparamsdf)[i], rownames(ecounts[,grep("JH01",colnames(ecounts))]))
  cluster_data[i,]<-c(mean(ecounts[,grep("JH01",colnames(ecounts))][index,1]*size_facs[1], ecounts[,grep("JH01",colnames(ecounts))][index,7]*size_facs[7], ecounts[,grep("JH01",colnames(ecounts))][index,13]*size_facs[13]), mean(ecounts[,grep("JH01",colnames(ecounts))][index,2]*size_facs[2], ecounts[,grep("JH01",colnames(ecounts))][index,8]*size_facs[8], ecounts[,grep("JH01",colnames(ecounts))][index,14]*size_facs[14]), mean(ecounts[,grep("JH01",colnames(ecounts))][index,3]*size_facs[3], ecounts[,grep("JH01",colnames(ecounts))][index,9]*size_facs[9], ecounts[,grep("JH01",colnames(ecounts))][index,15]*size_facs[15]), mean(ecounts[,grep("JH01",colnames(ecounts))][index,4]*size_facs[4], ecounts[,grep("JH01",colnames(ecounts))][index,10]*size_facs[10], ecounts[,grep("JH01",colnames(ecounts))][index,16]*size_facs[16]), mean(ecounts[,grep("JH01",colnames(ecounts))][index,5]*size_facs[5], ecounts[,grep("JH01",colnames(ecounts))][index,11]*size_facs[11], ecounts[,grep("JH01",colnames(ecounts))][index,17]*size_facs[17]), mean(ecounts[,grep("JH01",colnames(ecounts))][index,6]*size_facs[6], ecounts[,grep("JH01",colnames(ecounts))][index,12]*size_facs[12], ecounts[,grep("JH01",colnames(ecounts))][index,18]*size_facs[18]))
  }
rownames(cluster_data)<-rownames(monoparamsdf)
colnames(cluster_data)<-c(0,30,60,90,120,150)
Set<-ExpressionSet(cluster_data)
Set.s<-standardise(Set)
scaleddata<-t(scale(t(cluster_data)))

#run clustering
cl<-mfuzz(Set.s, c=4, m=mestimate(Set.s))

#plot clusters
mfuzz.plot(Set.s, cl, mfrow=c(2,2), time.labels = c(0,30,60,90,120,150), min.mem=0, new.window=FALSE)

#visualize cluster overlap
overlap.plot(cl, overlap(cl), thres=0.01)

#select cores
cores<-acore(Set.s, cl, min.acore=0.1)

monoparamsdf$cluster<-rep(NA, dim(monoparamsdf)[1])
for (i in 1:dim(monoparamsdf)[1]){
  if (rownames(monoparamsdf)[i] %in% cores[[1]]$NAME) {monoparamsdf$cluster[i]<-"1"}
  else if (rownames(monoparamsdf)[i] %in% cores[[2]]$NAME) {monoparamsdf$cluster[i]<-"2"}
  else if (rownames(monoparamsdf)[i] %in% cores[[3]]$NAME) {monoparamsdf$cluster[i]<-"3"}
  else if (rownames(monoparamsdf)[i] %in% cores[[4]]$NAME) {monoparamsdf$cluster[i]<-"4"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[5]]$NAME) {monoparamsdf$cluster[i]<-"5"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[6]]$NAME) {monoparamsdf$cluster[i]<-"6"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[7]]$NAME) {monoparamsdf$cluster[i]<-"7"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[8]]$NAME) {monoparamsdf$cluster[i]<-"8"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[9]]$NAME) {monoparamsdf$cluster[i]<-"9"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[10]]$NAME) {monoparamsdf$cluster[i]<-"10"}
  #else if (rownames(monoparamsdf)[i] %in% cores[[11]]$NAME) {monoparamsdf$cluster[i]<-"11"}
  else foo()
}
ggplot(monoparamsdf, aes(x=t, y=log(h1/h0), color=cluster, shape=sens))+geom_jitter(size=1)+xlim(25,160)
ggplot(monoparamsdf, aes(x=t, y=log(h1/h0), color=cluster, shape=sens))+geom_jitter(size=1)+xlim(25,160)+facet_wrap(vars(cluster), nrow=6, ncol=2)

#GO each core
library(topGO)
library(org.EcK12.eg.db)
enrich<-function(core){
selection <- function(x) TRUE
GeneList <- c(1:length(core))
names(GeneList) <- core
annot <- annFUN.org(whichOnto = "BP", feasibleGenes = NULL, mapping = "org.EcK12.eg", ID = "symbol")
GOdata <- new("topGOdata", ontology="BP", allGenes=GeneList, annot=annFUN.GO2genes, GO2genes = annot, geneSel = selection, nodeSize = 5)
GO_results <- runTest(GOdata, algorithm = "classic", statistic = "ks")
goEnrich <- GenTable(GOdata, KS = GO_results, orderBy = "KS", topNodes = 10)
GO_terms<-goEnrich[,c("GO.ID", "Term", "KS")] %>% filter(KS<0.05)
GO_terms}

enrich(cores[[1]]$NAME)
enrich(cores[[2]]$NAME)
enrich(cores[[3]]$NAME)
enrich(cores[[4]]$NAME)
enrich(cores[[5]]$NAME)
enrich(cores[[6]]$NAME)
enrich(cores[[7]]$NAME)
enrich(cores[[8]]$NAME)
enrich(cores[[9]]$NAME)
enrich(cores[[10]]$NAME)
enrich(cores[[11]]$NAME)

### What if I cluster based on the read counts obtained from sigmoid profiles

```




```{r, eval=FALSE}
#Visualize some of prof Stoebel's "genes of interest"
set.seed(11)
genesofinterest<-read.table("genesOfInterest.txt", sep="\t", header=TRUE)$geneName
genes<-as.vector(sample(genesofinterest, 5))
pdf("GOI_Sim.pdf", onefile = TRUE)
for (k in 1:length(genes)){
geneparams<-monoparamsdf[match(genes[k], rownames(monoparamsdf)),]

###extract means at each TP, scale by size factor
size_facs<-sizeFactors(ecolidds)[grep("JH01", names(sizeFactors(ecolidds)))]
means<-sigmoid_function(as.numeric(geneparams[1]), as.numeric(geneparams[2]), as.numeric(geneparams[3]), as.numeric(geneparams[4]), unique(times))
repmeans<-c(rep(means, 3))

#index to find dispersion for talB
disp_index=match(genes[k], names(impulse_ecoli@vecDispersions))
disp<-as.numeric(impulse_ecoli@vecDispersions[disp_index])

#generate simulated read count data for 100 trajectories w/ proper NB noise
differentially_expressed<-matrix(ncol=18, nrow=100)
for (i in 1:18){
  expressions<-c()
  expressions<-c(expressions, rnbinom(n=100, mu=repmeans[i], size=disp))
  differentially_expressed[,i]<-round(expressions*as.numeric(size_facs[i]))
}
  differentially_expressed<-as.matrix(differentially_expressed)
  colnames(differentially_expressed)<-colnames(ecolidds)[grep("JH01", colnames(ecolidds))]
  rownames(differentially_expressed)<-paste(rep("gene", 100), seq(1,100))
  
  #set manual dispersions
  dispersions<-rep(disp, 100)
  names(dispersions)<-paste(rep("gene", 100), seq(1,100))
  
  #fit impulse models
  sim_sigmoid<-ImpulseDE2::runImpulseDE2(differentially_expressed, sigmoid_design, boolCaseCtrl=FALSE, vecConfounders=NULL, boolIdentifyTransients=TRUE, scaNProc=12, scaQThres = 0.01, vecDispersionsExternal = dispersions, vecSizeFactorsExternal = size_facs)

  #extract simulated params
  sim_params_to_plot<-matrix(ncol=4, nrow=100)
  for (i in 1:100){
    sim_params_to_plot[i,]<-sim_sigmoid@lsModelFits[["case"]][[rownames(sim_sigmoid$dfImpulseDE2Results, 100)[i]]][["lsSigmoidFit"]][["vecSigmoidParam"]]}
  colnames(sim_params_to_plot)<-c("beta", "h0", "h1", "t")
  sim_params_to_plot<-as.data.frame(sim_params_to_plot)

#plot distributions of params
b<-ggplot(sim_params_to_plot, aes(x=beta, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$beta, color="red")+ggtitle(paste("Param Dist. of 100 E coli genes simulated from", genes[k], "w/ disp.=", round(disp, 2), sep=" "))+labs(subtitle=paste("Params: beta", round(as.numeric(geneparams[1]), digits=2), ",", names(geneparams[2]), round(as.numeric(geneparams[2]), digits=2), ",", names(geneparams[3]), round(as.numeric(geneparams[3]), digits=2), ",", names(geneparams[4]), round(as.numeric(geneparams[4]), digits=2)))+theme(plot.title = element_text(size = 14, face = "bold"), plot.subtitle = element_text(size = 12, face = "italic"))+xlim(round(range(monoparamsdf$beta)))
c<-ggplot(sim_params_to_plot, aes(x=t, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$t, color="blue")+xlim(50,100)
d<-ggplot(sim_params_to_plot, aes(x=h1-h0, y=..density..))+geom_density()+geom_vline(xintercept=geneparams$h1-geneparams$h0, color="green")+xlim(round(range(monoparamsdf$h1-monoparamsdf$h0)))

#plot all expression trajectories on the same plot
plot_trajectories<-matrix(nrow=6, ncol=101)
rownames(plot_trajectories)<-unique(times)
colnames(plot_trajectories)<-c("init", paste(rep("gene", 100), seq(1,100)))
plot_trajectories[,1]<-means
for (i in 1:100){
  tmpsim<-sim_params_to_plot[i,]
  plot_trajectories[,i+1]<-sigmoid_function(tmpsim$beta, tmpsim$h0, tmpsim$h1, tmpsim$t, unique(times))
}

scores<-rep(cor(plot_trajectories, method="spearman")[,1], each=6)

counts_to_plot<-ecounts[match(genes[k], rownames(ecounts)),grep("JH01", colnames(ecounts))]*size_facs
counts_to_plot<-rbind(counts_to_plot, differentially_expressed)
counts_to_plot<-as.data.frame(t(counts_to_plot))
counts_to_plot$time<-times[1:18]

df <- melt(counts_to_plot ,  id.vars = 'time', variable.name = 'series')

plot_trajectories<-as.data.frame(plot_trajectories)
plot_trajectories$time<-unique(times)
plot_trajectories <- melt(plot_trajectories ,  id.vars = 'time', variable.name = 'series')
plot_trajectories$score<-scores

e<-ggplot(plot_trajectories[plot_trajectories$series!="init",], aes(x=time,y=log2(value),group=series)) + theme(legend.position ="none") + geom_line(aes(color=score), alpha=0.5, size=0.5)+ scale_color_gradient(low = "yellow", high = "red", name="Score", breaks=waiver(), position="right", space="Lab", guide="colourbar", aesthetics = "colour")+geom_line(data=plot_trajectories[plot_trajectories$series=="init",], aes(x=time, y=log2(value)),size=1, alpha=1)+theme_bw()+ggtitle(paste(genes[k], ": Plots of all expression trajectories (init in black)", sep=" ")) + geom_jitter(data=df, aes(x=time, y=log2(value)), alpha=0.3, color="gray47",size=0.5)+scale_x_continuous("time", breaks=c(0,30,60,90,120,150), labels=c(0,30,60,90,120,150))+geom_vline(xintercept=monoparamsdf[genes[k],]$t, linetype="dashed", color="darkblue", size=0.5)+geom_vline(xintercept=sens_peak, linetype="dashed", color="blue")+geom_vline(xintercept=insens_peak, linetype="dashed", color="red")
print(grid.arrange(b, c, d, ncol=1))
print(e)}
```

## References:
Fischer, D. S., Theis, F. J., & Yosef, N. (2018). Impulse model-based differential expression analysis of time course sequencing data. Nucleic Acids Research, 46(20), 1–10. https://doi.org/10.1093/nar/gky675
Fong, A. J. L., Shull, L. M., Batachari, L. E., Dillon, M., Evans, C., Becker, C. J., … Daniel, S.   (2017). Genome-Wide Transcriptional Response to Varying RpoS Levels in Escherichia coli K-12. Journal of Bacteriology, 199(7), 1–17.
Love, M. I., Huber, W., & Anders, S. (2014). Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biology, 15(12), 1–21. https://doi.org/10.1186/s13059-014-0550-8
Nueda, M. J., Tarazona, S., & Conesa, A. (2014). Next maSigPro: Updating maSigPro bioconductor package for RNA-seq time series. Bioinformatics, 30(18), 2598–2602. https://doi.org/10.1093/bioinformatics/btu333
Spies, D., Renz, P. F., Beyer, T. A., & Ciaudo, C. (2019). Comparative analysis of differential gene expression tools for RNA sequencing time course data. Briefings in Bioinformatics, 20(1), 1–11. https://doi.org/10.1093/bib/bbx115

