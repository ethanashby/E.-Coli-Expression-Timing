---
title: "Analysis of Trypanosma Brucei RNA-Seq data"
author: "Lian Morales, Annie Cohen, Ethan Ashby"
date: "7/22/2019"
output: 
  pdf_document:
    latex_engine: xelatex
bibliography: bibliography.bib
---

```{r, include=FALSE}
knitr::opts_chunk$set(cache = TRUE,warning = FALSE)

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
 
#Data Manipulation
library("dplyr")
library("tidyr")
library(readr)
library(devtools)
library("vsn")
library("hexbin")
library("tidyverse")
library(stringr)
library("Hmisc")
library(factoextra)

#clustering
library(jtools)
library(Mfuzz)
library(tcltk2) 
library(tkWidgets)

#DEG tools 
library("DESeq2")
library(cluster)
library("mclust")
library(ImpulseDE2)
library(maSigPro)
library(edgeR)

#for visualzation
library(VennDiagram)
library(ggplot2)
library("corrplot")

#for GSEA
library(doParallel)
library(Biobase)
library(biomaRt)
library(fgsea)
library(BiocParallel)
#tinytex::install_tinytex()
library(tinytex)
```

# Table of Contents  
1. Background  
\indent 1.1 Abstract  
\indent 1.2 Goals  
2. Methods  
\indent 2.1 Normalization  
\indent 2.2 Differential Expression Analysis  
3. Clustering  
4. Comparing Data  
\indent 4.1 Savage Data  
\indent 4.2 Savage Methods  
5. Gene Ontology Analysis     
\indent 5.1 Schulz GO  
\indent 5.2 Savage GO  
6.Gene Set Enrichment Analysis  
\indent 6.1 Clusters  
\indent 6.2 Savage  
7. Conclusion 
8. Acknowledgements  
9. References  

# 1. Background   

# 1.1 Abstract   
West African Sleeping Sickness is a deadly disease contracted by the bite of an infected Tsetse fly carrying the protozoan parasite *Trypanosoma Brucei*. This sickness is fatal in mammals and humans, as parasites proliferate in lymphatic, blood, nervous systems, and eventually the brain. Symptoms include disrupted sleep, behavioral changes,neurological damage, and death if left untreated. Due to the limited studies of this illness and harmful drug treatments, motivation to understand the complexity and nature of *Trypanosoma Brucei* become pertinent to world wide health and safety. 

Trypanosome surface proteins can directly interact with the host environment, allowing parasites to effectively establish and maintain infections(Savage 2015). During its infectious cycle, the parasite maintains several life stages throughout changing environments of insect and mammal. When living in the fly, the parasite's surface is covered with an invariant procylin, or proteins developed in the surface coating of *Trypanosoma brucei* in the Procyclic form(PF). However, upon living in the mammal, the parasite resides extracellularly in the bloodstream and becomes densely covered with highly immunogenic Variant Surface Glycoprotein (VSG). In this bloodstream form (BF), the parasite can vary its outer surface using approximately 2,500 distinct VSG genes. As a result, *Trypanosoma brucei* can evade human/mammal antibody immune response and remain virulent by constantly interchanging VSG genes.

For BF in mammals, the role of histone acetyl-lysine recognizing bromodomain proteins, in controlling of stem cell fate, lead to the hypothesis that bromodomain proteins may maintain the BF cell fate in trypanosomes. Histone lysine acetylation is central to epigenetic control of gene transcription. Thus, bromodomain inhibition disrupts two major BF specific immune evasion mechanisms that trypanosomes harness to evade mammalian antibody immune response. Of these functions, monoallelic expression of VSGs are disrupted, and rapid internalization of antibodies bound to VSGs on the surface of the trypanosome is blocked. Through these results, bromodomain inhibition in BF trypanosomes reveals changes in the transcriptome similar to PF trypanosomes. Importantly, bromodomain inhibition leads to a decrease in virulence in a mouse model of infection, establishing these proteins as potential therapeutic drug targets for trypanosomiasis.

This summer 2019, we looked at the result of research studying the effects of bromodomain inhibition in PF trypanosomes. Building off of past research that found bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, Professor Schulz and her lab measured gene expression in WT PF and bromodomain-inhibited PF over 2 week time course, determined differentially expressed genes (DEGs) between these two conditions in order to understand the effect of bromodomain inhibition on gene expression in insect form through data analysis.

# 1.2 Goals   

Building off of past research, and showed bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, what is the result of inhibiting bromodomain in PF trypanosome? 

# 2. Methods  
To begin the analysis of T.*brucei* data, we must understand the experiment's variables, conditions, and hypothesis. Schulz's data is a time course experiment with 10 samples with three replicates, excluding sample time point at 3 hours -- three hours repetition 1 was removed because it was an outlier.  The data was then sent to be processed by RNA-seq, which is a way to measure gene expression in an organism. Also commonly known as High Throughput Sequencing, this process uses next-generation sequencing to reveal the presence and quantity of RNA in a biological sample at a given moment. The RNA is extracted and RNA reads (sequences of A, G, C, and U) are aligned to the organism's genome. The higher the number of reads, or inferred sequence of base pairs (or base pair probabilities) corresponding to all or part of a single DNA fragment, mapped to a certain gene the more that gene is expressed (Ruairi , Mackenzie J. “RNA-Seq: Basics, Applications and Protocol.”).

# 2.1 Normalization   
  In order to analyze raw read counts, we must normalize them to account for factors that prevent direct comparison of expression measures. Length, GC-content, and sequencing depth are big factors inLength and GC-content are major factors that affect the number of reads mapped to a gene. Only length and GC content are within-sample effects, meaning that they affect the comparison of read counts between different genes in a sample. Sequencing depth, which is the number of reads covering each position(column sum), on the other hand, is a between-sample effect that alters the comparison of read counts between the same gene in different samples.
  In RNA-seq, coverage pattern is very uneven due to differences in expression, so one must account for unequal samples through normalization. In order to ascertain the best normalization method for out data, our first step was comparing Differential Expression tools edgeR and DESeq2. 

# `DESeq2` @DESeq2
DESeq normalizes raw count data using the algorithm Relative Log Expression(RLE). It first takes the geometric mean of all sample values, or the raw counts for each gene in a particular sample. This creates the reference sample of the data set. Then, DESeq2 takes the median of the number of observed reads in condition k and replicate r  and divides this value by the reference sample. As the algorithm completes this for all genes, the resulting vector is the ‘size factor’ of the particular sample. Size factors represent how deeply the sample is sequenced, and the ratio of the size factors of two different samples is an approximation of the ratio of their sequencing depths. 

# `edgeR` @edgeR
edgeR normalizes raw counts using Trimmed Mean Method(TMM). TMM first prenomalizes by library size, by dividing the observed number of reads for gene g in condition k and replicate r by the total number of reads for condition k and replicate r. For TMM, the arbitrary reference sample is condition and replicate 1, however one can specify what reference sample to use.  
For TMM, it takes the set of not trimmed genes with valid fold change and the absolute expression levels (cf. Robinson and Oshlack, 2010) and uses this value to calculate the relative scaling factor. Additionally, TMM scales this factor by multiplying it to one, thus giving a vector of normalization factor. These normalization factors are used as offset parameters in the statistical model for differential gene expression analysis. 


The result of this comparison was that DESeq2 and edgeR gave very similar results, with a small amount of different DEGS. As a result, our choice between DESeq2 and edgeR was more arbitrary, as DESeq2’s algorithm was preferable to fast run time and simple input. However, to understand the main differences and similarities between these two specific methods, comparing DESeq2 size factors and edgeR normalization factors and creating a VennDiagram of DEG’s identified by each method allowed for a clearer understanding of each algorithm, as well as our data. We then created a new data frame with information ofthe columns, or gene names.  

```{r,cache=TRUE}
TBcounts <- read.table("18-5-23_Proc_ibet_TC_for_deseq.txt",header = TRUE) %>% dplyr ::select(-ib_3h_1) 
TBcounts <- TBcounts %>% dplyr :: distinct(gene, .keep_all = TRUE) 

rownames(TBcounts) <- TBcounts$gene #renames the gene row
TBcounts <- TBcounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
#creating new data frame for DESeq to analyze
tb_new <- data.frame(rownames = colnames(TBcounts),
                     reps = as.factor(c(1,2,3,1,2,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3)),
                    stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3))))
rownames(tb_new) <- tb_new$rownames
tb_new <- tb_new %>% dplyr ::select(-rownames)

```
 As you can see in the code above, the breakdown of our data involves separating the repetitions of the samples and times, or stages of the experiment. In the first line, we see that the treated sample 1 at 3 hours(ib_3h_1) is not included in our data analysis. This is because it is an outlier determined by Professor Schulz. 



# DESeq2 Normalization  

The first step for DESeq2 normalization involves creating a count matrix with specified count data, column data, and design features. Here, we used reps + stage for the sample number(rep) and the time(stage) at which the sample was taken. Then, the function DESeq() of that matrix run the differential expression analysis, and from this output we can extract the normalized counts and size factors. 
```{r, echo = FALSE, cache = TRUE}
#dds stands for the DESeq Data Set
ddsFullCountTable <- DESeqDataSetFromMatrix(countData = TBcounts,
                                            colData = tb_new, 
                                            design = ~ reps + stage)

TBcounts_dds <- DESeq(ddsFullCountTable)

#calculating norm counts
##DESeq2 :: allows to specify where this fcn comes from
norm_counts <- as.data.frame(counts(TBcounts_dds, normalized = TRUE)) %>%
  mutate(gene = rownames(TBcounts))
 
 
```

```{r}
head(norm_counts)

```
#  edgeR Normalization  

Similar to DESeq, we will need to create a new data frame detailing the samples, time, and repetitions. For this data set, stage = treatment and time, and rep = sample repetition. 

For edgeR, the function calcNormFactors() calculates normalized counts, and return library size of each sample, normalization factor, and group of each sample. In this example, variable 'tb_normfact' represents the normalization factors that calcNormFactors() of Schulz raw counts outputs. For edgeR, the function 'filterByExpr()' gets rid of genes that are not expressed, or with zero counts.
  

```{r, echo = FALSE}
#DE WITH EDGER
#for easy data manipulation, creating DGE list from 
#TBcounts and data table tb_new(with columns stage, reps)
tbcounts_dge <- DGEList(counts = TBcounts, norm.factors = rep(1,ncol(TBcounts)), group = tb_new$stage, remove.zeros = TRUE)

#creating design matrix of reps and stage
design <- model.matrix(~ tb_new$reps + tb_new$stage)
rownames(design) <- colnames(TBcounts)

#FILTER data -- getting rid of non expressed genes
keep <- filterByExpr(tbcounts_dge)
table(keep)
tbcounts_dge <- tbcounts_dge[keep, ,keep.lib.sizes = FALSE]
 
#NORMALIZE DATA - USING CALCNORMFACTORS()

tb_norm <- calcNormFactors(tbcounts_dge, method = "TMM", refColumn = NULL)
#separating the counts and samples
tbcounts <- tb_norm$counts
tb_normfact <- tb_norm$samples$norm.factors
 
#getting the norm counts
tb_normCounts <- cpm(tbcounts_dge)
```
The first comparison between methods edgeR and DESeq2 was normalization and size factors. In order to compare DESeq2's size factor and edgeR's normalization factor, we must multiply the normalization factor by the library size for each sample. In edgeR, the equivalent to the size factor is the effective library size(Cierian). That is, the normalization factor captures sample-specific bias beyond differences in library size. In this graph, one can see that the multiplied normalization factors  and DESeq2's size factors follow a clear linear trend, leading to the conclusion that these values are very similar. 

```{r, echo = FALSE}
tb_norm_sf <- data.frame(tb_normfact* colSums(TBcounts))
colnames(tb_norm_sf) <- "TMM.size.fact"
size.DESeq2 <- TBcounts_dds$sizeFactor
size.edgeR <- tb_norm_sf$TMM.size.fact
plot(size.DESeq2, size.edgeR, main = "Size Factor DESeq & edgeR")
 
```

The second comparison between algorithms DESeq2 and edgeR were the amount of differentially expressed genes at comparison time points 0-12 hours. In edgeR, the FDR was filtered with 0.01, and for edgeR, the padj was filtered at 0.01. For DESeq2, we will use the results function to contrast stages 0 to 12 hours.  
```{r, echo = FALSE}
#COMPARING - DE ANALYSIS - FOR GSEA

#comparing stages noo_ib and ib_12h --- the stage of non inhibited bromodomain at time 0 to inhibited bromodomain at time point 12 hours
TBcountsRes <- results( TBcounts_dds ,contrast = c("stage","ib_12h", "noo_ib"))
#resSig_012 stands for the results of the significant genes expressed in comparison of noo_ib and ib_12h
resSig_012 <- TBcountsRes[ which(TBcountsRes$padj < 0.01 ), ]

```

```{r}

#DE ANALYSIS - EDGER - getting the DE genes

#comparing 6h to noo, under hypothesis that 6h-noo = 0 
stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3)))
design <- model.matrix(~0 + stage)
rownames(design) <- colnames(tb_norm)
con <- makeContrasts(stageib_6h-stagenoo_ib , levels= design)
est_disp <- estimateDisp(tb_norm, design, robust=TRUE)
fit <- glmQLFit(est_disp, design, robust=TRUE)
qlf <- glmQLFTest(fit, contrast = con) 
 
#now want to look at all de genes from toptags which are the top de genes
out <- topTags(qlf, n=Inf, adjust.method="BH")  
keep <- out$table$FDR <= 0.01 #filtering genes with FDR 0.01 
de_table <- out[keep,] #de_table for the table of DE genes

```

As we can see in this VennDiagram below that both methods shows similarity between the algorithms of nomalizing raw counts. For our analysis we chose DESeq2 over edgeR due to earier coding and familiarity with the package.  
```{r}
#making venn diagram
area1 <- length(rownames(resSig_012))    
area2 <- length(rownames(de_table))  
cross <- length(intersect(rownames(resSig_012), rownames(de_table)))
 
grid.newpage()
draw.pairwise.venn(area1= area1, area2 = area2, cross.area = cross, category = c("DESeq","edgeR"))
```

# 2.2 Differential Expression Analysis   
  Based on the large amount of genes in T.*brucei* data, using more than one method to identify DEGs must be used to provide accurate results for our analysis. Due to the large number of differential expression algorithms, we used three tools becuase we would better indentify real DEGs and resuce the number of false positives. The three methods we used were `DESeq2`, `ImpulseDE2`, and `maSigPro`. 
  Differential expression analysis algorithms for time course datasets can be divided into methods that treat time points independently and methods that explicitly model the dependence between time points. Methods that utilize the former approach are mostly based on generalized linear models, with the sampling time point as a categorical variable that is then used as a predictor for the expression level (Fischer *et.al* 2018). These methods include software packages `DESeq2` and `edgeR`. For our analysis, as previously discussed, we will use `DESeq2` for the remainder of Normalization and Differential Expression analysis. 
  
  The methods that explicitly model the dependence between time points constrain the sequence of measured expression levels to a continuous function of time, thus capturing the dependence of expression levels between time points. Such continuous dependence on time has previously been captured with non-linear models based on a spline basis transform of the time coordinate such as `ImpulseDE2`. `ImpulseDE2` models the gene-wise expression trajectories over time with a descriptive single-pulse (impulse) function and employs a noise model specific to count data from multiple batches and combines it with a likelihood ratio test, leading to much faster and more accurate inference (Fischer *et.al* 2018). Due to `ImpulseDE2` popularity and accuracy cited in recent reports(Spies D. *et.al* 2017), we chose to use this model to identify T.*brucei* DEGs. 
  
  Another serial method we used was the Differential Expression package `maSigPro`. `maSigPro` follows a two step regression strategy to find genes with significant temporal expression changes and significant differences between experimental groups. The method defines a general regression model for the data where the experimental groups are identified by dummy variables. The procedure first adjusts this global model by the least-squared technique to identify differentially expressed genes and selects significant genes applying false discovery rate control procedures. Secondly, stepwise regression is applied as a variable selection strategy to study differences between experimental groups and to find statistically significant different profiles. The coefficients obtained in this second regression model will be useful to cluster together significant genes with similar expression patterns and to visualize the results (Conesa *et.al* 2017).

 Because we are more interested in earlier time points of Schulz's time course experiment due to the increased gene expression shown from 0-12 hours, our DEG analysis will compare time points 0 & 12 hours. 
 
# DESeq2   
Beginning with DESeq2, the results for a comparison of any two levels of a variable can be calculated using the contrast argument to the results function. The function requires three values: the name of the variable, the name of the level in the numerator, and the name of the level in the denominator.  
Here we extract results for the log2 of the fold change of treated 12h and untreated 0h, ib_12h / noo_ib. 


```{r}
#COMPARING - DE ANALYSIS - FOR GSEA

#comparing stages noo_ib and ib_12h --- the stage of non inhibited bromodomain at time 0 to inhibited bromodomain at time point 12 hours
TBcountsRes <- results( TBcounts_dds ,contrast = c("stage","ib_12h", "noo_ib"))
 
```

In order to correct for multiple testing, the package @DESeq2 uses Benjamini-Hochberg (BH) adjustment, which is a method that decreases the false discovery rate(FDR). Due to the fact that small p-values often happen by chance, the tool helps remove the possibility of falsely rejecting the true null hypothesis. For example, if one had a very low p-value(<.05), it would mean that there is only a 5% chance that you would get your observed result granted the null was true. Thus, with a p value of 0.05, it is unlikely that your null is correct. The BH adjustment adjusts for the probability of a FDR. For example, if one called all genes that are significant are those with a p value less than or equal to a gene’s p value threshold, the BH method calculates the fraction of false positives among those genes. In a test of 1000 genes with a p value cutoff of 0.05, one would expect 50 genes to be DE by random chance alone. The fraction of false positives among those genes, called the BH-adjusted p values, are given in the column padj of the results object.

For our data, we considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for T.*brucei* dataset. We consider all genes with an adjusted p value below 1% = 0.01 as significant. We filtered those genes by using function which() and speficied in the TBcountsRes data set the padj values < 0.01. 

```{r}
#resSig_012 stands for the results of the significant genes expressed in comparison of noo_ib and ib_12h
resSig_012 <- TBcountsRes[ which(TBcountsRes$padj < 0.01 ), ]
resSig_012 <- resSig_012[complete.cases(resSig_012),]
resSig_012$gene <- rownames(resSig_012)
resSig_012$fcsign <- sign(resSig_012$log2FoldChange) #fcsign stands for the log2foldchange sign
resSig_012_df <- data.frame(resSig_012)
head(resSig_012,3)

#creating negative and positive logfold change data sets
resSig_log.pos <- resSig_012[which(resSig_012$fcsign != -1),]
resSig_log.neg <- resSig_012[which(resSig_012$fcsign == -1),]
```

For further analysis, we group the positive, and negative logfold2 changes. This is because down regulated genes have negative logfold2change and upregulated genes have a positive logfold2change. Therefore, by splitting up the data into up and down regulated genes, we can succesfully, and more clearly identify biological pathways for future analysis, such as Gene Ontology and Gene Set Enrichment Analysis.

# ImpulseDE2  
For ImpulseDE2, we must create an integer count matrix (TBcounts_matrix) and a meta data table (impulse_design) to input directly to the ImpulseDE2 wrapper (runImpulseDE2). 

```{r, echo = F,cache= TRUE }
Time <- c(rep(0,3), rep(3,2), rep(6,3,), rep(12,3), rep(24,3), rep(48,3), rep(72,3), rep(168,3), rep(240,3), rep(336,3))

impulse_design <- data.frame(Sample = colnames(TBcounts), Condition = rep("case", 29), Time = Time)
#edit count matrix and filter s.t. average count is double digits
TBcounts_matrix <- as.matrix(TBcounts)

#may take awhile to run ImpulseDE2 (~20 mins), using q-value threshold of 0.01
tryp_impulse <- ImpulseDE2 :: runImpulseDE2(TBcounts_matrix, impulse_design, boolCaseCtrl = FALSE, vecConfounders = NULL, scaNProc = 8, scaQThres = 0.01)
 
```

# maSigPro   
 
```{r,cache=TRUE, echo = FALSE}
#################################################################################################################################
#Serial expression tool: NEXT maSigPro
#################################################################################################################################

#set up design
time <-c(rep(0,3),rep(3,2),rep(6,3),rep(12,3),rep(24,3),rep(48,3),rep(72,3),rep(168,3),rep(240,3),rep(336,3))
replicates<-c(1:3, 1:2, rep(1:3, 8))
group<-rep(1,29)
ss.edesign<-cbind(time, replicates, group)
rownames(ss.edesign)<-colnames(TBcounts)

#Run maSigPro on DESeq2 normalized counts, theta=1000...
tccount1<-as.data.frame(counts(TBcounts_dds, normalized=TRUE))
ss.edesign<-as.data.frame(ss.edesign)
newdesign<-make.design.matrix(ss.edesign, degree=9, time.col=1, repl.col=2, group.cols=3)

#run maSigPro w/ Q=0.01
results<-maSigPro(tccount1, ss.edesign, vars="all", Q=0.01)
maSigProGenes<-results$p.vector[results$p.vector<0.01,]
maSigProGenes<-names(maSigProGenes)

```

# Creating Venn Diagram  

Completing each Differential Experssion algorithm, we found that there are 716 DEGs identified by DESeq2, maSigPro, and ImpulseDE2. Because of the large amount of DEG found for each method, we will take the intersection of all tools as our list of DEGs for Schulz 0-12 hour comparsion to not only get the most accurate DEGs, but also cut down on the amount used for analysis.
```{r, echo = FALSE}
#Creating VennDiagram 

#three way comparison - Impulse, maSigPro, DESeq2
area1 <- length(intersect(rownames(resSig_012),maSigProGenes))
area2<- length(intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)))
area3 <- length(intersect(maSigProGenes, tryp_impulse$vecDEGenes))
area123<-length(intersect(intersect(maSigProGenes, tryp_impulse$vecDEGenes), intersect(maSigProGenes,rownames(resSig_012))))
grid.newpage()
g = draw.triple.venn(area1= length(rownames(resSig_012)), area2 = length(maSigProGenes), area3= length(tryp_impulse$vecDEGenes), n12=area1, n23=area3, n13=area2, n123=area123, category = c("DESeq2","maSigPro", "ImpulseDE2"), lty = rep("blank",3), fill = c("light blue", "light green", "pink"), euler.d=FALSE,  scaled = FALSE,ind = FALSE,cex=rep(1.5, 7), cat.cex=rep(1.5,3), cat.dist=c(0,0,0), cat.fontface = "bold")  
require(gridExtra)
grid.arrange(gTree(children=g), top="Schulz T.brucei Three Way Comparison of Differentally Expressed Genes")

```


```{r, echo = FALSE}
#Generate Final DEGList
#Creating DEG list from three way intersection - Impulse, maSigPro, DESeq2   
#Here, we will be saving our DE genes from maSigPro, impulse, and DESeq2. 
#DEGs from the intersections of each method. 
tryp_DEGs_3_way <-unique(c(intersect(rownames(resSig_012),maSigProGenes), intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)), intersect(maSigProGenes, tryp_impulse$vecDEGenes)))
write.csv(tryp_DEGs_3_way, "tryp_DEGs_3_way.csv")
tryp_DEGs_3_way_df <- data.frame(tryp_DEGs_3_way) %>% `colnames<-`("gene")
tryp_DEGs_3_way_sig_df <- right_join(resSig_012_df,tryp_DEGs_3_way_df,by  = "gene")

#DEGs only from the intersection of the middle. 
tryp_DEGs_all <- intersect(intersect(rownames(resSig_012),maSigProGenes),tryp_impulse$vecDEGenes)
write.csv(tryp_DEGs_all, "tryp_DEGs_all.csv")
tryp_DEGs_all_df <- data.frame(tryp_DEGs_all) %>% `colnames<-`("gene")
#we need to have the log, padj, pvalue, and logfoldchange which is given by resSig012 from DESeq2
#make data frame of resSig_012
resSig_012_df <- data.frame(resSig_012)
tryp_DEGs_all_sig_df <- right_join(resSig_012_df,tryp_DEGs_all_df,by  = "gene")

```
# 3 Clustering  

Due to the large number of DEGs in our data set, we need to cluster our data to gather important information based on the similarites within it. Clustering our data is an instrumental step in analyzing our results because it can reveal expression patterns, determine specific profiles within the expression data, and can answer the question of what exactly does our data tell us?  
The two methods that we chose to cluster our data were Partitioning Around Medoids(PAM), and Fuzzy clustering. Choices for these are due to the efficiency of both algorithms, and time constraints of finding and running other methods.  
# 3.1 PAM   
PAM clustering, or *k-medoids* is a clustering algorithm similar to the *k-means* algorithm. Both *k-means* and *k-medoids* algorithms are partitional, or break the dataset into groups, and both attempt to minimize the distance between points labeled to be in a cluster, and a point designated as the center of that cluster. *k-medoids* uses data points as centers, and can be used with arbitrary distances. 
*k-medoids* clusters the data set of *n* objects into *k* clusters and redistributes the clusters and centers until the distances to the centers are minimized. For our data set, we chose 6 *k* clusters, however this number is up for consideration and could be further research.
 
Here, we will cluster the tryp_DEGs_3_way_sig_df, which is the DEGs identified by 2+ tools. In order to match the DEGs with the corresonding p values, logfold2change etc, we need to match our data frame with the norm_counts, which is the entire gene library.    
```{r,echo = FALSE}

ind <- match(norm_counts$gene,tryp_DEGs_3_way_sig_df$gene)
 
norm_counts$sig <- tryp_DEGs_3_way_sig_df$gene[ind]

norm_counts$padj <- tryp_DEGs_3_way_sig_df$padj[ind]

norm_counts$pval <- tryp_DEGs_3_way_sig_df$pvalue[ind]

norm_counts$log2FoldChange <- tryp_DEGs_3_way_sig_df$log2FoldChange[ind]

norm_counts <- norm_counts %>%
  filter(!is.na(sig))

pos_DEGs_metrics <- norm_counts %>%
  filter(log2FoldChange > 0)
rownames(pos_DEGs_metrics) <- pos_DEGs_metrics$gene
pos_DEGs <- pos_DEGs_metrics %>%
  dplyr :: select(-c(gene, sig, padj,pval,log2FoldChange))

neg_DEGs_metrics <- norm_counts %>%
  filter(log2FoldChange < 0)
rownames(neg_DEGs_metrics) <- neg_DEGs_metrics$gene
neg_DEGs <- neg_DEGs_metrics %>%
  dplyr :: select(-c(gene, sig, padj,pval,log2FoldChange))

rownames(norm_counts) <- norm_counts$gene
tb_DEGS <- norm_counts %>%
  dplyr :: select(-c(gene, sig, padj, pval, log2FoldChange))
 
#norm_counts$gene <- rownames(norm_counts_cluster)
#norm_counts <- norm_counts %>% dplyr :: select(-c(sig, padj, pval, log2FoldChange))

```
Now, beginning our clustering, we will 

```{r, cache=TRUE,echo = TRUE, results = 'hide'}
k = 6

dissimilarity_matrix <- 1 - cor(t(tb_DEGS[1:20,]),method = "pearson")

DESeq_clusters <- cluster::pam(x = dissimilarity_matrix, k = k, pamonce = 5)

DESeq_clusters_df <- data.frame("cluster" = DESeq_clusters$clustering, "gene" = names(DESeq_clusters$clustering))

DESeq_medoids_df <- data.frame("medoids" = (DESeq_clusters$medoids))

 

DESeq_cluster_df <- left_join(DESeq_clusters_df,norm_counts, by = "gene")

DESeq_cluster_counts <- DESeq_cluster_df %>% dplyr::select(-c(padj,pval,log2FoldChange,sig))

DESeq_cluster_metric <- DESeq_cluster_df %>%
  mutate("stat" = (-log10(DESeq_cluster_df$padj))) %>%
  dplyr:: select(gene, stat, cluster) %>%
  filter(stat != "-Inf") %>%
  filter(stat != "Inf")

DESeq_Pathways_list <-DESeq_cluster_metric$stat

names(DESeq_Pathways_list) <- DESeq_cluster_metric$gene

DESeq_cluster_list <- c()
DESeq_cluster_list <- split(DESeq_cluster_metric, DESeq_cluster_df$cluster)


DESeq_clusters <- c()
for (i in 1:k) {
  DESeq_clusters[[i]] <- DESeq_cluster_list[[i]]$stat
  names(DESeq_clusters[[i]]) <- DESeq_cluster_list[[i]]$gene
}

counts_gath_norm <- DESeq_cluster_counts %>%
  gather(-c(gene,cluster), key="sample", value = "rawcount") %>%
  mutate(sample2 = sample) %>%
  separate(sample2, c("treat", "time", "rep"), "_") %>%
  mutate(time = ifelse(time == "ib", 0, 
                        ifelse(time == "3h", 3, 
                               ifelse(time == "6h", 6,
                                      ifelse(time == "12h", 12,
                                             ifelse(time == "24h", 24,
                                                    ifelse(time == "48h", 48,
                                                           ifelse(time == "3d", 72,
                                                                  ifelse(time == "7d", 168,
                                                                         ifelse(time == "10d", 240, 336))))))))))
 

counts_sum_norm <- counts_gath_norm %>%
  group_by(gene, treat, time, cluster) %>%
  dplyr::summarise(avecount = mean(rawcount))
counts_sum_norm_head <- counts_sum_norm %>%
  filter(time <= 12)
```

After creating the clusters, we need to save each cluster into a csv file for further analysis. Here, I only included the first cluster, but did the same for the rest which is not included in the knitted file. 
```{r, cache=TRUE}
cluster_lists <- c()
cluster_lists[1] <- counts_sum_norm %>% filter(cluster == 1)
list_1 <- paste(cluster_lists[[1]], sep = "")
write.csv(list_1, file = "tryp_cluster_1.csv")
```
```{r, include = FALSE}
cluster_lists[2] <- counts_sum_norm %>% filter(cluster == 2)
list_2 <- paste(cluster_lists[[2]], sep = "")
write.csv(list_2, file = "tryp_cluster_2.csv")

cluster_lists[3] <- counts_sum_norm %>% filter(cluster == 3)
list_3 <- paste(cluster_lists[[3]], sep = "")
write.csv(list_3, file = "tryp_cluster_3.csv")

cluster_lists[4] <- counts_sum_norm %>% filter(cluster == 4)
list_4 <- paste(cluster_lists[[4]], sep = "")
write.csv(list_4, file = "tryp_cluster_4.csv")

cluster_lists[5] <- counts_sum_norm %>% filter(cluster == 5)
list_5 <- paste(cluster_lists[[5]], sep = "")
write.csv(list_5, file = "tryp_cluster_5.csv")

cluster_lists[6] <- counts_sum_norm %>% filter(cluster == 6)
list_6 <- paste(cluster_lists[[6]], sep = "")
write.csv(list_6, file = "tryp_cluster_6.csv")
 
counts_sum_norm %>%
  ggplot(aes(x=time, y=avecount, color=gene)) +
  geom_line(alpha = .5) +
  theme(legend.position = "none")
```

# 3.2 Fuzzy Clustering  

Fuzzy clustering (also referred to as soft clustering or soft k-means) is a form of clustering in which each data point can belong to more than one cluster. Here, for Schulz's data, we will use the package Mfuzz to cluster the genes. The algorithm of fuzzy clustering assigns membership grades to each of the data points (tags). These membership grades indicate the degree to which data points belong to each cluster. Thus, points on the edge of a cluster, with lower membership grades, may be in the cluster to a lesser degree than points in the center of cluster.

Although we already used PAM as a method of clustering, because there are numerous methods to cluster genes we chose to test another moethod(soft clustering on this data set). Reasons for choosing fuzzy clustering and package Mfuzz is that the regulation of genes is generally not in an ‘on-off’, but gradual manner. Also, expression profiles of the genes were noisy, and while being forced to be in a cluster by a method like *k-means* may not acutally represent the clusters well. For example, the *k-means* algorithm would put a dotted profile on a gene in a certain cluster that might not follow the general trend of the cluster, while fuzzy will tell us that it does not strongly adhere to the general trend in the cluster. Soft clustering appears a good candidate for modeling this by assiging a gene *i* gradual degrees of membership *μij* to a cluster *j*. The membership values can vary continuously between zero and one. This feature enables soft clustering to provide more information about the   gene expression clusters.

Here, we will run fuzzy on the DEGs indentifies by 2+ tools. 

```{r,echo = T, cache=TRUE}
####################################################################################################
#DEG LIST: GENES ID'ED from the 3 different intersections of each tool 
#RUN GO ANALYSIS in TriTrypDb for each of the cores (Cellular Component, Biological Process, & Mol Function)
####################################################################################################
all3_DEGcounts<-tccount1[match(tryp_DEGs_3_way_df$gene, rownames(tccount1)),]
 
sdvec<-c()
for (i in 1:dim(all3_DEGcounts)[1]){
  sdvec<-c(sdvec, sd(all3_DEGcounts[i,]))}
all3_DEGcounts<-all3_DEGcounts[sdvec>0,]
all3_DEGcounts<-all3_DEGcounts+0.1
all3_DEGcounts<-as.matrix(all3_DEGcounts)
all3l_cluster_data<-matrix(ncol=5,nrow=dim(all3_DEGcounts)[1])
for (i in 1:dim(all3_DEGcounts)[1]){
  all3l_cluster_data[i,]<-c(mean(all3_DEGcounts[i, 1:3]), mean(all3_DEGcounts[i, 4:2]), mean(all3_DEGcounts[i, 6:8]), mean(all3_DEGcounts[i, 9:11]), mean(all3_DEGcounts[i, 12:14]))}
rownames(all3l_cluster_data)<-rownames(all3_DEGcounts)
colnames(all3l_cluster_data)<-c(0,3,6,12,24)
Set<-ExpressionSet(all3l_cluster_data)
Set.s<-standardise(Set)
all3_cl<-mfuzz(Set.s, c=6, m=mestimate(Set.s))
all3_scaleddata<-t(scale(t(all3l_cluster_data)))
 

gap_all3 <- clusGap(all3_scaleddata, kmeans, 10, B = 100, verbose = interactive())
plot(gap_all3, main = "Gap statistic for DEGs Identified by all 3 tools")
abline(v=which.max(gap_all3$Tab[,3]), lty = 2)

pdf("tryp_fuzzy_clusters.pdf", onefile = TRUE)
mfuzz.plot(Set.s, all3_cl, mfrow=c(1,3), time.labels = c(0,3,6,12,24), min.mem=0, new.window=FALSE)
dev.off()
#extract alpha-cores of 0.72
cores<-acore(Set.s, all3_cl, min.acore=0.3)
```

 
For Gene Ontology analysis completed in the future we will save each cluster as a csv file. 

```{r, results = 'hide'}
#Run GO Analysis on these clusters
write.csv(cores[[1]]$NAME, "all3_Cluster1_of_6_Tryp.csv")
write.csv(cores[[2]]$NAME, "all3_Cluster2_of_6_Tryp.csv")
write.csv(cores[[3]]$NAME, "all3_Cluster3_of_6_Tryp.csv")
write.csv(cores[[4]]$NAME, "all3_Cluster4_of_6_Tryp.csv")
write.csv(cores[[5]]$NAME, "all3_Cluster2_of_6_Tryp.csv")
write.csv(cores[[6]]$NAME, "all3_Cluster6_of_6_Tryp.csv")

```


In these clusters of T-*brucei* data from 0-12h of 2+ tools, we can see that we set the cluster number to 6, and that each cluster here has slight differences. Each cluster is scaled by the standardize() function.  However, moving forward in this analysis Ethan and I got different results on the clustering of typanosoma data. This is a great cause of worry, as there should really only be one result of this clustering algorithm. Therefore, more analysis will be done in this section. 

We will continue fuzzy clustering on DEGs identified by all three. Here, we will follow the same steps as the DEgs identified by 2+ tools. This is important to see the differences between the stricter DEG list and the less strict list to fully see the patterns of our data. 

```{r,cache=TRUE,include =  FALSE}

####################################################################################################
#STRICTER DEG LIST: GENES ID'ED BY ALL 3
#RUN GO ANALYSIS in TriTrypDb for each of the cores (Cellular Component, Biological Process, & Mol Function)
####################################################################################################
 

#Look at smaller subset (3-way intersection)
small_DEGcounts<-tccount1[match(tryp_DEGs_all_df$gene, rownames(tccount1)),]
sdvec<-c()
for (i in 1:dim(small_DEGcounts)[1]){
  sdvec<-c(sdvec, sd(small_DEGcounts[i,]))}
small_DEGcounts<-small_DEGcounts[sdvec>0,]
small_DEGcounts<-small_DEGcounts+0.1
small_DEGcounts<-as.matrix(small_DEGcounts)
small_cluster_data<-matrix(ncol=5,nrow=dim(small_DEGcounts)[1])
for (i in 1:dim(small_DEGcounts)[1]){
  small_cluster_data[i,]<-c(mean(small_DEGcounts[i, 1:3]), mean(small_DEGcounts[i, 4:2]), mean(small_DEGcounts[i, 6:8]), mean(small_DEGcounts[i, 9:11]), mean(small_DEGcounts[i, 12:14]))}
rownames(small_cluster_data)<-rownames(small_DEGcounts)
colnames(small_cluster_data)<-c(0,3,6,12,24)
Set<-ExpressionSet(small_cluster_data)
Set.s<-standardise(Set)
small_cl<-mfuzz(Set.s, c=6, m=mestimate(Set.s))
small_scaleddata<-t(scale(t(small_cluster_data)))

gap_small <- clusGap(small_scaleddata, kmeans, 10, B = 100, verbose = interactive())
plot(gap_small, main = "Gap statistic for DEGs Identified by all 3 tools")
abline(v=which.max(gap_small$Tab[,3]), lty = 2)

pdf("tryp_fuzzy_clusters.pdf", onefile = TRUE)
mfuzz.plot(Set.s, small_cl, mfrow=c(1,3), time.labels = c(0,3,6,12,24), min.mem=0, new.window=FALSE)
dev.off()
#extract alpha-cores of 0.72
cores<-acore(Set.s, small_cl, min.acore=0.3)
 
write.csv(cores[[1]]$NAME, "Cluster1_of_6_Tryp_small.csv")
write.csv(cores[[2]]$NAME, "Cluster2_of_6_Tryp_small.csv")
write.csv(cores[[3]]$NAME, "Cluster3_of_6_Tryp_small.csv")
write.csv(cores[[4]]$NAME, "Cluster4_of_6_Tryp_small.csv")
write.csv(cores[[5]]$NAME, "Cluster5_of_6_Tryp_small.csv")
write.csv(cores[[6]]$NAME, "Cluster6_of_6_Tryp_small.csv")
```




# 4. Comparing T.*brucei* with Differentiating Data   

In order to answer the question of bromodomain inhibition impact on trypanosome PF, we must compare our results to @Savage data, or Differentiating data, which includes trypanosoma DE genes gathered from environmental based experiments in the Tsetse fly. This means that in this experiment, @Savage gathered samples of trypanosmoa from the midgut(MG), salivary gland(SA) and proventriculus(PV).  The results of @Savage data details the biological change in T.*brucei* gene transcription based on environmental conditions. By comparing our DE genes to Savage environment based DE genes, we can come to conclusions about what happens in gene expression for bromodomain inhibited PF.
By comparing MG to SA, the resulting DE genes are those that best exemplify the gene expression change between BF and PF. These genes are very important in our understanding of the changes that Schulz samples undergo. For example, if there is a high amount of correlation between DE genes in MG to SA and 0h - 12h, we can hypothesize certain aspects of what happens in bromodomain inhibition in PF in relation to epitope changes. This might be a revert to the BF, or the bromodomain inhibited PF trypanosomes share similar like qualities of BF trypanosomes. 

Thus, by completing DESeq and future biological analysis on Savage data, we can come to a more concrete conclusion of bromodomain function in trypanosoma. 
 
Similar to analyzing our data, we must analyze 2015 Savage data, using the same pipeline: 
  1. Run raw read counts  
  2. Filter/Quality Control  
  3. Run Differential Gene Expression Analysis using DESEq2  
# 4.1 Savage Data  
First, we must read in our data table. Variable 'savagecounts' represents this data table of Savage raw read counts. 
Similar to our data, we must manipulate our savagecounts data table for DESeq2. 
```{r, echo = FALSE}
#DESEQ ON SAVAGE DATA - THREE COMPARISON MGSA MGPV PVSA

savagecounts <- read.table("18-5-24_dedup_Savage_deseq_counts.txt", header = TRUE)

 
#Creating Data matrix 
rownames(savagecounts) <- savagecounts$gene #renames the gene row
savagecounts <- savagecounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
coldata <- data.frame(rownames = colnames(savagecounts),
                    reps = as.factor(c(1, 2, 3, 1, 2, 3 ,4,
                                     1, 2 ,3)), 
                    stage = as.factor(c(rep("MG",3),rep("PV",4), rep("SA",3))))

ddsFullCountTable <- DESeqDataSetFromMatrix(
   countData = savagecounts,
   colData = coldata,
   design = ~ reps + stage)
#DESeq2 getting DE genes
savagecounts_dds <- DESeq(ddsFullCountTable )

```  
 
 As you can see in the above chunk, savage data was run through the same pipeline, creating a new data frame for DESeq2 with variables reps, which are the repetition of the samples, and stage, whichrepresents the location of where the trypanosome was sampled: Midgut, Proventriculus, Salivary gland. We will not be using edgeR or other methods to normalize and run differential expression because of the consistency with normalization, and also due to timing contraints, and unnecessary analysis of Savage data. 
 
# 4.2 Savage Methods  
Here we are completing DESEq results on Savage data. We have an adjusted p value (padj) filter of < 0.01, a log2foldchange > 1.5. 
The comparisons we completed are:
1. MgSa (Midgut and Salivary Gland)  
$~$
2. MgPv (Migut and Proventriculus)  
$~$
3. PvSa (Proventriculus and Salivary Gland)  
$~$
  In the chunk below, we will comlete comparison MgSa. We will complete the same analysis pipline on the comparisons MG/SA, MG/PV and PV/SA, but it will not be shown in the knitted document.
  
Here we extract results for the log2 of the fold change of MG and SA. 
 
```{r}
#Comparisons of all 
  #padj filter < 0.01
  #abs(log2fold) filter > 1.5
#MG and SA############################################################################
savageRes_MgSa <- results( savagecounts_dds ,contrast = c("stage",  "MG","SA"))
savageRes_MgSa
```
 
For T.*brucei* data, we also considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Savage to compare to our dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  

Similar to filtering the padj, we want to filter the logfold2change. If a gene has a high absolute value log2foldchange, it means the gene is highly expressed, and therefore most likely biologically significant. In order to cut down the amount of DE genes, filtering of this parameter will select only the higly expressed genes for our analysis of Savage data against our own. The cutoff logfold2 value 1.5 was arbitrarly chosen based on needing ~200-500 DE genes for further analysis. 

MgSa represents the filtered padj and log2foldchange DE genes between midgut and salivary gland. 
```{r}
resSig <- savageRes_MgSa[ which(savageRes_MgSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgSa <- resSig
head(MgSa) 
```
Here is the padj and logfold2 filtered results of the log2 of the fold change of MG and SA.
The rownames of this table are the DE genes calculated from the results function. Theses genes are important and we will use them for analysis later. 

We completed the same analysis on comparisons MG/PV and PV/SA (not shown) with same parameters and filtering. This code will not be included in the knitted file. 
```{r, echo = FALSE}
#MG and PV############################################################################
savageRes_MgPv <- results( savagecounts_dds ,contrast = c("stage",  "MG","PV"))
resSig <- savageRes_MgPv[ which(savageRes_MgPv$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgPv <- resSig

#PV and SA############################################################################
savageRes_PvSa <- results( savagecounts_dds ,contrast = c("stage",  "PV","SA"))
resSig <- savageRes_PvSa[ which(savageRes_PvSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
PvSa <- resSig

 
```


# 5. Gene Ontology analysis  

In order to assign biological meaning to our results, we must understand the biological background behind our DE genes. GO analysis, or Gene Ontology term enrichment, is a way to characterize genes through assigning them to specific pathways and determines if groups of genes are significantly over or under enriched in a pathway. More explicitly, the GO system of classification assigns these genes to a set of predefined pathways depending on their functional characteristics. For example, if a gene called FasR is categorized by the GO term 'receptor', it might be found to be involved in apoptosis and located on the plasma membrane. Thus, by being able to group our DE genes by biological function, we can come to a fuller conclusion of our data.

For GO on T.*brucei* and Savage data, we used a database https://tritrypdb.org/tritrypdb/, and completed GeneId search for our DE genes, which give additional information on the specific information on each gene. Then, after completing Geneid search, click on the tab "Analyze Results" and then you should see a option 'GO'. For our data, we included Cellular Component, Molecular Function, and Biological Process for GO enrichment. The downloaded tabs are in the folder labeled "GO_Terms"
 

# 5.1 T.*brucei* GO  

For T.*brucei* data, we used GO analysis on the PAM clusters, fuzzy clusters, and total DE gene list. As explained above, it was necccesary to include a deeper analysis on the clusters by providing biological tags on the genes. For fuzzy, we completed the same pipline for the DEGs 2+ methods and DEGs 3 methods. 

CLusters: PAM and Fuzzy
Here, will use the saved file from PAM clustering code(gene names saved as "tryp_cluster_1.csv" and ect.) and from fuzzy code("Cluster1_of_6_Tryp.csv" and ect.) 
Then as descibed above, we will import the gene names to  https://tritrypdb.org/tritrypdb/ to create the GO components for each cluster. 
 
Here we are taking the fuzzy cluster GO analysis results, and preparing them for GSEA pipeline(which we will discuss int he nexrt section). 

First step is to read in all the fuzzy clusters. Then, we will separate them into respective clusters, sorting the clusters into Biological Process and so forth. We will need to make each clustered group into a list for GSEA. Here is the cluster 1 of the DEG list of 2+ methods(Cluster1), and cluster 1 of all 3 methods(small_Cluster1). Only the first cluster will be included in the knit file, but the rest of the clusters will be included in the rmd file. For each DEG list, we saved a .tab file of all GO processes. For 3 tools, the file is small_fuzzyclusters_GO.tab, and for 2+ DEGs the file is fuzzyclusters_GO.tab. 

```{r}
#CLUSTER 1
 
Cluster1_BioProcess<-read.table("GO_clusters/Cluster1_BiologicalProcess.tab", sep="\t", header=TRUE)
Cluster1_BioProcess<-Cluster1_BioProcess %>% filter(Benjamini<0.05)
Cluster1_BioProcess$Cluster<-rep(1, dim(Cluster1_BioProcess)[1])
Cluster1_BioProcess$Type<-rep("Biological Process", dim(Cluster1_BioProcess)[1])
 
Cluster1_CellularComponent<-read.table("GO_clusters/Cluster1_CellularComponent.tab", sep="\t", header=TRUE)
Cluster1_CellularComponent<-Cluster1_CellularComponent %>% filter(Benjamini<0.05)
Cluster1_CellularComponent$Cluster<-rep(1, dim(Cluster1_CellularComponent)[1])
Cluster1_CellularComponent$Type<-rep("Cellular Component", dim(Cluster1_CellularComponent)[1])
 
Cluster1_MolecularFunction<-read.table("GO_clusters/Cluster1_MolecularFunction.tab", sep="\t", header=TRUE)
Cluster1_MolecularFunction<-Cluster1_MolecularFunction %>% filter(Benjamini<0.05)
Cluster1_MolecularFunction$Cluster<-rep(1, dim(Cluster1_MolecularFunction)[1])
Cluster1_MolecularFunction$Type<-rep("Molecular Function", dim(Cluster1_MolecularFunction)[1])
Cluster1_GO<-rbind(Cluster1_BioProcess, Cluster1_CellularComponent, Cluster1_MolecularFunction)

```

```{r, include = FALSE}


#CLUSTER 2
 
Cluster2_BioProcess<-read.table("GO_clusters/Cluster2_BiologicalProcess.tab", sep="\t", header=TRUE)
Cluster2_BioProcess<-Cluster2_BioProcess %>% filter(Benjamini<0.05)
Cluster2_BioProcess$Cluster<-rep(2, dim(Cluster2_BioProcess)[1])
Cluster2_BioProcess$Type<-rep("Biological Process", dim(Cluster2_BioProcess)[1])
 
Cluster2_CellularComponent<-read.table("GO_clusters/Cluster2_CellularComponent.tab", sep="\t", header=TRUE)
Cluster2_CellularComponent<-Cluster2_CellularComponent %>% filter(Benjamini<0.05)
Cluster2_CellularComponent$Cluster<-rep(2, dim(Cluster2_CellularComponent)[1])
Cluster2_CellularComponent$Type<-rep("Cellular Component", dim(Cluster2_CellularComponent)[1])
 
Cluster2_MolecularFunction<-read.table("GO_clusters/Cluster2_MolecularFunction.tab", sep="\t", header=TRUE)
Cluster2_MolecularFunction<-Cluster2_MolecularFunction %>% filter(Benjamini<0.05)
Cluster2_MolecularFunction$Cluster<-rep(2, dim(Cluster2_MolecularFunction)[1])
Cluster2_MolecularFunction$Type<-rep("Molecular Function", dim(Cluster2_MolecularFunction)[1])
Cluster2_GO<-rbind(Cluster2_BioProcess, Cluster2_CellularComponent, Cluster2_MolecularFunction)

#CLUSTER 3
 
Cluster3_BioProcess<-read.table("GO_clusters/Cluster3_BiologicalProcess.tab", sep="\t", header=TRUE)
Cluster3_BioProcess<-Cluster3_BioProcess %>% filter(Benjamini<0.05)
Cluster3_BioProcess$Cluster<-rep(3, dim(Cluster3_BioProcess)[1])
Cluster3_BioProcess$Type<-rep("Biological Process", dim(Cluster3_BioProcess)[1])
 
Cluster3_CellularComponent<-read.table("GO_clusters/Cluster3_CellularComponent.tab", sep="\t", header=TRUE)
Cluster3_CellularComponent<-Cluster3_CellularComponent %>% filter(Benjamini<0.05)
Cluster3_CellularComponent$Cluster<-rep(3, dim(Cluster3_CellularComponent)[1])
Cluster3_CellularComponent$Type<-rep("Cellular Component", dim(Cluster3_CellularComponent)[1])
 
Cluster3_MolecularFunction<-read.table("GO_clusters/Cluster3_MolecularFunction.tab", sep="\t", header=TRUE)
Cluster3_MolecularFunction<-Cluster3_MolecularFunction %>% filter(Benjamini<0.05)
Cluster3_MolecularFunction$Cluster<-rep(3, dim(Cluster3_MolecularFunction)[1])
Cluster3_MolecularFunction$Type<-rep("Molecular Function", dim(Cluster3_MolecularFunction)[1])
Cluster3_GO<-rbind(Cluster3_BioProcess, Cluster3_CellularComponent, Cluster3_MolecularFunction)

#CLUSTER 4
 
Cluster4_BioProcess<-read.table("GO_clusters/Cluster4_BiologicalProcess.tab", sep="\t", header=TRUE)
Cluster4_BioProcess<-Cluster4_BioProcess %>% filter(Benjamini<0.05)
Cluster4_BioProcess$Cluster<-rep(4, dim(Cluster4_BioProcess)[1])
Cluster4_BioProcess$Type<-rep("Biological Process", dim(Cluster4_BioProcess)[1])
 
 Cluster4_CellularComponent<-read.table("GO_clusters/Cluster4_CellularComponent.tab", sep="\t", header=TRUE)
 Cluster4_CellularComponent<- Cluster4_CellularComponent %>% filter(Benjamini<0.05)
 Cluster4_CellularComponent$Cluster<-rep(4, dim(Cluster4_CellularComponent)[1])
 Cluster4_CellularComponent$Type<-rep("Cellular Component", dim(Cluster4_CellularComponent)[1])
 
Cluster4_MolecularFunction<-read.table("GO_clusters/Cluster4_MolecularFunction.tab", sep="\t", header=TRUE)
Cluster4_MolecularFunction<-Cluster4_MolecularFunction %>% filter(Benjamini<0.05)
Cluster4_MolecularFunction$Cluster<-rep(4, dim(Cluster4_MolecularFunction)[1])
Cluster4_MolecularFunction$Type<-rep("Molecular Function", dim(Cluster4_MolecularFunction)[1])
Cluster4_GO<-rbind(Cluster4_BioProcess, Cluster4_CellularComponent, Cluster4_MolecularFunction)

#CLUSTER 5
 
Cluster5_BioProcess<-read.table("GO_clusters/Cluster5_BiologicalProcess.tab", sep="\t", header=TRUE)
Cluster5_BioProcess<-Cluster5_BioProcess %>% filter(Benjamini<0.05)
Cluster5_BioProcess$Cluster<-rep(5, dim(Cluster5_BioProcess)[1])
Cluster5_BioProcess$Type<-rep("Biological Process", dim(Cluster5_BioProcess)[1])
 
Cluster5_CellularComponent<-read.table("GO_clusters/Cluster5_CellularComponent.tab", sep="\t", header=TRUE)
Cluster5_CellularComponent<-Cluster5_CellularComponent %>% filter(Benjamini<0.05)
Cluster5_CellularComponent$Cluster<-rep(5, dim(Cluster5_CellularComponent)[1])
Cluster5_CellularComponent$Type<-rep("Cellular Component", dim(Cluster5_CellularComponent)[1])
 
Cluster5_MolecularFunction<-read.table("GO_clusters/Cluster5_MolecularFunction.tab", sep="\t", header=TRUE)
Cluster5_MolecularFunction<-Cluster5_MolecularFunction %>% filter(Benjamini<0.05)
Cluster5_MolecularFunction$Cluster<-rep(5, dim(Cluster5_MolecularFunction)[1])
Cluster5_MolecularFunction$Type<-rep("Molecular Function", dim(Cluster5_MolecularFunction)[1])
Cluster5_GO<-rbind(Cluster5_BioProcess, Cluster5_CellularComponent, Cluster5_MolecularFunction)

#CLUSTER 6
 
Cluster6_BioProcess<-read.table("GO_clusters/Cluster6_BiologicalProcess.tab", sep="\t", header=TRUE)
Cluster6_BioProcess<-Cluster6_BioProcess %>% filter(Benjamini<0.05)
Cluster6_BioProcess$Cluster<-rep(6, dim(Cluster6_BioProcess)[1])
Cluster6_BioProcess$Type<-rep("Biological Process", dim(Cluster6_BioProcess)[1])
 
Cluster6_CellularComponent<-read.table("GO_clusters/Cluster6_CellularComponent.tab", sep="\t", header=TRUE)
Cluster6_CellularComponent<-Cluster6_CellularComponent %>% filter(Benjamini<0.05)
Cluster6_CellularComponent$Cluster<-rep(6, dim(Cluster6_CellularComponent)[1])
Cluster6_CellularComponent$Type<-rep("Cellular Component", dim(Cluster6_CellularComponent)[1])
 
Cluster6_MolecularFunction<-read.table("GO_clusters/Cluster6_MolecularFunction.tab", sep="\t", header=TRUE)
Cluster6_MolecularFunction<-Cluster6_MolecularFunction %>% filter(Benjamini<0.05)
Cluster6_MolecularFunction$Cluster<-rep(6, dim(Cluster6_MolecularFunction)[1])
Cluster6_MolecularFunction$Type<-rep("Molecular Function", dim(Cluster6_MolecularFunction)[1])
Cluster6_GO<-rbind(Cluster6_BioProcess, Cluster6_CellularComponent, Cluster6_MolecularFunction)

GO<-list(Cluster1_GO, Cluster2_GO, Cluster3_GO, Cluster4_GO, Cluster5_GO, Cluster6_GO)
names(GO)<-c("Cluster1", "Cluster2", "Cluster3", "Cluster4", "Cluster5", "Cluster6")

GO_table<-rbind(GO[[1]], GO[[2]], GO[[3]], GO[[4]], GO[[5]], GO[[6]])
write.table(GO_table, "fuzzyclusters_GO.tab")





```


```{r}
#CLUSTER 1
 
small_Cluster1_BioProcess<-read.table("small_Cluster1_BiologicalProcess.tab", sep="\t", header=TRUE)
small_Cluster1_BioProcess<-small_Cluster1_BioProcess %>% filter(Benjamini<0.05)
small_Cluster1_BioProcess$Cluster<-rep(1, dim(small_Cluster1_BioProcess)[1])
small_Cluster1_BioProcess$Type<-rep("Biological Process", dim(small_Cluster1_BioProcess)[1])
 
small_Cluster1_CellularComponent<-read.table("small_Cluster1_CellularComponent.tab", sep="\t", header=TRUE)
small_Cluster1_CellularComponent<-small_Cluster1_CellularComponent %>% filter(Benjamini<0.05)
small_Cluster1_CellularComponent$Cluster<-rep(1, dim(small_Cluster1_CellularComponent)[1])
small_Cluster1_CellularComponent$Type<-rep("Cellular Component", dim(small_Cluster1_CellularComponent)[1])
 
small_Cluster1_MolecularFunction<-read.table("small_Cluster1_MolecularFunction.tab", sep="\t", header=TRUE)
small_Cluster1_MolecularFunction<-small_Cluster1_MolecularFunction %>% filter(Benjamini<0.05)
small_Cluster1_MolecularFunction$Cluster<-rep(1, dim(small_Cluster1_MolecularFunction)[1])
small_Cluster1_MolecularFunction$Type<-rep("Molecular Function", dim(small_Cluster1_MolecularFunction)[1])
small_Cluster1_GO<-rbind(small_Cluster1_BioProcess, small_Cluster1_CellularComponent, small_Cluster1_MolecularFunction)
```
```{r, include = FALSE}
#CLUSTER 2
 
small_Cluster2_BioProcess<-read.table("small_Cluster2_BiologicalProcess.tab", sep="\t", header=TRUE)
#small_Cluster2_BioProcess<-small_Cluster2_BioProcess %>% filter(Benjamini<0.05)
small_Cluster2_BioProcess$Cluster<-rep(2, dim(small_Cluster2_BioProcess)[1])
small_Cluster2_BioProcess$Type<-rep("Biological Process", dim(small_Cluster2_BioProcess)[1])
 
small_Cluster2_CellularComponent<-read.table("small_Cluster2_CellularComponent.tab", sep="\t", header=TRUE)
#small_Cluster2_CellularComponent<-small_Cluster2_CellularComponent %>% filter(Benjamini<0.05)
small_Cluster2_CellularComponent$Cluster<-rep(2, dim(small_Cluster2_CellularComponent)[1])
small_Cluster2_CellularComponent$Type<-rep("Cellular Component", dim(small_Cluster2_CellularComponent)[1])
 
small_Cluster2_MolecularFunction<-read.table("small_Cluster2_MolecularFunction.tab", sep="\t", header=TRUE)
small_Cluster2_MolecularFunction<-small_Cluster2_MolecularFunction %>% filter(Benjamini<0.05)
small_Cluster2_MolecularFunction$Cluster<-rep(2, dim(small_Cluster2_MolecularFunction)[1])
small_Cluster2_MolecularFunction$Type<-rep("Molecular Function", dim(small_Cluster2_MolecularFunction)[1])
small_Cluster2_GO<-rbind(small_Cluster2_BioProcess, small_Cluster2_CellularComponent, small_Cluster2_MolecularFunction)

#CLUSTER 3
 
small_Cluster3_BioProcess<-read.table("small_Cluster3_BiologicalProcess.tab", sep="\t", header=TRUE)
#small_Cluster3_BioProcess<-small_Cluster3_BioProcess %>% filter(Benjamini<0.05)
small_Cluster3_BioProcess$Cluster<-rep(3, dim(small_Cluster3_BioProcess)[1])
small_Cluster3_BioProcess$Type<-rep("Biological Process", dim(small_Cluster3_BioProcess)[1])
 
small_Cluster3_CellularComponent<-read.table("small_Cluster3_CellularComponent.tab", sep="\t", header=TRUE)
#small_Cluster3_CellularComponent<-small_Cluster3_CellularComponent %>% filter(Benjamini<0.05)
small_Cluster3_CellularComponent$Cluster<-rep(3, dim(small_Cluster3_CellularComponent)[1])
small_Cluster3_CellularComponent$Type<-rep("Cellular Component", dim(small_Cluster3_CellularComponent)[1])
 
small_Cluster3_MolecularFunction<-read.table("small_Cluster3_MolecularFunction.tab", sep="\t", header=TRUE)
#small_Cluster3_MolecularFunction<-small_Cluster3_MolecularFunction %>% filter(Benjamini<0.05)
small_Cluster3_MolecularFunction$Cluster<-rep(3, dim(small_Cluster3_MolecularFunction)[1])
small_Cluster3_MolecularFunction$Type<-rep("Molecular Function", dim(small_Cluster3_MolecularFunction)[1])
small_Cluster3_GO<-rbind(small_Cluster3_BioProcess,small_Cluster3_CellularComponent, small_Cluster3_MolecularFunction)

#CLUSTER 4
 
small_Cluster4_BioProcess<-read.table("small_Cluster4_BiologicalProcess.tab", sep="\t", header=TRUE)
#small_Cluster4_BioProcess<-small_Cluster4_BioProcess %>% filter(Benjamini<0.05)
small_Cluster4_BioProcess$Cluster<-rep(4, dim(small_Cluster4_BioProcess)[1])
small_Cluster4_BioProcess$Type<-rep("Biological Process", dim(small_Cluster4_BioProcess)[1])
 
small_Cluster4_CellularComponent<-read.table("small_Cluster4_CellularComponent.tab", sep="\t", header=TRUE)
#small_Cluster4_CellularComponent<-small_Cluster4_CellularComponent %>% filter(Benjamini<0.05)
small_Cluster4_CellularComponent$Cluster<-rep(4, dim(small_Cluster4_CellularComponent)[1])
small_Cluster4_CellularComponent$Type<-rep("Cellular Component", dim(small_Cluster4_CellularComponent)[1])
 
small_Cluster4_MolecularFunction<-read.table("small_Cluster4_MolecularFunction.tab", sep="\t", header=TRUE)
#small_Cluster4_MolecularFunction<-small_Cluster4_MolecularFunction %>% filter(Benjamini<0.05)
small_Cluster4_MolecularFunction$Cluster<-rep(4, dim(small_Cluster4_MolecularFunction)[1])
small_Cluster4_MolecularFunction$Type<-rep("Molecular Function", dim(small_Cluster4_MolecularFunction)[1])
small_Cluster4_GO<-rbind(small_Cluster4_BioProcess, small_Cluster4_CellularComponent, small_Cluster4_MolecularFunction)

#CLUSTER 5
 
small_Cluster5_BioProcess<-read.table("small_Cluster5_BiologicalProcess.tab", sep="\t", header=TRUE)
#small_Cluster5_BioProcess<-small_Cluster5_BioProcess %>% filter(Benjamini<0.05)
small_Cluster5_BioProcess$Cluster<-rep(5, dim(small_Cluster5_BioProcess)[1])
small_Cluster5_BioProcess$Type<-rep("Biological Process", dim(small_Cluster5_BioProcess)[1])
 
small_Cluster5_CellularComponent<-read.table("small_Cluster5_CellularComponent.tab", sep="\t", header=TRUE)
#small_Cluster5_CellularComponent<-small_Cluster5_CellularComponent %>% filter(Benjamini<0.05)
small_Cluster5_CellularComponent$Cluster<-rep(5, dim(small_Cluster5_CellularComponent)[1])
small_Cluster5_CellularComponent$Type<-rep("Cellular Component", dim(small_Cluster5_CellularComponent)[1])
 
small_Cluster5_MolecularFunction<-read.table("small_Cluster5_MolecularFunction.tab", sep="\t", header=TRUE)
#small_Cluster5_MolecularFunction<-small_Cluster5_MolecularFunction %>% filter(Benjamini<0.05)
small_Cluster5_MolecularFunction$Cluster<-rep(5, dim(small_Cluster5_MolecularFunction)[1])
small_Cluster5_MolecularFunction$Type<-rep("Molecular Function", dim(small_Cluster5_MolecularFunction)[1])
small_Cluster5_GO<-rbind(small_Cluster5_BioProcess, small_Cluster5_CellularComponent, small_Cluster5_MolecularFunction)

#CLUSTER 6
 
small_Cluster6_BioProcess<-read.table("small_Cluster6_BiologicalProcess.tab", sep="\t", header=TRUE)
#small_Cluster6_BioProcess<-small_Cluster6_BioProcess %>% filter(Benjamini<0.05)
small_Cluster6_BioProcess$Cluster<-rep(6, dim(small_Cluster6_BioProcess)[1])
small_Cluster6_BioProcess$Type<-rep("Biological Process", dim(small_Cluster6_BioProcess)[1])
 
small_Cluster6_CellularComponent<-read.table("small_Cluster6_CellularComponent.tab", sep="\t", header=TRUE)
#small_Cluster6_CellularComponent<-small_Cluster6_CellularComponent %>% filter(Benjamini<0.05)
small_Cluster6_CellularComponent$Cluster<-rep(6, dim(small_Cluster6_CellularComponent)[1])
small_Cluster6_CellularComponent$Type<-rep("Cellular Component", dim(small_Cluster6_CellularComponent)[1])
 
small_Cluster6_MolecularFunction<-read.table("small_Cluster6_MolecularFunction.tab", sep="\t", header=TRUE)
#small_Cluster6_MolecularFunction<-small_Cluster6_MolecularFunction %>% filter(Benjamini<0.05)
small_Cluster6_MolecularFunction$Cluster<-rep(6, dim(small_Cluster6_MolecularFunction)[1])
small_Cluster6_MolecularFunction$Type<-rep("Molecular Function", dim(small_Cluster6_MolecularFunction)[1])
small_Cluster6_GO<-rbind(small_Cluster6_BioProcess, small_Cluster6_CellularComponent, small_Cluster6_MolecularFunction)

small_GO<-list(small_Cluster1_GO, small_Cluster2_GO, small_Cluster3_GO, small_Cluster4_GO, small_Cluster5_GO, small_Cluster6_GO)
names(small_GO)<-c("Cluster1", "Cluster2", "Cluster3", "Cluster4", "Cluster5", "Cluster6")

small_GO_table<-rbind(small_GO[[1]], small_GO[[2]], small_GO[[3]], small_GO[[4]], small_GO[[5]], small_GO[[6]])
write.table(small_GO_table, "small_fuzzyclusters_GO.tab")



```

Now, we will need to read in the file with all the GO terms of the clusters. 
```{r}  
#Reading in huge file with all GO terms of clusters 
fuzzyClust <- read.table("fuzzyclusters_GO.tab") %>% dplyr :: select(Name, Result.gene.list, Cluster,Type)
fuzzyClust$Result.gene.list <- gsub(',',',',fuzzyClust$Result.gene.list,fixed=TRUE)
fuzzyClust$Result.gene.list <- strsplit(fuzzyClust$Result.gene.list, ",")

clust1_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 1)
clust1_bio_list <- as.list(clust1_bio)
names(clust1_bio_list$Result.gene.list) <- clust1_bio_list$Name
clust1_bio <- clust1_bio_list$Result.gene.list
clust1_bio$`microtubule-based movement`
```
We can see that in clust1_bio, the GO terms are labeled in the list as *microtubule-based movement* for example, and returns the list of genes from that specific cluster that are involved with that GO term. 

It is not included in the knitted file, but this process was completed for rest of the 6 fuzzy clusters and PAM clusters which used same method for GO. 
 
 
```{r, echo= FALSE, include =  FALSE}
#Fuzzy Cluster GO terms
#########CLUSTER 1######### 
#Cellular Component
clust1_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 1)
clust1_cell_list <- as.list(clust1_cell)
names(clust1_cell_list$Result.gene.list) <- clust1_cell_list$Name
clust1_cell <- clust1_cell_list$Result.gene.list
#Molecular Function
clust1_mol <- fuzzyClust %>% filter(Type == "Molecular Function",Cluster == 1)
clust1_mol_list <- as.list(clust1_mol)
names(clust1_mol_list$Result.gene.list) <- clust1_mol_list$Name
clust1_mol <- clust1_mol_list$Result.gene.list

#########CLUSTER 2######### 
#Biological Process
clust2_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 2)
clust2_bio_list <- as.list(clust2_bio)
names(clust2_bio_list$Result.gene.list) <- clust2_bio_list$Name
clust2_bio <- clust2_bio_list$Result.gene.list
#Cellular Component
clust2_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 2)
clust2_cell_list <- as.list(clust2_cell)
names(clust2_cell_list$Result.gene.list) <- clust2_cell_list$Name
clust2_cell <- clust2_cell_list$Result.gene.list

#this was not included because there were no Molecular Function GO terms in cluster 2
#clust2_mol <- cluster2 %>% filter(Cluster2.Type == "Molecular Function")
#clust2_mol_list <- as.list(clust2_mol)
#names(clust2_mol_list$Cluster2.Result.gene.list) <- clust2_mol_list$Cluster2.Name
#fuzzylist_2_mol <- clust2_mol_list$Cluster2.Result.gene.list
 
#########CLUSTER 3######### 
#this was not included because there were no Biological Process, Cellular Component, Molecular Function 
#GO terms in cluster 3
#cluster3 <- data.frame(GO[3])%>%dplyr::select(Cluster3.Name,Cluster3.Result.gene.list,Cluster3.Type) 
#clust3_bio <- cluster3 %>% filter(Cluster3.Type == "Biological Process")
#clust3_cell <- cluster3 %>% filter(Cluster3.Type == "Cellular Component")
#clust3_mol <- cluster3 %>% filter(Cluster3.Type == "Molecular Function")

#########CLUSTER 4######### 
#Biological Process
clust4_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 4)
clust4_bio_list <- as.list(clust4_bio)
names(clust4_bio_list$Result.gene.list) <- clust4_bio_list$Name
clust4_bio <- clust4_bio_list$Result.gene.list
#Cellular Component 
clust4_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 4)
clust4_cell_list <- as.list(clust4_cell)
names(clust4_cell_list$Result.gene.list) <- clust4_cell_list$Name
clust4_cell <- clust4_cell_list$Result.gene.list
#Molecular Function
clust4_mol <- fuzzyClust %>% filter(Type == "Molecular Function", Cluster == 4)
clust4_mol_list <- as.list(clust4_mol)
names(clust4_mol_list$Result.gene.list) <- clust4_mol_list$Name
clust4_mol <- clust4_mol_list$Result.gene.list

#########CLUSTER 5#########  
#this was not included because there were no Biological Process, Cellular Component, Molecular Function 
#GO terms in cluster 5
#cluster5 <- data.frame(GO[5])%>%dplyr::select(Cluster5.Name,Cluster5.Result.gene.list,Cluster5.Type) 
#clust5_bio <- cluster5 %>% filter(Cluster5.Type == "Biological Process")
#clust5_cell <- cluster5 %>% filter(Cluster5.Type == "Cellular Component")
#clust5_mol <- cluster5 %>% filter(Cluster5.Type == "Molecular Function")
 
#########CLUSTER 6######### 
#this was not included because there were no Biological Process or Molecular Function GO terms in cluster 6
#clust6_bio <- cluster6 %>% filter(Cluster6.Type == "Biological Process")

#Cellular Component 
clust6_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 6) 
clust6_cell_list <- as.list(clust6_cell)
names(clust6_cell_list$Result.gene.list) <- clust6_cell_list$Name
clust6_cell <- clust6_cell_list$Result.gene.list
```

```{r,include =  FALSE}
tryp_cluster_1 <- read.table("tryp_cluster_1.csv")
tryp_cluster_2 <- read_csv("tryp_cluster_2.csv")
tryp_cluster_3 <- read_csv("tryp_cluster_3.csv")
tryp_cluster_4 <- read_csv("tryp_cluster_4.csv")
tryp_cluster_5 <- read_csv("tryp_cluster_5.csv")
tryp_cluster_6 <- read_csv("tryp_cluster_6.csv")

```


# 5.2 Savage GO  

Here, we must upload the files into the trypanosome database, by taking all the rownames of the DESeq2 results analysis. What that means is, is that we are taking the names of all the DEGs found by DESeq2 and uploading them to a database for GO. Then, after writing the file, the quotations and 'x' must be deleted in order to run Geneid analysis in the database. 
This is comparison MG/SA, other comparisons MG/PV and PV/SA are not shown in the kintted file but completed. 

```{r, echo = FALSE}
###here we need to perform GO on these genes. Upload to tryp database under New search : metabolic pathways, and enter this txt file. Then, make sure to get is downloaded as a csv.
  #GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(MgSa), collapse="\t")
write.table(file_to_write, file="MgSa_gene") #look up in file directory, then delete quotation marks as well as the first rows that are not genes
```

```{r,  include =  FALSE}
#creating file for GO/PATHWAY ANALYSIS
file_to_write<-paste(rownames(MgPv), collapse="\t")
write.table(file_to_write, file="MgPv_gene")

#creating file for GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(PvSa), collapse="\t")
write.table(file_to_write, file="PvSa_gene")

```

# 6. Gene Set Enrichment Analysis  

Gene Set Enrichment Analysis interprets gene expression data by focusing on gene sets, or sets of genes that share common traits and or biological function. This algorithm uses categorical or continuous phenotype data, such as an experiment testing ‘treatment’ vs ‘untreated’. The goal of GSEA is to determine if a gene set S is randomly distributed or found at the top or bottom of a ranked gene list L. 

For our analysis, we want to 
1. Take Savage DE genes comparisons and enrich them in Schulz data  
2. Take DE genes from Schulz clusters/data and enrich them in Savage data  
3. Take GO terms from Savage data and enrich them in Schulz data  
4. Take GO terms from Schulz clusters and enrich them in Savage data  

We used fgsea package, and function fgsea(), or fast gene set enrichment analysis. 

In order to prepare our results for GSEA pipline, we must manipulate GO data tables into pathways (list), and ranks (vector). 

# 6.1 Gene Set Enrichment Analysis on Savage data 

Here we have the loaded GO analysis  of Savage data set. This set includes GO Biological Process, Molecular Function, and Cellular Component. 

```{r}

###############MAKING PATHWAY LIST FROM GO ANALYSIS - BIO, CELL,MOLECULAR###########################

####################BIO PROS GO###########################
MgSa_GObiopros <- read.table("MgSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GObiopros <- data.frame(MgSa_GObiopros, comparison = "MgSa_bio")
MgPv_GObiopros <- read.table("MgPv_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GObiopros <- data.frame(MgPv_GObiopros, comparison = "MgPv_bio")
PvSa_GObiopros <- read.table("PvSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GObiopros <- data.frame(PvSa_GObiopros, comparison = "PvSa_bio")
  
```
Here, to speed up the process, we bind all GO biological process for three comparisons MgSa, MgPv, and PvSa. We will separate the data frame using filter function using column 'comparison'.
Because the genes that are given by default in this data table are not in a list format, but rather a block of string. We need to split the genes in order to evaluate GSEA using string split them using functions gsub() and strsplit(). 
```{r}
  
all_bio <- rbind(MgSa_GObiopros,MgPv_GObiopros,PvSa_GObiopros)
all_bio$Result.gene.list[1]
all_bio$Result.gene.list <- gsub(',',',',all_bio$Result.gene.list,fixed=TRUE)
all_bio$Result.gene.list <- strsplit(all_bio$Result.gene.list, ",")
all_bio$Result.gene.list[1]
```
 
Here, using the filter function we filter data frame MgSa GO biological process, and then turn the resulting GO term data table into a list of GO terms and resulting gene names. Complete data filter and GO pathway creation for remaining GO Cellular, and Molecular pathways for MgSa, MgPv, and PvSa. 
```{r}
#MgSa Bio
MgSa_GObiopros <- data.frame(all_bio %>% dplyr :: filter(comparison == "MgSa_bio"))
MgSa_GObiopros_list <- as.list(MgSa_GObiopros)
names(MgSa_GObiopros_list$Result.gene.list) <- MgSa_GObiopros_list$Name 
MgSaGOlist_bio <- MgSa_GObiopros_list$Result.gene.list
MgSaGOlist_bio$`transmembrane transport`

```

```{r, echo = FALSE,include =  FALSE}
#MgPv Bio
MgPv_GObiopros <- data.frame(all_bio %>% filter(comparison == "MgPv_bio"))
MgPv_GObiopros_list <- as.list(MgPv_GObiopros)
names(MgPv_GObiopros_list$Result.gene.list) <- MgPv_GObiopros_list$Name
MgPvGOlist_bio <- MgPv_GObiopros_list$Result.gene.list
#PvSa Bio
PvSa_GObiopros <- data.frame(all_bio %>% filter(comparison == "PvSa_bio"))
PvSa_GObiopros_list <- as.list(PvSa_GObiopros)
names(PvSa_GObiopros_list$Result.gene.list) <- PvSa_GObiopros_list$Name
PvSaGOlist_bio <- PvSa_GObiopros_list$Result.gene.list

#####################CELL PROS#######################
  #MGSA
MgSa_GOcellpros <- read.table("MgSa_GOcellpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOcellpros <- data.frame(MgSa_GOcellpros, comparison = "MgSa_cell")
MgPv_GOcellpros <- read.table("MgPv_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOcellpros <- data.frame(MgPv_GOcellpros, comparison = "MgPv_cell")
PvSa_GOcellpros <- read.table("PvSa_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOcellpros <- data.frame(PvSa_GOcellpros, comparison = "PvSa_cell")
  
all_cell <- rbind(MgSa_GOcellpros, MgPv_GOcellpros,PvSa_GOcellpros)
all_cell$Result.gene.list <- gsub(',',',',all_cell$Result.gene.list,fixed=TRUE)
all_cell$Result.gene.list <- strsplit(all_cell$Result.gene.list, ",")

  #MGSA CELL
MgSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgSa_cell"))
MgSa_GOcellpros_list <- as.list(MgSa_GOcellpros)
names(MgSa_GOcellpros_list$Result.gene.list) <- MgSa_GOcellpros_list$Name
MgSaGOlist_cell <- MgSa_GOcellpros_list$Result.gene.list
  #MGPV CELL
MgPv_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgPv_cell"))
MgPv_GOcellpros_list <- as.list(MgPv_GOcellpros)
names(MgPv_GOcellpros_list$Result.gene.list) <- MgPv_GOcellpros_list$Name
MgPvGOlist_cell <- MgPv_GOcellpros_list$Result.gene.list
  #PVSA CELL
PvSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "PvSa_cell"))
PvSa_GOcellpros_list <- as.list(PvSa_GOcellpros)
names(PvSa_GOcellpros_list$Result.gene.list) <- PvSa_GOcellpros_list$Name
PvSaGOlist_cell <- PvSa_GOcellpros_list$Result.gene.list
#View(PvSaGOlist_cell)


##################### MOLE PROS #####################
MgSa_GOmolepros <- read.table("MgSa_GOmolecpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOmolepros <- data.frame(MgSa_GOmolepros, comparison = "MgSa_mol")
MgPv_GOmolepros <- read.table("MgPv_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOmolepros <- data.frame(MgPv_GOmolepros, comparison = "MgPv_mol")
PvSa_GOmolepros <- read.table("PvSa_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOmolepros <- data.frame(PvSa_GOmolepros, comparison = "PvSa_mol")
  
all_mol <- rbind(MgSa_GOmolepros,MgPv_GOmolepros, PvSa_GOmolepros)
all_mol$Result.gene.list <- gsub(',',',',all_mol$Result.gene.list,fixed=TRUE)
all_mol$Result.gene.list <- strsplit(all_mol$Result.gene.list, ",")

  #MGSA MOL
MgSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgSa_mol")) 
MgSa_GOmolepros_list <- as.list(MgSa_GOmolepros)
names(MgSa_GOmolepros_list$Result.gene.list) <- MgSa_GOmolepros$Name
MgSaGOlist_mole <- MgSa_GOmolepros_list$Result.gene.list
  #MGPV MOL
MgPv_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgPv_mol")) 
MgPv_GOmolepros_list <- as.list(MgPv_GOmolepros)
names(MgPv_GOmolepros_list$Result.gene.list) <- MgPv_GOmolepros$Name
MgPvGOlist_mole <- MgPv_GOmolepros_list$Result.gene.list
  #PVSA MOL
PvSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "PvSa_mol")) 
PvSa_GOmolepros_list <- as.list(PvSa_GOmolepros)
names(PvSa_GOmolepros_list$Result.gene.list) <- PvSa_GOmolepros$Name
PvSaGOlist_mole <- PvSa_GOmolepros_list$Result.gene.list



```

Creating ranks

To measure the enrichment of Savage DE genes in Schulz clusters, we need to create a ranked list based on a metric of differential expression. For this analysis, the metric used was -log10(pvlaue) * abs(logfold2change). If the p value of a resulting DE gene is very low, the -log10(pvalue) will be extremely large. Contrastly, a high logfold2change represents high expression, and a positive logfold2change shows genes are up regulated, and a negative logfold2change show genes are down regulated. Thus, the ranked vector of Savage DE genes will factor the up/down gene regulation and DE gene significance and magnitude.  


A. Making ranked metric list for GSEA: 
We want to complete these tasks for GSEA. First,we will be creating ranks for Savage data.  
  1. Ranks for Savage data (three ranks = MgSa, MgPv, PvSa)  
  2. Ranks for Schulz data (Three ranks = negative logfold, positive logfold, total)  

To begin creating the ranked list, the results data table for all Savage comparisons will be row bound and differentiated by column 'comparison' to speed up coding and process. 

```{r}
#######MAKING RANKED METRIC LIST FOR SAVAGE DATA########

#making big data set 'allcomp' with all comparisons to make code easier. Splitting by 'comparison' 
MGSA_df <- data.frame(Gene = rownames(MgSa), pvalue = MgSa$pvalue, padj = MgSa$padj, comparison = "MgSa",log2FoldChange= MgSa$log2FoldChange)
MGPV_df <- data.frame(Gene = rownames(MgPv), pvalue = MgPv$pvalue, padj = MgPv$padj, comparison = "MgPv", log2FoldChange= MgPv$log2FoldChange)
PVSA_df <- data.frame(Gene = rownames(PvSa), pvalue = PvSa$pvalue, padj = PvSa$padj, comparison = "PvSa",log2FoldChange= PvSa$log2FoldChange)
sav_allcomp <- rbind(MGSA_df,MGPV_df, PVSA_df)
```

Next, we will be creating the ranked metric, which is again the -log10(pvalue) * abs(sav_allcomp$log2FoldChange). Because we joined the DEGs for each comparison, we will need to separate them after calculating the metric, and then separatly rank each by using the function sort(). 
```{r}

sav_allcomp$logP <- -log10(sav_allcomp$pvalue) #calculating metric == -log10(pvalue)
sav_allcomp <-  sav_allcomp[which(abs(sav_allcomp$logP) != 0),] #filtering out p-values 
sav_allcomp$metric <- sav_allcomp$logP * abs(sav_allcomp$log2FoldChange)
sav_gsea_allcomp <- sav_allcomp[,c("Gene","metric","comparison")]

##filtering out big dataset -- creating data frames for each comparison 
gsea_MgSa_df<- sav_gsea_allcomp %>% filter(comparison == "MgSa") %>% dplyr :: select(-comparison) 
gsea_MgPv_df <- sav_gsea_allcomp %>% filter(comparison == "MgPv") %>% dplyr :: select(-comparison) 
gsea_PvSa_df <- sav_gsea_allcomp %>% filter(comparison == "PvSa") %>% dplyr :: select(-comparison) 
head(gsea_MgSa_df)
#creating stats and pathways for gsea
  #MgSa
gseaDat_MgSa <- filter(gsea_MgSa_df, !is.na(Gene))
gseaDat_MgSa <- gseaDat_MgSa %>% filter(metric != c(Inf, -Inf))
ranks_MgSa <- gsea_MgSa_df$metric
names(ranks_MgSa) <- gseaDat_MgSa$Gene
ranks_MgSa <- sort(ranks_MgSa)
head(ranks_MgSa)
```

```{r, echo = FALSE,include =  FALSE}
  #MgPv
gseaDat_MgPv <- filter(gsea_MgPv_df, !is.na(Gene)) 
gseaDat_MgPv <- gseaDat_MgPv %>% filter(metric != c(Inf, -Inf))
ranks_MgPv <- gsea_MgPv_df$metric
names(ranks_MgPv) <- gseaDat_MgPv$Gene
ranks_MgPv <- sort(ranks_MgPv)
#PvSa
gseaDat_PvSa <- filter(gsea_PvSa_df, !is.na(Gene) )
gseaDat_PvSa <- gseaDat_PvSa %>% filter(metric != c(Inf, -Inf))
ranks_PvSa <- gsea_PvSa_df$metric
names(ranks_PvSa) <- gseaDat_PvSa$Gene
ranks_PvSa <- sort(ranks_PvSa)

```

B. Making metric rank for T.*brucei* data  
Similar to the Savage data, we will create a ranked list of DEGs for T.*brucei* data. We will be using the 0-12h time comparison, and use resSig_012 which was created by running DESeq2 results(). This data frame has the p values, logfold2change, and padj that we will use to create this ranked list. We will separate the negative, positive, and total logfold2change to analyize the different expression patterns of genes. 

Here, we will take resSig_012, ib_12h / noo_ib, and create ranking metric -log10(pvalue) * abs(logfold2change). Because there are values of -+ \infinity for our metric, we needed to remove them for future analysis. 

This process was completed for positive and negative log fold, but is not shown in the knitted document.

```{r}
 
#Making metric rank for 0-12h comparison

#creating metric used for ranking DE of genes for TB schulz 0-12h timepoint contrast
#resSig$fcsign <- sign(resSig$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig <-  resSig[which(abs(resSig$fcsign) != 0),] #filtering out foldchanges = 0
resSig_012$logP = -log10(resSig_012$pvalue) 
resSig_012 <-  resSig_012[which(abs(resSig_012$logP) != 0),] 
resSig_012$metric= resSig_012$logP * abs(resSig_012$log2FoldChange)#calculating metric = log10(pvalue)/fcsign
resSig_012$Gene <- rownames(resSig_012) #creating column Gene for dataframe
gsea_schulz <-resSig_012[,c("Gene", "metric")]

#Creating data frame from gsea_schulz for gsea
gsea_schulz_df <- data.frame(gsea_schulz)
rownames(gsea_schulz_df) <- NULL
gsea_schulz_df <- gsea_schulz_df %>% filter(metric != "Inf",metric != "Inf") 
gsea_schulz_df[1:10,] 
#creating stats and pathways for gsea
gseaDat_schulz <- filter(gsea_schulz_df, !is.na(Gene))
ranks <- gsea_schulz_df$metric
names(ranks) <- gseaDat_schulz$Gene
ranks <- sort(ranks)
head(ranks)
```

```{r, echo = FALSE,include =  FALSE}
#####FOR LOG POS FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.pos$fcsign <- sign(resSig_log.pos$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.pos$logP = -log10(resSig_log.pos$pvalue) 
resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$logP) != 0),] 
resSig_log.pos$metric= resSig_log.pos$logP * abs(resSig_log.pos$log2FoldChange) #metric = -log10(pvalue) *abs(log2FoldChange)
resSig_log.pos$Gene <- rownames(resSig_log.pos) #creating column Gene for dataframe
gsea_schulz_log.pos <-resSig_log.pos[,c("Gene", "metric")]
 
  #creating data frame
gsea_schulz_df_log.pos <- data.frame(gsea_schulz_log.pos)
rownames(gsea_schulz_df_log.pos) <- NULL
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos %>% filter(metric != "Inf",metric != "Inf") 

gsea_schulz_df_log.pos[1:10,]

  #creating ranks for fgsea
gseaDat_schulz_log.pos <- filter(gsea_schulz_df_log.pos, !is.na(Gene))
ranks_log.pos <- gsea_schulz_df_log.pos$metric
names(ranks_log.pos) <- gseaDat_schulz_log.pos$Gene
ranks_log.pos <- sort(ranks_log.pos)
head(ranks_log.pos)
#####FOR LOG NEG FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.neg$fcsign <- sign(resSig_log.neg$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.neg$logP <-  -log10(resSig_log.neg$pvalue)
resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$logP) != 0),] 
resSig_log.neg$metric <-  resSig_log.neg$logP * abs(resSig_log.neg$log2FoldChange) #calculating metric = log10(pvalue) 
resSig_log.neg$Gene <- rownames(resSig_log.neg) #creating column Gene for dataframe
gsea_schulz_log.neg <-resSig_log.neg[,c("Gene", "metric")]

  #creating data frame
gsea_schulz_df_log.neg <- data.frame(gsea_schulz_log.neg)
rownames(gsea_schulz_df_log.neg) <- NULL
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg %>% filter(metric != "Inf",metric != "Inf") 

gsea_schulz_df_log.neg[1:10,]
  #creating ranks for fgsea
gseaDat_schulz_log.neg <- filter(gsea_schulz_df_log.neg, !is.na(Gene))
ranks_log.neg <- gsea_schulz_df_log.neg$metric
names(ranks_log.neg) <- gseaDat_schulz_log.neg$Gene
ranks_log.neg <- sort(ranks_log.neg)
head(ranks_log.neg)

```

Now, we will complete GSEA on Savage DE genes that are enriched in Schulz DE genes 0-12 hours. We first need to make a list of all the gene names of the DEG found from the MgSa etc comparisons. 

```{r}

################################GSEA on all SAV DE genes########################################
####need to make list of all 'pathways'
sav_all_list <- c()
  #for MgSa
MgSa_list <- rownames(MgSa)
  #for MgPv
MgPv_list <- rownames(MgPv)
  #for PvSa
PvSa_list <- rownames(PvSa)
 
#creating full list for all savage 
sav_all_list$MgSa <- MgSa_list
sav_all_list$MgPv <- MgPv_list
sav_all_list$PvSa <- PvSa_list
```

For the function fgsea(), the function takes the argument *stats*, which is a named vector of gene-level stats, and the names should be the same as in 'pathways'. Here, *stats* are the ranks we created for each DEG set. The second argument is nperm, which Number of permutations that the function will run through. The higher the permutations the more accurate the results will be, so we chose to have permutations set to 1000. The third argument is minSize, which is the minimal size of a gene set to test. All pathways below the threshold are excluded. Here we will need to specify at least 1 since we are comparing a whole set of MgSa, MgPv, and PvSa to T.*brucei* data. 

```{r}
#FGSEA on SAV DE GENES (NO GO)

fgseaRes_all <- fgsea(pathways = as.list(sav_all_list), stats = ranks, minSize = 1,  nperm = 1000)
fgseaRes_all
```

We can see here that our p values are very small, signaling very significant results. We will need to conduct further analysis on the biological significance of these results, however it is interesting to see the statistical significance of our results. 

In order to visualize the GSEA results, we will create a GSEA enrichment plot, which takes in the pathways, of gene set to plot, and the stats, which are the ranks of a DEG list. Here, we will plot the pathway of MgSa, with the ranks of T.*brucei* data. Here we need to specify from sav_all_list$MgSa becuase we want to look at the particular set MgSa. 
```{r}
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks ) + labs(title ="MgSa")
```
On this graph, we can see that the gene lines on the bottom are the ranked list of the T.*brucei* data. The enrichment score is based on the MgSa GO terms and how they are overrepresented at the extremes(top or bottom) of the entire ranked T.*brucei* list.  In this graph, we can see that many of the genes in the MgSa GO terms are 

```{r, include =  FALSE}
fgseaRes_all_pos <- fgsea(pathways = as.list(sav_all_list), stats = ranks_log.pos, minSize = 1,  nperm = 1000)
fgseaRes_all_pos

plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks_log.pos) + labs(title ="MgSa pos log fold")
```

```{r,include =  FALSE}
fgseaRes_all_neg <- fgsea(pathways = as.list(sav_all_list), stats = ranks_log.neg, minSize = 1,  nperm = 1000)
fgseaRes_all_neg

plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks_log.neg) + labs(title ="MgPv Negative log fold")
```

```{r, echo = FALSE,include =  FALSE}
##########NEG FOLD CHANGE ENRICHMENT#########
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks_log.neg) + labs(title = "MgSa Negative log fold")
plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks_log.neg) + labs(title ="MgPv Negative log fold")
plotEnrichment(pathway = sav_all_list$PvSa,
               stats  = ranks_log.neg) + labs(title ="PvSa Negative log fold")
##########POS FOLD CHANGE ENRICHMENT#########
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks_log.pos) + labs(title ="MgSa pos log fold")
plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks_log.pos) + labs(title ="MgPv pos log fold")
plotEnrichment(pathway = sav_all_list$PvSa,
               stats  = ranks_log.pos) + labs(title ="PvSa pos log fold")
##########TOTAL ENRICHMENT##################
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks ) + labs(title ="MgSa")
plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks ) + labs(title ="MgPv")
plotEnrichment(pathway = sav_all_list$PvSa,
               stats  = ranks ) + labs(title ="PvSa")



```


Here, we have GO analysis results from three comparisons of savage data, MgSa, MgPv, and PvSa. We will test these pathways on our data, separated into negative and positive log fold change, and ranked by the metric -log(pvalue)*abs(logfold2change). We will perform fgsea on each pathway, for positive, and negative ranked DE genes from our time point 0 to 12hours. 

```{r, echo = FALSE }
 ########################FGSEA -- SAV GO DATA ENRICHED IN OUR DATA################################
 
#In order to complete GSEA, we must create pathways, or gene lists that help us determine if that particular gene set is enriched in a gene expression data set. 

all_list <- c()
all_list$MgSa_bio <- MgSaGOlist_bio
all_list$MgPv_bio <- MgPvGOlist_bio
all_list$PvSa_bio <- PvSaGOlist_bio
all_list$MgSa_cell <- MgSaGOlist_cell
all_list$MgPv_cell <- MgPvGOlist_cell
all_list$PvSa_cell <- PvSaGOlist_cell
all_list$MgSa_mole <- MgSaGOlist_mole
all_list$MgPv_mole <- MgPvGOlist_mole
all_list$PvSa_mole <- PvSaGOlist_mole

fgsea_all_pos <- c()
fgsea_all_neg <- c()
for (i in 1:9){
fgsea_all_pos[[i]] = fgsea(pathways = as.list(all_list[[i]]), stats = ranks_log.pos, minSize = 15,  nperm = 1000)
fgsea_all_neg[[i]] = fgsea(pathways = as.list(all_list[[i]]), stats = ranks_log.neg, minSize = 15,  nperm = 1000)
}
names(fgsea_all_neg) <- names(all_list)
names(fgsea_all_pos) <- names(all_list)
```
This data table shown below shows pathway MgSaGOlist_bio enriched in the negalitve log fold change DEG ranked list of T.*brucei* data. We can see the pathway transmembrane transport, transport, localization and establishment of localization all have the same padj. 
```{r}
fgsea_all_neg[1]
```
Here, we have GSEA plot of MgSa Biological Process GO term and genes enriched in Schulz negative log DEGs. The enrichment score for transport is 0.8868227. We can see the most enriched pathway is transport. In this instance, we will further discuss which plots and which analysis to include in GSEA to best answer the biological questions of our data set. 
```{r}
plotEnrichment(all_list$MgSa_bio[[head(fgsea_all_neg$MgSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_bio[order(pval), ], 1)$pathway)

```



```{r, include = FALSE}
 

plotEnrichment(all_list$MgSa_mole[[head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway)
 
#Here, MgSa Cellular Component GO terms and genes enriched in Schulz negative log DEGs.
 
#fgsea_all_neg[4]

 
#Here, MgPv Cellular Component GO DEGs enriched in Schuls negative log DEGs
 
#fgsea_all_neg[5]
plotEnrichment(all_list$MgPv_cell[[head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway)
 
#Here, PvSa Cellular Component DEGs enriched in Schulz negative log DEGs
 
#fgsea_all_neg[6]
plotEnrichment(all_list$PvSa_cell[[head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway)
```

```{r, echo = FALSE,include =  FALSE}
#####################MGSA ENRICHMENT########################

########POSLOG###########
plotEnrichment(all_list$MgSa_bio[[head(fgsea_all_pos$MgSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgSa_cell[[head(fgsea_all_pos$MgSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgSa_mole[[head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway)
########NEG LOG###########
plotEnrichment(all_list$MgSa_bio[[head(fgsea_all_neg$MgSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgSa_cell[[head(fgsea_all_neg$MgSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_cell[order(pval), ], 1)$pathway)

#plotEnrichment(all_list$MgSa_mole[[head(fgsea_all_neg$MgSa_mole[order(pval), ], 1)$pathway]],
               #ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_mole[order(pval), ], 1)$pathway)

#####################MGPV ENRICHMENT########################

########POS LOG###########
plotEnrichment(all_list$MgPv_bio[[head(fgsea_all_pos$MgPv_bio[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgPv_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_cell[[head(fgsea_all_pos$MgPv_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgPv_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_mole[[head(fgsea_all_pos$MgPv_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgPv_mole[order(pval), ], 1)$pathway)
########NEG LOG###########
plotEnrichment(all_list$MgPv_bio[[head(fgsea_all_neg$MgPv_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_cell[[head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_mole[[head(fgsea_all_neg$MgPv_mole[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_mole[order(pval), ], 1)$pathway)
 
#####################PVSA ENRICHMENT########################

########POS LOG###########
plotEnrichment(all_list$PvSa_bio[[head(fgsea_all_pos$PvSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$PvSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_cell[[head(fgsea_all_pos$PvSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$PvSa_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_mole[[head(fgsea_all_pos$PvSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$PvSa_mole[order(pval), ], 1)$pathway)

########NEG LOG###########
plotEnrichment(all_list$PvSa_bio[[head(fgsea_all_neg$PvSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_cell[[head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_mole[[head(fgsea_all_neg$PvSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_mole[order(pval), ], 1)$pathway)

```
 
# 6.2 GSEA: Fuzzy - Running GSEA - Preparing Schulz Clusters for pathways  


# 7 Conclusion   

Through this analysis of Schulz's data set of Trypanosoma Brucei, we identified the best normalization method, identified DEGs by using Differential Expression tools that used independent and dependent time modeling, and clustered those DEGs using 2 different algorithms. Then, we compared the time course T.*brucei* data to Savage environmental/location based data. Using Fuzzy clustering, we ran Gene Ontology analysis on each cluster, as well as DEGs from Savage data and T.*brucei* data. From this we determined which DEGs were overrepresented in T.*brucei* data using Gene Set Enrichment Analysis and plotting the results from the GSEA. Of these plotted, there will be more analysis on which clusters will be biologically significant. 

In analyzing our results, we can see that GO analysis of Fuzzy clusters in bromodomain-inhibited T. brucei suggest a possible  developmental change. We can see this where Cluster 1 GO terms indicate upregulation of motility related genes. T.*brucei* movement through host tissues is essential for development & pathogenesis, particularly in migrating through the tissues of the insect host (Dimitrova et al. 2017).
 We can also see in the GSEA on Savage DEG GO terms on Schulz 0-12 hours DEGs show enrichment in membrane and transport function in T.*brucei* PF. 
To continue this project, we would need to continue to identify and assign biological meaning to DEGs, and look more into GO analysis. Furthermore, we will need to look into clusering algorithms and make sure that each person will get the same result when using the function, and that the biologist will agree and be able to interpert our results. We will mainly be looking at fuzzy clustering algorithm, and identify either mistakes, or better ways to cluster the DEGs.

 
# Citations  

Fischer, et al. “Impulse Model-Based Differential Expression Analysis of Time Course Sequencing Data.” OUP Academic, Oxford University Press, 8 Aug. 2018, academic.oup.com/nar/article/46/20/e119/5068248.

 Conesa, Ana, and Nueda Mar ́ıa  J. “MaSigPro User’s Guide.” Bioconductor.org, 4 Sept. 2017, www.bioconductor.org/packages/release/bioc/vignettes/maSigPro/inst/doc/maSigProUsersGuide.pdf.


Ruairi , Mackenzie J. “RNA-Seq: Basics, Applications and Protocol.” Genomics Research from Technology Networks, 6 Apr. 2018, www.technologynetworks.com/genomics/articles/rna-seq-basics-applications-and-protocol-299461.

Love, Michael, et al. Beginner’s Guide to Using the DESeq2 Package. 13 May 2014, bioc.ism.ac.jp/packages/2.14/bioc/vignettes/DESeq2/inst/doc/beginner.pdf.

Schulz, Danae, et al. “Bromodomain Proteins Contribute to Maintenance of Bloodstream Form Stage Identity in the African Trypanosome.” PLoS Biology, Public Library of Science, 8 Dec. 2015

www.ncbi.nlm.nih.gov/pubmed/26646171.


