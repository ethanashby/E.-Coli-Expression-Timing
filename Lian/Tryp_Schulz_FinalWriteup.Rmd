---
title: "Tryp_schulz_FinalWriteup"
author: "Lian Morales"
date: "7/22/2019"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
#tinytex::install_tinytex()
library("dplyr")
library("tidyr")
library("DESeq2")
library(readr)
library(devtools)
library("DESeq2")
library(readr)
library(tidyr)
library(ggplot2)
library("vsn")
library("hexbin")
library("corrplot")
library("tidyverse")
library(stringr)
library("Hmisc")
library(cluster)
library("mclust")

#for GSEA
library(doParallel)
library(Biobase)
library(biomaRt)
library(fgsea)
```

#Table of Contents
1. Background
2. RNA-Seq Overview
3. Start With the Raw Read Counts
4. Quality Control
5. Normalize All Counts
6. Differential Expression Analysis
7. Grouping Methods
8. GO Analysis
9. GSEA 

#1. Background 
Trypanosoma brucei (T. brucei) is a protozoan parasite that causes African Trypanosomiasis, commonly known as sleeping sickness, in humans and other mammals. This parasite is transmitted into mammals through an insect vector, the Tsetse fly. During its infectious cycle, the parasite maintains several life stages throughout changing environments of insect and mammal. Of those most studied are trypanosoma in the Bloodstream form and the procyclic form. 
 These life cycle stages differ in their cell-surface landscapes, cytochrome-associated metabolism in the mitochondrion, endocytic activity, cell-cycle checkpoints, and morphology. These profound biological changes are associated with cognizable changes in the parasite’s transcriptome (Savage et al, 2016), however, very little is known about how gene expression is regulated in T. brucei (Siegel et al, 2010).

Upon entering a mammal, T.brucei undergoes biological and cell surface landscape changes, marking the distinction between bloodstream forms and procyclic form. Cell surface variant surface glycoproteins (VSG) are the differences between these two forms. T.brucei BF VSGs provides security to human body immune response. By varying ~2,500 distinct surface glycoprotein genes, the parasite can evade human/mammal antibody response and continue to infect host. 

A known protein bromodomain,which are important transcriptional regulators in T. brucei. Has veen suggested to control cell fate through recognition of epigenetic modifications of histones (Di Micco et al 2014). Inhibition of bromodomain has been found to prohibit certain bloodstream form function, such as mobility, reproduction, and transcriptional factors. Cell-surface landscapes, and decrease in virulence in the BF have lead to hypothesis of turning into the PF. Therefore, the conclusion arises that bromodomain maintains main BF function and thus have implications that by inhibiting this protein, the trypanosome undergoes the transition of BF to PF, which is less virulent in human/mammal host. 

This summer, we have looked at the result of research studying the effects of bromodomain inhibition in the trypanosome PF. Building off of past research, and understanding   Bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, we  measured gene expression in WT PF and bromodomain-inhibited PF over 2 week time course, Determined differentially expressed genes (DEGs) between these two conditions, and finally help predict the effect of bromodomain inhibition on gene expression in insect form through data analysis.  


#2. RNA-Seq Overview
RNA Sequencing (RNA-seq) is a way to measure gene expression in an organism. The RNA is extracted and RNA reads (sequences of A, G, C, and U) are aligned to the organism's genome. The higher the number of reads mapped to a certain gene, the more we can say that gene is expressed.  

#3. Starting with the raw read counts

```{r}
 
TBcounts <- read.table("18-5-23_Proc_ibet_TC_for_deseq.txt",header = TRUE) %>% dplyr ::select(-ib_3h_1) 
TBcounts <- TBcounts %>% dplyr :: distinct(gene, .keep_all = TRUE) 
#NORMALIZATION BY DESEQ2
rownames(TBcounts) <- TBcounts$gene #renames the gene row
TBcounts <- TBcounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
#creating new data frame for DESeq to analyze
tb_new <- data.frame(rownames = colnames(TBcounts),
                     reps = as.factor(c(1,2,3,1,2,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3)),
                    stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3))))
rownames(tb_new) <- tb_new$rownames
tb_new <- tb_new %>% dplyr ::select(-rownames)
```
 As you can see in the code above, the breakdown of our data invlolves separating the repetitions of the samples and times, or stages of the experiment. In the first line, we see that the treated sample 1 at 3 hours(ib_3h_1) is not included in our data analysis. This is becuase it is an outlier determined by Professor Schulz. 
 For DESeq, the alrogithm requires the input of a new data table that includes the conditions of the samples. Here, tb_new includes reps, which are the number of repetitions per sample, and stage, which states wheter a sample is treated, ib, or utreated, noo_ib, as well as the time at which this sample was taken. 
#4. Quality Control 
In order to gather accurate results, the data must be filtered. Here, we filtered genes that had expression levels > 0. 
#5. Normalize Raw Counts

```{r, include = FALSE}
##dds stands for the DESeq Data Set
TBcounts <- TBcounts[rowSums(TBcounts) > 0 ,]
ddsFullCountTable <- DESeqDataSetFromMatrix(countData = TBcounts,
                                            colData = tb_new, 
                                            design = ~ reps + stage)

TBcounts_dds <- DESeq(ddsFullCountTable)
#calculating norm counts
##DESeq2 :: allows to specify where this fcn comes from
normDE_counts <- DESeq2::counts(TBcounts_dds, normalized = TRUE) 
normDE_counts_df <- data.frame(normDE_counts)
 
```

We must normalize the counts because each sample is sequenced at a different depth in RNA Seq. The sequencing depth of each sample refers to the total raw read count (column sum) of that sample. If we simply used the raw read counts from the data table given us by RNASeq, we wouldn't be comparing apples to apples because of that difference in sequencing depth.

We use DESeq's normalization technique which is a standard method for this type of analysis. DESeq normalizes by taking the raw count of that gene at that sample over the geometric mean of the raw read count for that gene across all samples. The algoritm then does this for all genes, and you get a sample-specific vector of numbers. Take the median of that vector, and you have the "size factor" for your sample. Size factors essentially tell us how deeply the sample is sequenced, and the ratio of the size factors of two different samples is an approximation of the ratio of their sequencing depths. ALthough there are numerous normalization techinques, such as edgeR, TKPM, ImpulseDE2, maSigPro, DESeq2 was preferable to the fast run time, as well as the simple and easy input. 

Our analysis compares the 0 time point to the 12 hour time point, because we are more interested in earlier time points due to the increased gene expression shown from 0-12 hours. 

For DESeq2, the results for a comparison of any two levels of a variable can be calculated using the contrast argument to the results function. The function requires three values: the name of the variable, the name of the level in the numerator, and the name of the level in the denominator. We will complete the same analysis (not shown) on comparisons MG/PV and PV/SA 
Here we extract results for the log2 of the fold change of treated 12h and untreated 0h, ib_12h / noo_ib. 



```{r}
#COMPARING - DE ANALYSIS - FOR GSEA

#comparing stages noo_ib and ib_12h --- the stage of non inhibited bromodomain at time 0 to inhibited bromodomain at time point 12 hours
TBcountsRes <- results( TBcounts_dds ,contrast = c("stage","ib_12h", "noo_ib"))
TBcountsRes
```

In order to correct for multiple testing, DESeq2 uses Benjamini-Hochberg (BH) adjustment, which is a method that decreases the false discovery rate(FDR). Due to the fact that small p-values often happen by chance, the tool helps remove the possibility of falsely rejecting the try null hypothesis. For example, if one had a very low p-value(<.05), it would mean that there is only a 5% chance that you would get your observed result granted the null was true. Thus, with a pvalue of 0.05, it is highly unlikely that your null is incorrect. So, in order to eliminate the possibility of FDR, the BH adjustment adjusts for the probability of a FDR. For example, if one called all genes that are signigicant are those with a p value less than or equal to a gene’s p value threshold, the BH method calculates the fraction of false positives among those genes. These values, called the BH-adjusted p values, are given in the column padj of the results object.

For our data, we considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Schulz dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  
 
For further analysis, we group the positive, and negative logfold2 changes. This is because down regulated genes have negative logfold2change and upregulated genes have a positive logfold2change. Therefore, by splitting up the data into up and down regulated genes, we can succesfully, and more clearly identify biological pathways for future analysis, such as Gene Ontology and Gene Set Enrichment Analysis.
```{r}
#resSig_012 stands for the results of the signigicant genes expressed in comparison of noo_ib and ib_12h
resSig_012 <- TBcountsRes[ which(TBcountsRes$padj < 0.01 ), ]
resSig_012 <- resSig_012[complete.cases(resSig_012),]
resSig_012$gene <- rownames(resSig_012)
resSig_012$fcsign <- sign(resSig_012$log2FoldChange) #fcsign stands for the log2foldchange sign
resSig_012

#creating negative and positive logfold change data sets
resSig_log.pos <- resSig_012[which(resSig_012$fcsign != -1),]
resSig_log.neg <- resSig_012[which(resSig_012$fcsign == -1),]
```

#8. Savage Data - DESeq2 pipeline

In order to answer Schulz's question of bromodomain inhibition impact on trypanosome PF, we must compare our results to Savage 2015 data, which includes trypanosoma DE genes gathered from enviromental based experiments in the Tsetse fly. The results of Savage 2015 data details the biological change in trypanosoma based on enviromental conditions. By comparing our DE genes to Savage enviromnet based DE genes, we can come to conclusions about what form the bromodomain inhibited PF will revert to, if at all. 
By comparing MG to SA, the resulting DE genes are those that exemplify the difference between BF and PF. These genes are very important in our understanding of the changes that Schulz samples undergo. For example, if there is a high amount of correlation between DE genes in MG to SA and 0h - 12h, we can hypothesize that bromodomain inhibition in PF causes a revert to the BF. 

Thus, by completing DESeq and future biological analysis on Savage data, we can come to a more concrete conclusion of bromodomain function in trypanosoma. 
 

Similar to analyzing our data, we must analyze 2015 Savage data, using the same pipeline: 
  1. Run raw read counts
  2. Filter/Quality Control
  3. Run Differental Gene Expression Analysis using DESEq2.
  
First, we must read in our data table. Variable 'savagecounts' represents this data table of Savage raw read counts. 
Similar to our data, we must manipulate our savagecounts data table for DESeq2. 
```{r, include  = FALSE}
#DESEQ ON SAVAGE DATA - THREE COMPARISON MGSA MGPV PVSA

savagecounts <- read.table("18-5-24_dedup_Savage_deseq_counts.txt", header = TRUE)

 
#Creating Data matrix 
rownames(savagecounts) <- savagecounts$gene #renames the gene row
savagecounts <- savagecounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
coldata <- data.frame(rownames = colnames(savagecounts),
                    reps = as.factor(c(1, 2, 3, 1, 2, 3 ,4,
                                     1, 2 ,3)), 
                    stage = as.factor(c(rep("MG",3),rep("PV",4), rep("SA",3))))

ddsFullCountTable <- DESeqDataSetFromMatrix(
   countData = savagecounts,
   colData = coldata,
   design = ~ reps + stage)
#DESeq2 getting DE genes
savagecounts_dds <- DESeq(ddsFullCountTable )

```  
 
 As you can see in the above chunk, savage data was run through the same pipeline, creating a new data frame for DESeq2 with variables reps, which are the repetition of the samples, and stage, which now represents the location of where the trypanosome was sampled: Migut, Proventiculus, Salivary gland.


#8. Savage Data  
Here we are completing DESEq results on Savage data. We have a adjusted pvalue (padj) filter of < 0.01, a log2foldchange > 1.5. 
The comparisons we completed are:
1. MgSa (Midgut and Salivary Gland)
$~$
2. MgPv (Migut and Proventiculus)
$~$
3. PvSa (Proventiculus and Salivary Gland)
$~$
 We will complete the same analysis on Schulz data on the comparisons MG/SA, MG/PV and PV/SA. 
Here we extract results for the log2 of the fold change of MG and SA. 
```{r}
#Comparisons of all 
  #padj filter < 0.01
  #abs(log2fold) filter > 1.5
#MG and SA############################################################################
savageRes_MgSa <- results( savagecounts_dds ,contrast = c("stage",  "MG","SA"))
savageRes_MgSa
```
 
For Schulz data, we also considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Savage to compare to our dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  

Similar to filtering the padj, we want to filter the logfold2change. If a gene has a high absolute value log2foldchange, it means the gene is highly expressed. In order to cut down the amount of DE genes, filtering of this parameter will select only the higly expressed genes for our analysis of Savage data against our own. The cutoff logfold2 value 1.5 was arbitrarly chosen based on needing ~200-500 DE genes for further analysis. 

```{r}
resSig <- savageRes_MgSa[ which(savageRes_MgSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgSa <- resSig
head(MgSa) 
```
Here is the padj and logfold2 filtered results of the log2 of the fold change of MG and SA.
The rownames of this table are the DE genes calculated from the results function. 

We completed the same analysis on comparisons MG/PV and PV/SA (not shown) with same parameters and filtering. 
```{r, echo = FALSE}
#MG and PV############################################################################
savageRes_MgPv <- results( savagecounts_dds ,contrast = c("stage",  "MG","PV"))
resSig <- savageRes_MgPv[ which(savageRes_MgPv$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgPv <- resSig

#PV and SA############################################################################
savageRes_PvSa <- results( savagecounts_dds ,contrast = c("stage",  "PV","SA"))
resSig <- savageRes_PvSa[ which(savageRes_PvSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
PvSa <- resSig


```

#7. Grouping Methods

In order to answer the biological questions of our data, we need to take statisitcal steps to gather information in order to prove or answer the hypothesis at hand. Clustering our data is an example of this method. Here we are taking the fuzzy cluster GO analysis results, and preparing them for GSEA pipeline. 
(cluster code here)



#8. GO analysis 
In order to assign biological meaning to our results, we must understand the biological background behind our DE genes. GO analysis, or Gene Ontology term enrichment is a way to charachterize genes through assigning them to cell/organism specific pathways. The Gene Ontology system of classification assigns genes to a set of predefined pathways depending on their functional characteristics. For example, if a gene FasR is categorized as being a receptor, bing involved in apoptosis and located on the plasma membrane. Thus, by being able to group our DE genes by biologocal funciton, we can come to a fuller conclusion of our data using biological results.

For GO on Schulz and savage data, we used a database https://tritrypdb.org/tritrypdb/, and completed GeneId search for our DE genes, which give additional information on the specific information on each gene. Then, after completing Geneid search, click on the tab "Analyze Results" and then GO. For our data, we completed Cellular Component, Molecular Function, and Biological Process GO enrichment. The downloaded tabs are in the folder labled "GO_Terms"
 
https://en.wikipedia.org/wiki/Gene_Ontology_Term_Enrichment

Here, we must upload the files into the trypanosome database, by taking all the rownames of the DESeq2 results analysis. Then, after writing the file, the quotations and 'x' must be deleted in order to run Geneid analysis in the data base. 
This is comparison MG/SA, other comparisons MG/PV and PV/SA are not shown but completed. 

```{r}
###here we need to preform GO on these genes. Upload to tryp database under New search : metabolic pathways, and enter this txt file. Then, make sure to get is downloaded as a csv.
  #GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(MgSa), collapse="\t")
write.table(file_to_write, file="MgSa_gene") #look up in file directory, then delete quotation marks as well as the first rows that are not genes
```

```{r, include = FALSE}
#creating file for GO/PATHWAY ANALYSIS
file_to_write<-paste(rownames(MgPv), collapse="\t")
write.table(file_to_write, file="MgPv_gene")

#creating file for GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(PvSa), collapse="\t")
write.table(file_to_write, file="PvSa_gene")

```

#9 GSEA analysis
Gene Set Enrichment Analysis interpers gene expression data by focusing on gene sets, or sets of genes that share common traits and or biological function. This alrogith uses categorical or continuous phenotype data, such as an experiment testing ‘treatment’ vs ‘untreated’. The goal of GSEA is to determine if a gene set S is randomly distributed or found at the top or bottom of a ranked gene list L. 

For our analysis, we want to 
Take Savage DE genes comparisons and enrich them in Schulz data
Take DE genes from Schulz clusters/data and enrich them in Savage data
Take GO terms from Savage data and enrich them in Schulz data
Take GO terms from Schulz clusters and enrich them in Savage data

We used fgsea(), or fast gene set enrichment analysis. 

In order to prepare our results for GSEA pipline, we must manipulate GO data tables into pathways (list), and ranks (vector). 

```{r}

###############MAKING PATHWAY LIST FROM GO ANALYSIS - BIO, CELL,MOLECULAR###########################

####################BIO PROS GO###########################
MgSa_GObiopros <- read.table("MgSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GObiopros <- data.frame(MgSa_GObiopros, comparison = "MgSa_bio")
MgPv_GObiopros <- read.table("MgPv_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GObiopros <- data.frame(MgPv_GObiopros, comparison = "MgPv_bio")
PvSa_GObiopros <- read.table("PvSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GObiopros <- data.frame(PvSa_GObiopros, comparison = "PvSa_bio")
  
```
Here, to speed up the process, we bind all GO biological process for three comparisons MgSa, MgPv, and PvSa. We will separate the data frame using fiulter function using column 'comparison'.
Because the genes that are given by default in this data table are not in a list format, but rather a block of string. We need to split the genes in order to evaluate GSEA using string split them using functions gsub() and strsplit(). 
```{r}
  
all_bio <- rbind(MgSa_GObiopros,MgPv_GObiopros,PvSa_GObiopros)
all_bio$Result.gene.list[1]
all_bio$Result.gene.list <- gsub(',',',',all_bio$Result.gene.list,fixed=TRUE)
all_bio$Result.gene.list <- strsplit(all_bio$Result.gene.list, ",")
all_bio$Result.gene.list[1]
```
 
 Here, using the filter funciton we filter data frame MgSa GO biological process, and then turn the resulting GO term data table into a list of GO terms and resulting gene names. Complete data filter and GO pathway creation for remaining GO Cellular, and Molecular pathways for MgSa, MgPv, and PvSa. 
```{r}
#MgSa Bio
MgSa_GObiopros <- data.frame(all_bio %>% dplyr :: filter(comparison == "MgSa_bio"))
MgSa_GObiopros_list <- as.list(MgSa_GObiopros)
names(MgSa_GObiopros_list$Result.gene.list) <- MgSa_GObiopros_list$Name 
MgSaGOlist_bio <- MgSa_GObiopros_list$Result.gene.list
MgSaGOlist_bio$`transmembrane transport`

```

```{r, include = FALSE}
#MgPv Bio
MgPv_GObiopros <- data.frame(all_bio %>% filter(comparison == "MgPv_bio"))
MgPv_GObiopros_list <- as.list(MgPv_GObiopros)
names(MgPv_GObiopros_list$Result.gene.list) <- MgPv_GObiopros_list$Name
MgPvGOlist_bio <- MgPv_GObiopros_list$Result.gene.list
#PvSa Bio
PvSa_GObiopros <- data.frame(all_bio %>% filter(comparison == "PvSa_bio"))
PvSa_GObiopros_list <- as.list(PvSa_GObiopros)
names(PvSa_GObiopros_list$Result.gene.list) <- PvSa_GObiopros_list$Name
PvSaGOlist_bio <- PvSa_GObiopros_list$Result.gene.list

#####################CELL PROS#######################
  #MGSA
MgSa_GOcellpros <- read.table("MgSa_GOcellpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOcellpros <- data.frame(MgSa_GOcellpros, comparison = "MgSa_cell")
MgPv_GOcellpros <- read.table("MgPv_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOcellpros <- data.frame(MgPv_GOcellpros, comparison = "MgPv_cell")
PvSa_GOcellpros <- read.table("PvSa_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOcellpros <- data.frame(PvSa_GOcellpros, comparison = "PvSa_cell")
  
all_cell <- rbind(MgSa_GOcellpros, MgPv_GOcellpros,PvSa_GOcellpros)
all_cell$Result.gene.list <- gsub(',',',',all_cell$Result.gene.list,fixed=TRUE)
all_cell$Result.gene.list <- strsplit(all_cell$Result.gene.list, ",")

  #MGSA CELL
MgSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgSa_cell"))
MgSa_GOcellpros_list <- as.list(MgSa_GOcellpros)
names(MgSa_GOcellpros_list$Result.gene.list) <- MgSa_GOcellpros_list$Name
MgSaGOlist_cell <- MgSa_GOcellpros_list$Result.gene.list
  #MGPV CELL
MgPv_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgPv_cell"))
MgPv_GOcellpros_list <- as.list(MgPv_GOcellpros)
names(MgPv_GOcellpros_list$Result.gene.list) <- MgPv_GOcellpros_list$Name
MgPvGOlist_cell <- MgPv_GOcellpros_list$Result.gene.list
  #PVSA CELL
PvSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "PvSa_cell"))
PvSa_GOcellpros_list <- as.list(PvSa_GOcellpros)
names(PvSa_GOcellpros_list$Result.gene.list) <- PvSa_GOcellpros_list$Name
PvSaGOlist_cell <- PvSa_GOcellpros_list$Result.gene.list
#View(PvSaGOlist_cell)


##################### MOLE PROS #####################
MgSa_GOmolepros <- read.table("MgSa_GOmolecpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOmolepros <- data.frame(MgSa_GOmolepros, comparison = "MgSa_mol")
MgPv_GOmolepros <- read.table("MgPv_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOmolepros <- data.frame(MgPv_GOmolepros, comparison = "MgPv_mol")
PvSa_GOmolepros <- read.table("PvSa_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOmolepros <- data.frame(PvSa_GOmolepros, comparison = "PvSa_mol")
  
all_mol <- rbind(MgSa_GOmolepros,MgPv_GOmolepros, PvSa_GOmolepros)
all_mol$Result.gene.list <- gsub(',',',',all_mol$Result.gene.list,fixed=TRUE)
all_mol$Result.gene.list <- strsplit(all_mol$Result.gene.list, ",")

  #MGSA MOL
MgSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgSa_mol")) 
MgSa_GOmolepros_list <- as.list(MgSa_GOmolepros)
names(MgSa_GOmolepros_list$Result.gene.list) <- MgSa_GOmolepros$Name
MgSaGOlist_mole <- MgSa_GOmolepros_list$Result.gene.list
  #MGPV MOL
MgPv_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgPv_mol")) 
MgPv_GOmolepros_list <- as.list(MgPv_GOmolepros)
names(MgPv_GOmolepros_list$Result.gene.list) <- MgPv_GOmolepros$Name
MgPvGOlist_mole <- MgPv_GOmolepros_list$Result.gene.list
  #PVSA MOL
PvSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "PvSa_mol")) 
PvSa_GOmolepros_list <- as.list(PvSa_GOmolepros)
names(PvSa_GOmolepros_list$Result.gene.list) <- PvSa_GOmolepros$Name
PvSaGOlist_mole <- PvSa_GOmolepros_list$Result.gene.list



```

Creating ranks

To measure the enrichment of Savage DE genes in Schulz clusters, we need to create a ranked list based on a metric of differental expression. For this analysis, the metric used was -log10(pvlaue) * abs(logfold2change). If the pvalue of a resulting DE gene is very low, the -log10(pvalue) will be extremely large. Contrastly, a high logfold2change represents high expression, and a positive logfold2change shows genes are up regulated, and a negative logfold2change show genes are down regulated. Thus, the ranked vector of Savage DE genes will factor the up/down gene regulation and DE gene significance and magnitude.  

To begin creating the ranked list, the results data table for all Savage comparisons will be row binded and differitated by colum 'comparison' to speed up coding and process. 
```{r}
#######MAKING RANKED METRIC LIST FOR SAVAGE DATA########

#making big data set 'allcomp' with all comparisons to make code easier. Splitting after by 'comparison' 
MGSA_df <- data.frame(Gene = rownames(MgSa), pvalue = MgSa$pvalue, padj = MgSa$padj, comparison = "MgSa",log2FoldChange= MgSa$log2FoldChange)
MGPV_df <- data.frame(Gene = rownames(MgPv), pvalue = MgPv$pvalue, padj = MgPv$padj, comparison = "MgPv", log2FoldChange= MgPv$log2FoldChange)
PVSA_df <- data.frame(Gene = rownames(PvSa), pvalue = PvSa$pvalue, padj = PvSa$padj, comparison = "PvSa",log2FoldChange= PvSa$log2FoldChange)
sav_allcomp <- rbind(MGSA_df,MGPV_df, PVSA_df)
```


```{r}

sav_allcomp$logP <- -log10(sav_allcomp$pvalue) #calculating metric == -log10(pvalue)
sav_allcomp <-  sav_allcomp[which(abs(sav_allcomp$logP) != 0),] #filtering out p-values 
sav_allcomp$metric <- sav_allcomp$logP * abs(sav_allcomp$log2FoldChange)
sav_gsea_allcomp <- sav_allcomp[,c("Gene","metric","comparison")]

##filtering out big dataset -- creating data frames for each comparison 
gsea_MgSa_df<- sav_gsea_allcomp %>% filter(comparison == "MgSa") %>% dplyr :: select(-comparison) 
gsea_MgPv_df <- sav_gsea_allcomp %>% filter(comparison == "MgPv") %>% dplyr :: select(-comparison) 
gsea_PvSa_df <- sav_gsea_allcomp %>% filter(comparison == "PvSa") %>% dplyr :: select(-comparison) 
head(gsea_MgSa_df)
#creating stats and pathways for gsea
  #MgSa
gseaDat_MgSa <- filter(gsea_MgSa_df, !is.na(Gene))
ranks_MgSa <- gsea_MgSa_df$metric
names(ranks_MgSa) <- gseaDat_MgSa$Gene
ranks_MgSa <- sort(ranks_MgSa)
head(ranks_MgSa)
  #MgPv
gseaDat_MgPv <- filter(gsea_MgPv_df, !is.na(Gene))
ranks_MgPv <- gsea_MgPv_df$metric
names(ranks_MgPv) <- gseaDat_MgPv$Gene
ranks_MgPv <- sort(ranks_MgPv)
#PvSa
gseaDat_PvSa <- filter(gsea_PvSa_df, !is.na(Gene))
ranks_PvSa <- gsea_PvSa_df$metric
names(ranks_PvSa) <- gseaDat_PvSa$Gene
ranks_PvSa <- sort(ranks_PvSa)

```
Here, we can see the output of a result table, with values indicating DE of genes based on pvalues, logfold2, padj, etc. 
In order to start the GSEA pipeline, we must create ranks of the DE genes based on a metric of DE. Here, we chose the metric -log10(pvalue) * abs(logfold2)
This gives us the data table with the gene and metric, and then ranks, which is a vector of the gene name and corresponding metric. 

```{r, include = FALSE}
#GSEA -- MAKING DATA TABLES AND RUNNING FGSEA
  #Making metric rank for 0-12h comparison

#creating metric used for ranking DE of genes for TB schulz 0-12h timepoint contrast
#resSig$fcsign <- sign(resSig$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig <-  resSig[which(abs(resSig$fcsign) != 0),] #filtering out foldchanges = 0
resSig$logP = -log10(resSig$pvalue) 
resSig <-  resSig[which(abs(resSig$logP) != 0),] 
resSig$metric= resSig$logP * abs(resSig$log2FoldChange)#calculating metric = log10(pvalue)/fcsign
resSig$Gene <- rownames(resSig) #creating column Gene for dataframe
gsea_schulz <-resSig[,c("Gene", "metric")]

#Creating data frame from gsea_schulz for gsea
gsea_schulz_df <- data.frame(gsea_schulz)
rownames(gsea_schulz_df) <- NULL
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != Inf),]
gsea_schulz_df[1:10,] 
#creating stats and pathways for gsea
gseaDat_schulz <- filter(gsea_schulz_df, !is.na(Gene))
ranks <- gsea_schulz_df$metric
names(ranks) <- gseaDat_schulz$Gene
ranks <- sort(ranks)
head(ranks)

#####FOR LOG POS FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.pos$fcsign <- sign(resSig_log.pos$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.pos$logP = -log10(resSig_log.pos$pvalue) 
resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$logP) != 0),] 
resSig_log.pos$metric= resSig_log.pos$logP * abs(resSig_log.pos$log2FoldChange) #metric = -log10(pvalue) *abs(log2FoldChange)
resSig_log.pos$Gene <- rownames(resSig_log.pos) #creating column Gene for dataframe
gsea_schulz_log.pos <-resSig_log.pos[,c("Gene", "metric")]
 
  #creating data frame
gsea_schulz_df_log.pos <- data.frame(gsea_schulz_log.pos)
rownames(gsea_schulz_df_log.pos) <- NULL
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != Inf),]
gsea_schulz_df_log.pos[1:10,]

  #creating ranks for fgsea
gseaDat_schulz_log.pos <- filter(gsea_schulz_df_log.pos, !is.na(Gene))
ranks_log.pos <- gsea_schulz_df_log.pos$metric
names(ranks_log.pos) <- gseaDat_schulz_log.pos$Gene
ranks_log.pos <- sort(ranks_log.pos)
head(ranks_log.pos)
#####FOR LOG NEG FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.neg$fcsign <- sign(resSig_log.neg$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.neg$logP <-  -log10(resSig_log.neg$pvalue)
resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$logP) != 0),] 
resSig_log.neg$metric <-  resSig_log.neg$logP * abs(resSig_log.neg$log2FoldChange) #calculating metric = log10(pvalue) 
resSig_log.neg$Gene <- rownames(resSig_log.neg) #creating column Gene for dataframe
gsea_schulz_log.neg <-resSig_log.neg[,c("Gene", "metric")]

  #creating data frame
gsea_schulz_df_log.neg <- data.frame(gsea_schulz_log.neg)
rownames(gsea_schulz_df_log.neg) <- NULL
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != -Inf),] #removing metric   where = -Inf
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != Inf),]
gsea_schulz_df_log.neg[1:10,]
  #creating ranks for fgsea
gseaDat_schulz_log.neg <- filter(gsea_schulz_df_log.neg, !is.na(Gene))
ranks_log.neg <- gsea_schulz_df_log.neg$metric
names(ranks_log.neg) <- gseaDat_schulz_log.neg$Gene
ranks_log.neg <- sort(ranks_log.neg)
head(ranks_log.neg)

```



