---
title: "Analysis of Trypanosma Brucei RNA-Seq data"
author: "Lian Morales, Annie Cohen, Ethan Ashby"
date: "7/22/2019"
output: 
  pdf_document:
    latex_engine: xelatex
---

```{r, include=FALSE}
knitr::opts_chunk$set(cache = TRUE,warning = FALSE)

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
 
#Data Manipulation
library("dplyr")
library("tidyr")
library(readr)
library(devtools)
library("vsn")
library("hexbin")
library("tidyverse")
library(stringr)
library("Hmisc")
library(factoextra)

#clustering
library(jtools)
library(Mfuzz)
library(tcltk2) 
library(tkWidgets)

#DEG tools 
library("DESeq2")
library(cluster)
library("mclust")
library(ImpulseDE2)
library(maSigPro)
library(edgeR)

#for visualzation
library(VennDiagram)
library(ggplot2)
library("corrplot")

#for GSEA
library(doParallel)
library(Biobase)
library(biomaRt)
library(fgsea)
library(BiocParallel)
#tinytex::install_tinytex()
```

# Table of Contents  
1. Background  
\indent 1.1 Abstract  
\indent 1.2 Goals  
2. Methods  
\indent 2.1 Normalization  
\indent 2.2 Differential Expression Analysis  
3. Clustering  
4. Comparing Data  
\indent 4.1 Savage Data  
\indent 4.2 Savage Methods  
5. Gene Ontology Analysis     
\indent 5.1 Schulz GO  
\indent 5.2 Savage GO  
6.Gene Set Enrichment Analysis  
\indent 6.1 Clusters  
\indent 6.2 Savage  
7. Conclusion 
8. Acknowledgements  
9. References  

# 1. Background   

# 1.1 Abstract   
West African Sleeping Sickness is a deadly disease contracted by the bite of an infected Tsetse fly carrying the protozoan parasite *Trypanosoma Brucei*. This sickness is fatal in mammals and humans, as parasites proliferate in lymphatic, blood, nervous systems, and eventually the brain. Symptoms include disrupted sleep, behavioral changes,neurological damage, and death if left untreated. Due to the limited studies of this illness and harmful drug treatments, motivation to understand the complexity and nature of *Trypanosoma Brucei* become pertinent to world wide health and safety. 

Trypanosome surface proteins can directly interact with the host environment, allowing parasites to effectively establish and maintain infections(Savage 2015). During its infectious cycle, the parasite maintains several life stages throughout changing environments of insect and mammal. When living in the fly, the parasite's surface is covered with an invariant procylin, or proteins developed in the surface coating of *Trypanosoma brucei* in the Procyclic form(PF). However, upon living in the mammal, the parasite resides extracellularly in the bloodstream and becomes densely covered with highly immunogenic Variant Surface Glycoprotein (VSG). In this bloodstream form (BF), the parasite can vary its outer surface using approximately 2,500 distinct VSG genes. As a result, *Trypanosoma brucei* can evade human/mammal antibody immune response and remain virulent by constantly interchanging VSG genes.

For BF in mammals, the role of histone acetyl-lysine recognizing bromodomain proteins, have shown control of stem cell fate, leading to the hypothesis that bromodomain proteins may maintain the BF cell fate in trypanosomes. Histone lysine acetylation is central to epigenetic control of gene transcription. Thus, bromodomain inhibition disrupts two major BF specific immune evasion mechanisms that trypanosomes harness to evade mammalian antibody immune response. Of these functions, monoallelic expression of VSGs are disrupted, and rapid internalization of antibodies bound to VSGs on the surface of the trypanosome is blocked. Through these results, bromodomain inhibition in BF trypanosomes reveals changes in the transcriptome similar to PF trypanosomes. Importantly, bromodomain inhibition leads to a decrease in virulence in a mouse model of infection, establishing these proteins as potential therapeutic drug targets for trypanosomiasis.

This summer 2019, we looked at the result of research studying the effects of bromodomain inhibition in PF trypanosomes. Building off of past research, and understanding bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, we measured gene expression in WT PF and bromodomain-inhibited PF over 2 week time course, Determined differentially expressed genes (DEGs) between these two conditions, and finally help predict the effect of bromodomain inhibition on gene expression in insect form through data analysis.

# 1.2 Goals   

Building off of past research, and understanding bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, what is the result of inhibiting bromodomain in PF trypanosome? 

# 2. Methods  
To begin the analysis of Schulz data, we must understand the experiment's variables, conditions, and hypothesis. Schulz's data is a time course experiment with 10 samples with three repetitions, excluding sample time point at 3 hours -- three hours repetition 1 was removed because it was an outlier.  The data was then sent to be processed by RNA-seq, which is a way to measure gene expression in an organism.Also commonly known as High Throughput Sequencing, this process uses next-generation sequencing to reveal the presence and quantity of RNA in a biological sample at a given moment. The RNA is extracted and RNA reads (sequences of A, G, C, and U) are aligned to the organism's genome. The higher the number of reads, or inferred sequence of base pairs (or base pair probabilities) corresponding to all or part of a single DNA fragment, mapped to a certain gene the more that gene is expressed. 

# 2.1 Normalization   
In order to analyze raw read counts, we must normalize them to account for sequencing depth. Depth is commonly a term used for genome or exome sequencing and represents the number of reads covering each position(column sum). In RNA-seq, coverage pattern is very uneven due to differences in expression, so one must account for unequal samples through normalization. To obtain accurate results, we normalization methods. In order to ascertain the best normalization method for out data, our first step was comparing Differential Expression tools edgeR and DESeq2. 

# DESeq2  
DESeq normalizes raw count data using the algorithm Relative Log Expression(RLE). It first takes the geometric mean of all sample values, or the raw counts for each gene in a particular sample. This creates the reference sample of the data set. Then, DESeq2 takes the median of the number of observed reads in condition k and replicate r  and divides this value by the reference sample. As the algorithm completes this for all genes, the resulting vector is the ‘size factor’ of the particular sample. Size factors represent how deeply the sample is sequenced, and the ratio of the size factors of two different samples is an approximation of the ratio of their sequencing depths. 

# edgeR  
edgeR normalizes raw counts using Trimmed Mean Method(TMM). TMM first prenomalizes by library size, by dividing the observed number of reads for gene g in condition k and replicate r by the total number of reads for condition k and replicate r. For TMM, the arbitrary reference sample is condition and replicate 1, however one can specify what reference sample to use.  
For TMM, it takes the set of not trimmed genes with valid fold change and the absolute expression levels (cf. Robinson and Oshlack, 2010) and uses this value to calculate the relative scaling factor. Additionally, TMM scales this factor by multiplying it to one, thus giving a vector of normalization factor. These normalization factors are used as offset parameters in the statistical model for differential gene expression analysis. 


The result of this comparison was that DESeq2 and edgeR gave very similar results, with a small amount of different DEGS. As a result, our choice between DESeq2 and edgeR was more arbitrary, as DESeq2’s algorithm was preferable to fast run time and simple easy input. However, to understand the main differences and similarities between these two specific methods, comparing DESeq2 size factors and edgeR normalization factors and creating a VennDiagram of DEG’s identified by each method allowed for a clearer understanding of each algorithm, as well as our data. 

```{r,cache=TRUE}
TBcounts <- read.table("18-5-23_Proc_ibet_TC_for_deseq.txt",header = TRUE) %>% dplyr ::select(-ib_3h_1) 
TBcounts <- TBcounts %>% dplyr :: distinct(gene, .keep_all = TRUE) 
#NORMALIZATION BY DESEQ2
rownames(TBcounts) <- TBcounts$gene #renames the gene row
TBcounts <- TBcounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
#creating new data frame for DESeq to analyze
tb_new <- data.frame(rownames = colnames(TBcounts),
                     reps = as.factor(c(1,2,3,1,2,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3)),
                    stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3))))
rownames(tb_new) <- tb_new$rownames
tb_new <- tb_new %>% dplyr ::select(-rownames)

```
 As you can see in the code above, the breakdown of our data involves separating the repetitions of the samples and times, or stages of the experiment. In the first line, we see that the treated sample 1 at 3 hours(ib_3h_1) is not included in our data analysis. This is because it is an outlier determined by Professor Schulz. 



# DESeq2 Normalization  

The first step for DESeq2 normalization involves creating a count matrix with degin reps + stage. Then, the function DESeq() of that matrix calculates the normalized counts as well as size factors. 
```{r, cache = TRUE}
##dds stands for the DESeq Data Set
ddsFullCountTable <- DESeqDataSetFromMatrix(countData = TBcounts,
                                            colData = tb_new, 
                                            design = ~ reps + stage)

TBcounts_dds <- DESeq(ddsFullCountTable)

#calculating norm counts
##DESeq2 :: allows to specify where this fcn comes from
norm_counts <- as.data.frame(counts(TBcounts_dds, normalized = TRUE)) %>%
  mutate(gene = rownames(TBcounts))
 
 
```
#  edgeR Normalization  

Similar to DESeq, we will need to create a new data frame detailing the samples, time, and repetitions. For this data set, stage = treatment and time, and rep = sample repetition. 

For edgeR, the function calcNormFactors() calculates normalized counts, and return library size of each sample, normalization factor, and group of each sample. In this example, variable 'tb_normfact' represents the normalization factors that calcNormFactors() of Schulz raw counts outputs. 
  

```{r}
#ECHO 
#DE WITH EDGER
#for easy data manipulation, creating DGE list from TBcounts and data table tb_new(with columns stage, reps)
tbcounts_dge <- DGEList(counts = TBcounts, norm.factors = rep(1,ncol(TBcounts)), group = tb_new$stage, remove.zeros = TRUE)

#creating design matrix of reps and stage
design <- model.matrix(~ tb_new$reps + tb_new$stage)
rownames(design) <- colnames(TBcounts)

#FILTER data -- getting rid of non expressed genes
keep <- filterByExpr(tbcounts_dge)
table(keep)
tbcounts_dge <- tbcounts_dge[keep, ,keep.lib.sizes = FALSE]
 
#NORMALIZE DATA - USING CALCNORMFACTORS()

tb_norm <- calcNormFactors(tbcounts_dge, method = "TMM", refColumn = NULL)
#separating the counts and samples
tbcounts <- tb_norm$counts
tb_normfact <- tb_norm$samples$norm.factors
 
#getting the norm counts
tb_normCounts <- cpm(tbcounts_dge)
```
The first comparison between methods edgeR and DESeq2 was normalization and size factors. In order to compare DESeq2's size factor and edgeR's normalization factor, we must multiply the normalization factor by  the library size for each sample.  In edgeR, the equivalent to the size factor is actually the effective library size. That is, the normalization factor captures sample-specific bias beyond differences in library size. In this graph, one can see that the multiplied normalization factors almost equal DESeq2's size factors. 

```{r, echo = FALSE}
tb_norm_sf <- data.frame(tb_normfact* colSums(TBcounts))
colnames(tb_norm_sf) <- "TMM.size.fact"
size.DESeq2 <- TBcounts_dds$sizeFactor 
size.edgeR <- tb_norm_sf$TMM.size.fact
plot(size.DESeq2, size.edgeR, main = "Size Factor DESeq & edgeR")
 
```

The second comparison between algorithms DESeq2 and edgeR were the amount of differentially expressed genes at comparison time points 0-12 hours. In edgeR, the FDR was filtered with 0.01, and for edgeR, the padj was filtered at 0.01. This VennDiagram below shows not only the similarity between the algorithms, but also the ability for our team to choose between DESeq2 and edgeR with confidence. 

```{r, echo = FALSE}
#COMPARING - DE ANALYSIS - FOR GSEA

#comparing stages noo_ib and ib_12h --- the stage of non inhibited bromodomain at time 0 to inhibited bromodomain at time point 12 hours
TBcountsRes <- results( TBcounts_dds ,contrast = c("stage","ib_12h", "noo_ib"))
#resSig_012 stands for the results of the significant genes expressed in comparison of noo_ib and ib_12h
resSig_012 <- TBcountsRes[ which(TBcountsRes$padj < 0.01 ), ]
```

```{r}
#ECHO
#DE ANALYSIS - EDGER - getting the DE genes

#comparing 6h to noo, under hypothesis that 6h-noo = 0 
stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3)))
design <- model.matrix(~0 + stage)
rownames(design) <- colnames(tb_norm)
con <- makeContrasts(stageib_6h-stagenoo_ib , levels= design)
est_disp <- estimateDisp(tb_norm, design, robust=TRUE)
fit <- glmQLFit(est_disp, design, robust=TRUE)
qlf <- glmQLFTest(fit, contrast = con) 
summary(decideTests(qlf)) #looks at the number of up and down regulated genes
topTags(qlf) #looking at the top de genes

#now want to look at all de genes from toptags
out <- topTags(qlf, n=Inf, adjust.method="BH")  
keep <- out$table$FDR <= 0.01 #filtering genes with FDR 0.01
de_table <- out[keep,] #de_table for the table of DE genes

```


```{r,echo = FALSE}
#making venn diagram
area1 <- length(rownames(resSig_012))    
area2 <- length(rownames(de_table))  
cross <- length(intersect(rownames(resSig_012), rownames(de_table)))
 
grid.newpage()
draw.pairwise.venn(area1= area1, area2 = area2, cross.area = cross, category = c("DESeq","edgeR"))
```

# 2.2 Differential Expression Analysis   
  Based on the large amount of genes in Schulz’s data, using more than one method to identify DEGs must be used to provide accurate results for our analysis. Due to the large amount of differential expression algorithms, the choice were limited down to 3 - DESeq2, ImpulseDE2, and maSigPro.
  
  Differential expression analysis algorithms for time course datasets can be divided into methods that treat time points independently and methods that explicitly model the dependence between time points. Methods that utilize the former approach are mostly based on generalized linear models, with the sampling time point as a categorical variable that is then used as a predictor for the expression level (Fischer *et.al* 2018). These methods include software packages DESeq2 and edgeR. For our analysis, as previously discussed, we will use DESeq2 for the remainder of Normalization and Differential Expression analysis. 
  
  The methods that use the latter approach constrain the sequence of measured expression levels to a continuous function of time, thus capturing the dependence of expression levels between time points. Such continuous dependence on time has previously been captured with non-linear models based on a spline basis transform of the time coordinate such as ImpulseDE2. ImpulseDE2 models the gene-wise expression trajectories over time with a descriptive single-pulse (impulse) function and employs a noise model specific to count data from multiple batches and combines it with a likelihood ratio test, leading to much faster and more accurate inference (Fischer *et.al* 2018). Due to ImpulseDE2 popularity and accuracy cited in recent reports(Spies D. *et.al* 2017), we chose to use this model to identify Schulz DEGs. 
  
  Along with ImpulseDE2 and DESeq2, we used Differential Expression package maSigPro. maSigPro follows a two step regression strategy to find genes with significant temporal expression changes and significant differences between experimental groups. The method defines a general regression model for the data where the experimental groups are identified by dummy variables. The procedure first adjusts this global model by the least-squared technique to identify differentially expressed genes and selects significant genes applying false discovery rate control procedures. Secondly, stepwise regression is applied as a variable selection strategy to study differences between experimental groups and to find statistically significant different profiles. The coefficients obtained in this second regression model will be useful to cluster together significant genes with similar expression patterns and to visualize the results (Conesa *et.al* 2017).

 Because we are more interested in earlier time points of Schulz's time course experiment due to the increased gene expression shown from 0-12 hours, our DEG analysis will compare time points 0 & 12 hours. 
 
# DESeq2   
Beginning with DESeq2, the results for a comparison of any two levels of a variable can be calculated using the contrast argument to the results function. The function requires three values: the name of the variable, the name of the level in the numerator, and the name of the level in the denominator.  
Here we extract results for the log2 of the fold change of treated 12h and untreated 0h, ib_12h / noo_ib. 


```{r}
#COMPARING - DE ANALYSIS - FOR GSEA

#comparing stages noo_ib and ib_12h --- the stage of non inhibited bromodomain at time 0 to inhibited bromodomain at time point 12 hours
TBcountsRes <- results( TBcounts_dds ,contrast = c("stage","ib_12h", "noo_ib"))
 
```

In order to correct for multiple testing, DESeq2 uses Benjamini-Hochberg (BH) adjustment, which is a method that decreases the false discovery rate(FDR). Due to the fact that small p-values often happen by chance, the tool helps remove the possibility of falsely rejecting the try null hypothesis. For example, if one had a very low p-value(<.05), it would mean that there is only a 5% chance that you would get your observed result granted the null was true. Thus, with a p value of 0.05, it is highly unlikely that your null is incorrect. So, in order to eliminate the possibility of FDR, the BH adjustment adjusts for the probability of a FDR. For example, if one called all genes that are significant are those with a p value less than or equal to a gene’s p value threshold, the BH method calculates the fraction of false positives among those genes. These values, called the BH-adjusted p values, are given in the column padj of the results object.

For our data, we considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Schulz dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  

```{r}
#resSig_012 stands for the results of the significant genes expressed in comparison of noo_ib and ib_12h
resSig_012 <- TBcountsRes[ which(TBcountsRes$padj < 0.01 ), ]
resSig_012 <- resSig_012[complete.cases(resSig_012),]
resSig_012$gene <- rownames(resSig_012)
resSig_012$fcsign <- sign(resSig_012$log2FoldChange) #fcsign stands for the log2foldchange sign
head(resSig_012)

#creating negative and positive logfold change data sets
resSig_log.pos <- resSig_012[which(resSig_012$fcsign != -1),]
resSig_log.neg <- resSig_012[which(resSig_012$fcsign == -1),]
```

For further analysis, we group the positive, and negative logfold2 changes. This is because down regulated genes have negative logfold2change and upregulated genes have a positive logfold2change. Therefore, by splitting up the data into up and down regulated genes, we can succesfully, and more clearly identify biological pathways for future analysis, such as Gene Ontology and Gene Set Enrichment Analysis.

# ImpulseDE2  
For ImpulseDE2, we must create an integer count matrix (TBcounts_matrix) and a meta data table (impulse_design) to input directly to the ImpulseDE2 wrapper (runImpulseDE2). 

```{r, cache= TRUE,include =  FALSE}
Time <- c(rep(0,3), rep(3,2), rep(6,3,), rep(12,3), rep(24,3), rep(48,3), rep(72,3), rep(168,3), rep(240,3), rep(336,3))

impulse_design <- data.frame(Sample = colnames(TBcounts), Condition = rep("case", 29), Time = Time)
#edit count matrix and filter s.t. average count is double digits
TBcounts_matrix <- as.matrix(TBcounts)

#may take awhile to run ImpulseDE2 (~20 mins), using q-value threshold of 0.01
tryp_impulse <- ImpulseDE2 :: runImpulseDE2(TBcounts_matrix, impulse_design, boolCaseCtrl = FALSE, vecConfounders = NULL, scaNProc = 8, scaQThres = 0.01)
 
```

# maSigPro   
 
```{r,cache=TRUE,include =  FALSE}
#################################################################################################################################
#Serial expression tool: NEXT maSigPro
#################################################################################################################################

#set up design
time <-c(rep(0,3),rep(3,2),rep(6,3),rep(12,3),rep(24,3),rep(48,3),rep(72,3),rep(168,3),rep(240,3),rep(336,3))
replicates<-c(1:3, 1:2, rep(1:3, 8))
group<-rep(1,29)
ss.edesign<-cbind(time, replicates, group)
rownames(ss.edesign)<-colnames(TBcounts)

#Run maSigPro on DESeq2 normalized counts, theta=1000...
tccount1<-as.data.frame(counts(TBcounts_dds, normalized=TRUE))
ss.edesign<-as.data.frame(ss.edesign)
newdesign<-make.design.matrix(ss.edesign, degree=9, time.col=1, repl.col=2, group.cols=3)

#run maSigPro w/ Q=0.01
results<-maSigPro(tccount1, ss.edesign, vars="all", Q=0.01)
maSigProGenes<-results$p.vector[results$p.vector<0.01,]
maSigProGenes<-names(maSigProGenes)

```

# Creating Venn Diagram  

Completing each Differential Experssion algorithm, we found that there are 716 DEGs identified by DESeq2, maSigPro, and ImpulseDE2. Because of the large amount of DEG found for each method, we will take the intersection of each tool as our list of DEGs for Schulz 0-12 hour comparsion to not only get the most accurate DEGs, but also cut down on the amount used for analysis.
```{r, echo = FALSE}
#Creating VennDiagram 

#Impluse and DESeq2
area <- length(intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)))
grid.newpage()
draw.pairwise.venn(area1= length(rownames(resSig_012)), area2 = length(tryp_impulse$vecDEGenes), cross.area = area, category = c("DESeq2 (0h-12h comparison)","ImpulseDE2 (serial analysis)"),lty = rep("blank",2),fill = c("light blue", "light green"))


#three way comparison - Impulse, maSigPro, DESeq2
area1 <- length(intersect(rownames(resSig_012),maSigProGenes))
area2<- length(intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)))
area3 <- length(intersect(maSigProGenes, tryp_impulse$vecDEGenes))
area123<-length(intersect(intersect(maSigProGenes, tryp_impulse$vecDEGenes), intersect(maSigProGenes,rownames(resSig_012))))
grid.newpage()
g = draw.triple.venn(area1= length(rownames(resSig_012)), area2 = length(maSigProGenes), area3= length(tryp_impulse$vecDEGenes), n12=area1, n23=area3, n13=area2, n123=area123, category = c("DESeq2","maSigPro", "ImpulseDE2"), lty = rep("blank",3), fill = c("light blue", "light green", "pink"), euler.d=FALSE,  scaled = FALSE,ind = FALSE,cex=rep(1.5, 7), cat.cex=rep(1.5,3), cat.dist=c(0,0,0), cat.fontface = "bold")  
require(gridExtra)
grid.arrange(gTree(children=g), top="Schulz T.brucei Three Way Comparison of Differentally Expressed Genes")

```


# Creating DEG list from three way intersection - Impulse, maSigPro, DESeq2   
Here, we will be saving our DE genes from maSigPro, impulse, and DESeq2.
```{r}

###################################################################################################################################
#Generate Final DEGList
###################################################################################################################################

tryp_DEGs <-unique(c(intersect(rownames(resSig_012),maSigProGenes), intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)), intersect(maSigProGenes, tryp_impulse$vecDEGenes)))
write.csv(tryp_DEGs, "tryp_DEGs.csv")

```
# 3 Clustering  

In order to answer the biological questions of our data, we need to take statistical steps to gather information in order to prove or answer the hypothesis at hand. Clustering our data is an example of this method. Here we are taking the fuzzy cluster GO analysis results, and preparing them for GSEA pipeline. 
(cluster code here)
The two methods that we chose to cluster our data were Partitioning Around Medoids(PAM), and Fuzzy clustering. Choices for these are due to the efficiency of both algorithms, and time constraints of finding and running other methods. (Impulse)

# 3.1 PAM   
PAM clustering, or *k-medoids* is a clustering algorithm similar to the *k-means* algorithm. Both k-means and k-medoids algorithms are partitional, or break the dataset into groups, and both attempt to minimize the distance between points labeled to be in a cluster, and a point designated as the center of that cluster. K-medoids uses data points as centers, and can be used with arbitrary distances. 
K-medoids clusters the data set of *n* objects into *k* clusters, with the number of 6 *k* clusters for our data set.  
 

```{r,include =  FALSE}

ind <- match(norm_counts$gene,resSig_012$gene)
 
norm_counts$sig <- resSig_012$gene[ind]

norm_counts$padj <- resSig_012$padj[ind]

norm_counts$pval <- resSig_012$pvalue[ind]

norm_counts$log2FoldChange <- resSig_012$log2FoldChange[ind]

norm_counts <- norm_counts %>%
  filter(!is.na(sig))

pos_DEGs_metrics <- norm_counts %>%
  filter(log2FoldChange > 0)
rownames(pos_DEGs_metrics) <- pos_DEGs_metrics$gene
pos_DEGs <- pos_DEGs_metrics %>%
  dplyr :: select(-c(gene, sig, padj,pval,log2FoldChange))

neg_DEGs_metrics <- norm_counts %>%
  filter(log2FoldChange < 0)
rownames(neg_DEGs_metrics) <- neg_DEGs_metrics$gene
neg_DEGs <- neg_DEGs_metrics %>%
  dplyr :: select(-c(gene, sig, padj,pval,log2FoldChange))

rownames(norm_counts) <- norm_counts$gene
tb_DEGS <- norm_counts %>%
  dplyr :: select(-c(gene, sig, padj, pval, log2FoldChange))
 
#norm_counts$gene <- rownames(norm_counts_cluster)
#norm_counts <- norm_counts %>% dplyr :: select(-c(sig, padj, pval, log2FoldChange))

```


```{r, cache=TRUE,include =  FALSE}
k = 6

dissimilarity_matrix <- 1 - cor(t(tb_DEGS[1:20,]),method = "pearson")

DESeq_clusters <- cluster::pam(x = dissimilarity_matrix, k = k, pamonce = 5)

DESeq_clusters_df <- data.frame("cluster" = DESeq_clusters$clustering, "gene" = names(DESeq_clusters$clustering))

DESeq_medoids_df <- data.frame("medoids" = (DESeq_clusters$medoids))

 

DESeq_cluster_df <- left_join(DESeq_clusters_df,norm_counts, by = "gene")

DESeq_cluster_counts <- DESeq_cluster_df %>% dplyr::select(-c(padj,pval,log2FoldChange,sig))

DESeq_cluster_metric <- DESeq_cluster_df %>%
  mutate("stat" = (-log10(DESeq_cluster_df$padj))) %>%
  dplyr:: select(gene, stat, cluster) %>%
  filter(stat != "-Inf") %>%
  filter(stat != "Inf")

DESeq_Pathways_list <-DESeq_cluster_metric$stat

names(DESeq_Pathways_list) <- DESeq_cluster_metric$gene

DESeq_cluster_list <- c()
DESeq_cluster_list <- split(DESeq_cluster_metric, DESeq_cluster_df$cluster)


DESeq_clusters <- c()
for (i in 1:k) {
  DESeq_clusters[[i]] <- DESeq_cluster_list[[i]]$stat
  names(DESeq_clusters[[i]]) <- DESeq_cluster_list[[i]]$gene
}

counts_gath_norm <- DESeq_cluster_counts %>%
  gather(-c(gene,cluster), key="sample", value = "rawcount") %>%
  mutate(sample2 = sample) %>%
  separate(sample2, c("treat", "time", "rep"), "_") %>%
  mutate(time = ifelse(time == "ib", 0, 
                        ifelse(time == "3h", 3, 
                               ifelse(time == "6h", 6,
                                      ifelse(time == "12h", 12,
                                             ifelse(time == "24h", 24,
                                                    ifelse(time == "48h", 48,
                                                           ifelse(time == "3d", 72,
                                                                  ifelse(time == "7d", 168,
                                                                         ifelse(time == "10d", 240, 336))))))))))
counts_gath_norm

counts_sum_norm <- counts_gath_norm %>%
  group_by(gene, treat, time, cluster) %>%
  dplyr::summarise(avecount = mean(rawcount))
counts_sum_norm_head <- counts_sum_norm %>%
  filter(time <= 12)

cluster_lists <- c()
cluster_lists[1] <- counts_sum_norm %>% filter(cluster == 1)
list_1 <- paste(cluster_lists[[1]], sep = "")
write.csv(list_1, file = "tryp_cluster_1.csv")

cluster_lists[2] <- counts_sum_norm %>% filter(cluster == 2)
list_2 <- paste(cluster_lists[[2]], sep = "")
write.csv(list_2, file = "tryp_cluster_2.csv")

cluster_lists[3] <- counts_sum_norm %>% filter(cluster == 3)
list_3 <- paste(cluster_lists[[3]], sep = "")
write.csv(list_3, file = "tryp_cluster_3.csv")

cluster_lists[4] <- counts_sum_norm %>% filter(cluster == 4)
list_4 <- paste(cluster_lists[[4]], sep = "")
write.csv(list_4, file = "tryp_cluster_4.csv")

cluster_lists[5] <- counts_sum_norm %>% filter(cluster == 5)
list_5 <- paste(cluster_lists[[5]], sep = "")
write.csv(list_5, file = "tryp_cluster_5.csv")

cluster_lists[6] <- counts_sum_norm %>% filter(cluster == 6)
list_6 <- paste(cluster_lists[[6]], sep = "")
write.csv(list_6, file = "tryp_cluster_6.csv")
 
```

# 3.2 Fuzzy Clustering  

Fuzzy clustering (also referred to as soft clustering or soft k-means) is a form of clustering in which each data point can belong to more than one cluster. Here, for Schulz's data, we will use the package Mfuzz to cluster the genes. The algorithm of fuzzy clustering assigns membership grades to each of the data points (tags). These membership grades indicate the degree to which data points belong to each cluster. Thus, points on the edge of a cluster, with lower membership grades, may be in the cluster to a lesser degree than points in the center of cluster.

Although we already used PAM as a method of clustering, because there are numerous methods to cluster genes we chose to test another moethod(soft clustering on this data set). Reasons for choosing fuzzy clustering and package Mfuzz is that the regulation of genes is generally not in an ‘on-off’, but gradual manner. Soft clustering appears a good candidate for modeling this by assiging a gene i gradual degrees of membership μij to a cluster j. The membership values can vary continuously between zero and one. This feature enables soft clustering to provide more information about the structure of gene expression data.


```{r, echo = FALSE}
####################################################################################################
#Fuzzy clustering of DEGs (2+ methods)
####################################################################################################

 
#DEGcounts
DEGcounts<-as.matrix(TBcounts[rownames(TBcounts) %in% rownames(tb_DEGS),])
 
###Too many clusters in all TPs. Let's only look at first 24 hours
cluster_data<-matrix(ncol=5,nrow=dim(DEGcounts)[1])
for (i in 1:dim(DEGcounts)[1]){
  cluster_data[i,]<-c(mean(DEGcounts[i, 1:3]), mean(DEGcounts[i, 4:5]), mean(DEGcounts[i, 6:8]), mean(DEGcounts[i, 9:11]), mean(DEGcounts[i, 12:14]))}
rownames(cluster_data)<-rownames(DEGcounts)
colnames(cluster_data)<-c(0,3,6,12,24)
Set<-ExpressionSet(cluster_data)
Set.s<- Mfuzz::standardise(Set)
cl<-mfuzz(Set.s, c=6, m=mestimate(Set.s))
scaleddata<-t(scale(t(cluster_data)))
#Gap stat Kmeans to estimate number of clusters... may take a few mins
gap <- clusGap(scaleddata, kmeans, 20, B = 100, verbose = interactive())
plot(gap, main = "Gap statistic")
abline(v=which.max(gap$Tab[,3]), lty = 2)

#plot clusters
pdf("tryp_fuzzy_clusters.pdf", onefile = TRUE)
mfuzz.plot(Set.s, cl, mfrow=c(2,3), time.labels = c(0,3,6,12,24), min.mem=0, new.window=FALSE)
dev.off()

cores<-acore(Set.s, cl, min.acore=0.8)

###Run GO Analysis on these clusters
write.csv(cores[[1]]$NAME, "Cluster1_of_6_Tryp.csv")
write.csv(cores[[2]]$NAME, "Cluster2_of_6_Tryp.csv")
write.csv(cores[[3]]$NAME, "Cluster3_of_6_Tryp.csv")
write.csv(cores[[4]]$NAME, "Cluster4_of_6_Tryp.csv")
write.csv(cores[[5]]$NAME, "Cluster2_of_6_Tryp.csv")
write.csv(cores[[6]]$NAME, "Cluster6_of_6_Tryp.csv")

```
In these clusters, we can see that we set the cluster number to 6, and that each cluster here has slight differences. However, moving forward in this analysis Ethan and I got different results on the clustering of typanosoma data. This is a great cause of worry, as there should really only be one result of this clustering algorithm. Therefore, more analysis will be done in this section. 

```{r,cache=TRUE,include =  FALSE}

####################################################################################################
#STRICTER DEG LIST: GENES ID'ED BY ALL 3
#RUN GO ANALYSIS in TriTrypDb for each of the cores (Cellular Component, Biological Process, & Mol Function)
####################################################################################################
set1<-intersect(rownames(resSig_012),maSigProGenes)
set2<-intersect(tryp_impulse$vecDEGenes,rownames(resSig_012))
small_DEGs<-unique(c(intersect(set1, set2)))

#Look at smaller subset (3-way intersection)
small_DEGcounts<-tccount1[match(small_DEGs, rownames(tccount1)),]
sdvec<-c()
for (i in 1:dim(small_DEGcounts)[1]){
  sdvec<-c(sdvec, sd(small_DEGcounts[i,]))}
small_DEGcounts<-small_DEGcounts[sdvec>0,]
small_DEGcounts<-small_DEGcounts+0.1
small_DEGcounts<-as.matrix(small_DEGcounts)
small_cluster_data<-matrix(ncol=5,nrow=dim(small_DEGcounts)[1])
for (i in 1:dim(small_DEGcounts)[1]){
  small_cluster_data[i,]<-c(mean(small_DEGcounts[i, 1:3]), mean(small_DEGcounts[i, 4:2]), mean(small_DEGcounts[i, 6:8]), mean(small_DEGcounts[i, 9:11]), mean(small_DEGcounts[i, 12:14]))}
rownames(small_cluster_data)<-rownames(small_DEGcounts)
colnames(small_cluster_data)<-c(0,3,6,12,24)
Set<-ExpressionSet(small_cluster_data)
Set.s<-standardise(Set)
small_cl<-mfuzz(Set.s, c=6, m=mestimate(Set.s))
small_scaleddata<-t(scale(t(small_cluster_data)))

gap_small <- clusGap(small_scaleddata, kmeans, 10, B = 100, verbose = interactive())
plot(gap_small, main = "Gap statistic for DEGs Identified by all 3 tools")
abline(v=which.max(gap$Tab[,3]), lty = 2)

pdf("tryp_fuzzy_clusters.pdf", onefile = TRUE)
```

```{r, echo = FALSE}
mfuzz.plot(Set.s, small_cl, mfrow=c(1,3), time.labels = c(0,3,6,12,24), min.mem=0, new.window=FALSE)
dev.off()
#extract alpha-cores of 0.72
cores<-acore(Set.s, cl, min.acore=0.3)
```


# 4. Comparing Data   

In order to answer Schulz's question of bromodomain inhibition impact on trypanosome PF, we must compare our results to Savage 2015 data, or Differentiating data, which includes trypanosoma DE genes gathered from environmental based experiments in the Tsetse fly. The results of Savage 2015 data details the biological change in T.brucei gene transcription based on environmental conditions. By comparing our DE genes to Savage environment based DE genes, we can come to conclusions about what happens in gene expression for bromodomain inhibited PF.
By comparing MG to SA, the resulting DE genes are those that best exemplify the gene expression change between BF and PF. These genes are very important in our understanding of the changes that Schulz samples undergo. For example, if there is a high amount of correlation between DE genes in MG to SA and 0h - 12h, we can hypothesize certain aspects of what happens in bromodomain inhibition in PF in relation to epitope changes. This might be a revert to the BF, or the bromodomain inhibited PF trypanosomes share similar like qualities of BF trypanosomes. 

Thus, by completing DESeq and future biological analysis on Savage data, we can come to a more concrete conclusion of bromodomain function in trypanosoma. 
 
Similar to analyzing our data, we must analyze 2015 Savage data, using the same pipeline: 
  1. Run raw read counts
  2. Filter/Quality Control
  3. Run Differential Gene Expression Analysis using DESEq2.
  
# 4.1 Savage Data  
First, we must read in our data table. Variable 'savagecounts' represents this data table of Savage raw read counts. 
Similar to our data, we must manipulate our savagecounts data table for DESeq2. 
```{r, include = FALSE}
#DESEQ ON SAVAGE DATA - THREE COMPARISON MGSA MGPV PVSA

savagecounts <- read.table("18-5-24_dedup_Savage_deseq_counts.txt", header = TRUE)

 
#Creating Data matrix 
rownames(savagecounts) <- savagecounts$gene #renames the gene row
savagecounts <- savagecounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
coldata <- data.frame(rownames = colnames(savagecounts),
                    reps = as.factor(c(1, 2, 3, 1, 2, 3 ,4,
                                     1, 2 ,3)), 
                    stage = as.factor(c(rep("MG",3),rep("PV",4), rep("SA",3))))

ddsFullCountTable <- DESeqDataSetFromMatrix(
   countData = savagecounts,
   colData = coldata,
   design = ~ reps + stage)
#DESeq2 getting DE genes
savagecounts_dds <- DESeq(ddsFullCountTable )

```  
 
 As you can see in the above chunk, savage data was run through the same pipeline, creating a new data frame for DESeq2 with variables reps, which are the repetition of the samples, and stage, which now represents the location of where the trypanosome was sampled: Migut, Proventriculus, Salivary gland.
 
# 4.2 Savage Methods  
Here we are completing DESEq results on Savage data. We have an adjusted p value (padj) filter of < 0.01, a log2foldchange > 1.5. 
The comparisons we completed are:
1. MgSa (Midgut and Salivary Gland)
$~$
2. MgPv (Migut and Proventriculus)
$~$
3. PvSa (Proventriculus and Salivary Gland)
$~$
  In the chunk below, we will comlete comparison MgSa. We will complete the same analysis on Schulz data on the comparisons MG/SA, MG/PV and PV/SA, but it will not be shown in the knitted document.
  
Here we extract results for the log2 of the fold change of MG and SA. 
 
```{r}
#Comparisons of all 
  #padj filter < 0.01
  #abs(log2fold) filter > 1.5
#MG and SA############################################################################
savageRes_MgSa <- results( savagecounts_dds ,contrast = c("stage",  "MG","SA"))
savageRes_MgSa
```
 
For Schulz data, we also considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Savage to compare to our dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  

Similar to filtering the padj, we want to filter the logfold2change. If a gene has a high absolute value log2foldchange, it means the gene is highly expressed. In order to cut down the amount of DE genes, filtering of this parameter will select only the higly expressed genes for our analysis of Savage data against our own. The cutoff logfold2 value 1.5 was arbitrarly chosen based on needing ~200-500 DE genes for further analysis. 

MgSa represents the filtered padj and log2foldchange DE genes. 
```{r}
resSig <- savageRes_MgSa[ which(savageRes_MgSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgSa <- resSig
head(MgSa) 
```
Here is the padj and logfold2 filtered results of the log2 of the fold change of MG and SA.
The rownames of this table are the DE genes calculated from the results function. Theses genes are important and we will use them for analysis later. 

We completed the same analysis on comparisons MG/PV and PV/SA (not shown) with same parameters and filtering. This code will not be included in the knitted file. 
```{r, echo = FALSE}
#MG and PV############################################################################
savageRes_MgPv <- results( savagecounts_dds ,contrast = c("stage",  "MG","PV"))
resSig <- savageRes_MgPv[ which(savageRes_MgPv$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgPv <- resSig

#PV and SA############################################################################
savageRes_PvSa <- results( savagecounts_dds ,contrast = c("stage",  "PV","SA"))
resSig <- savageRes_PvSa[ which(savageRes_PvSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
PvSa <- resSig

 
```


# 5. Gene Ontology analysis   
In order to assign biological meaning to our results, we must understand the biological background behind our DE genes. GO analysis, or Gene Ontology term enrichment, is a way to characterize genes through assigning them to cell, or organism specific pathways. More explicitly, the GO system of classification assigns these genes to a set of predefined pathways depending on their functional characteristics. For example, if a gene called FasR is categorized by the GO term 'receptor', it might be found to be involved in apoptosis and located on the plasma membrane. Thus, by being able to group our DE genes by biological function, we can come to a fuller conclusion of our data.

For GO on Schulz and savage data, we used a database https://tritrypdb.org/tritrypdb/, and completed GeneId search for our DE genes, which give additional information on the specific information on each gene. Then, after completing Geneid search, click on the tab "Analyze Results" and then you should see a option 'GO'. For our data, we included Cellular Component, Molecular Function, and Biological Process for GO enrichment. The downloaded tabs are in the folder labeled "GO_Terms"
 
https://en.wikipedia.org/wiki/Gene_Ontology_Term_Enrichment

# 5.1 Schulz GO  

For Schulz data, we used GO analysis on the PAM clusters, fuzzy clusters, and total DE gene list. As explained above, it was necccesary to include a deeper analysis on the clusters by providing biological tags on the genes.

CLusters: PAM and Fuzzy
Here, will use the saved file from PAM clustering code(gene names saved as "tryp_cluster_1.csv" and ect.) and from fuzzy code("Cluster1_of_6_Tryp.csv" and ect.) 
Then as descibed above, we will import the gene names to  https://tritrypdb.org/tritrypdb/ to create the GO components for each cluster.For fuzzy clusters, the GO tab is a data table of all clusters called "fuzzyclusters_GO.tab".
 
Here we are taking the fuzzy cluster GO analysis results, and preparing them for GSEA pipeline(which we will discuss int he nexrt section). 

First step is to read in all the fuzzy clusters. Then, we will separate them into respective clusters, sorting the clusters into Biological Process and so forth. We will need to make each clustered group into a list for GSEA. 
```{r}  
#Reading in huge file with all GO terms of clusters 
fuzzyClust <- read.table("fuzzyclusters_GO.tab") %>% dplyr :: select(Name, Result.gene.list, Cluster,Type)
fuzzyClust$Result.gene.list <- gsub(',',',',fuzzyClust$Result.gene.list,fixed=TRUE)
fuzzyClust$Result.gene.list <- strsplit(fuzzyClust$Result.gene.list, ",")

clust1_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 1)
clust1_bio_list <- as.list(clust1_bio)
names(clust1_bio_list$Result.gene.list) <- clust1_bio_list$Name
clust1_bio <- clust1_bio_list$Result.gene.list
clust1_bio$`microtubule-based movement`
```
We can see that in clust1_bio, the GO terms are labeled in the list as *microtubule-based movement* for example, and returns the list of genes from that specific cluster that are involved with that GO term. 

It is not included in the knitted file, but this process was completed for rest of the 6 fuzzy clusters and PAM clusters which used same method for GO. 

 
 
```{r, echo= FALSE, include =  FALSE}
#Fuzzy Cluster GO terms
#########CLUSTER 1######### 
#Cellular Component
clust1_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 1)
clust1_cell_list <- as.list(clust1_cell)
names(clust1_cell_list$Result.gene.list) <- clust1_cell_list$Name
clust1_cell <- clust1_cell_list$Result.gene.list
#Molecular Function
clust1_mol <- fuzzyClust %>% filter(Type == "Molecular Function",Cluster == 1)
clust1_mol_list <- as.list(clust1_mol)
names(clust1_mol_list$Result.gene.list) <- clust1_mol_list$Name
clust1_mol <- clust1_mol_list$Result.gene.list

#########CLUSTER 2######### 
#Biological Process
clust2_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 2)
clust2_bio_list <- as.list(clust2_bio)
names(clust2_bio_list$Result.gene.list) <- clust2_bio_list$Name
clust2_bio <- clust2_bio_list$Result.gene.list
#Cellular Component
clust2_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 2)
clust2_cell_list <- as.list(clust2_cell)
names(clust2_cell_list$Result.gene.list) <- clust2_cell_list$Name
clust2_cell <- clust2_cell_list$Result.gene.list

#this was not included because there were no Molecular Function GO terms in cluster 2
#clust2_mol <- cluster2 %>% filter(Cluster2.Type == "Molecular Function")
#clust2_mol_list <- as.list(clust2_mol)
#names(clust2_mol_list$Cluster2.Result.gene.list) <- clust2_mol_list$Cluster2.Name
#fuzzylist_2_mol <- clust2_mol_list$Cluster2.Result.gene.list
 
#########CLUSTER 3######### 
#this was not included because there were no Biological Process, Cellular Component, Molecular Function 
#GO terms in cluster 3
#cluster3 <- data.frame(GO[3])%>%dplyr::select(Cluster3.Name,Cluster3.Result.gene.list,Cluster3.Type) 
#clust3_bio <- cluster3 %>% filter(Cluster3.Type == "Biological Process")
#clust3_cell <- cluster3 %>% filter(Cluster3.Type == "Cellular Component")
#clust3_mol <- cluster3 %>% filter(Cluster3.Type == "Molecular Function")

#########CLUSTER 4######### 
#Biological Process
clust4_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 4)
clust4_bio_list <- as.list(clust4_bio)
names(clust4_bio_list$Result.gene.list) <- clust4_bio_list$Name
clust4_bio <- clust4_bio_list$Result.gene.list
#Cellular Component 
clust4_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 4)
clust4_cell_list <- as.list(clust4_cell)
names(clust4_cell_list$Result.gene.list) <- clust4_cell_list$Name
clust4_cell <- clust4_cell_list$Result.gene.list
#Molecular Function
clust4_mol <- fuzzyClust %>% filter(Type == "Molecular Function", Cluster == 4)
clust4_mol_list <- as.list(clust4_mol)
names(clust4_mol_list$Result.gene.list) <- clust4_mol_list$Name
clust4_mol <- clust4_mol_list$Result.gene.list

#########CLUSTER 5#########  
#this was not included because there were no Biological Process, Cellular Component, Molecular Function 
#GO terms in cluster 5
#cluster5 <- data.frame(GO[5])%>%dplyr::select(Cluster5.Name,Cluster5.Result.gene.list,Cluster5.Type) 
#clust5_bio <- cluster5 %>% filter(Cluster5.Type == "Biological Process")
#clust5_cell <- cluster5 %>% filter(Cluster5.Type == "Cellular Component")
#clust5_mol <- cluster5 %>% filter(Cluster5.Type == "Molecular Function")
 
#########CLUSTER 6######### 
#this was not included because there were no Biological Process or Molecular Function GO terms in cluster 6
#clust6_bio <- cluster6 %>% filter(Cluster6.Type == "Biological Process")

#Cellular Component 
clust6_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 6) 
clust6_cell_list <- as.list(clust6_cell)
names(clust6_cell_list$Result.gene.list) <- clust6_cell_list$Name
clust6_cell <- clust6_cell_list$Result.gene.list
```

```{r,include =  FALSE}
tryp_cluster_1 <- read.table("tryp_cluster_1.csv")
tryp_cluster_2 <- read_csv("tryp_cluster_2.csv")
tryp_cluster_3 <- read_csv("tryp_cluster_3.csv")
tryp_cluster_4 <- read_csv("tryp_cluster_4.csv")
tryp_cluster_5 <- read_csv("tryp_cluster_5.csv")
tryp_cluster_6 <- read_csv("tryp_cluster_6.csv")

```


# 5.2 Savage GO  

Here, we must upload the files into the trypanosome database, by taking all the rownames of the DESeq2 results analysis. What that means is, is that we are taking the names of all the DEGs found by DESeq2 and uploading them to a database for GO. Then, after writing the file, the quotations and 'x' must be deleted in order to run Geneid analysis in the database. 
This is comparison MG/SA, other comparisons MG/PV and PV/SA are not shown in the kintted file but completed. 

```{r}
###here we need to perform GO on these genes. Upload to tryp database under New search : metabolic pathways, and enter this txt file. Then, make sure to get is downloaded as a csv.
  #GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(MgSa), collapse="\t")
write.table(file_to_write, file="MgSa_gene") #look up in file directory, then delete quotation marks as well as the first rows that are not genes
```

```{r, echo = FALSE,include =  FALSE}
#creating file for GO/PATHWAY ANALYSIS
file_to_write<-paste(rownames(MgPv), collapse="\t")
write.table(file_to_write, file="MgPv_gene")

#creating file for GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(PvSa), collapse="\t")
write.table(file_to_write, file="PvSa_gene")

```

# 6. Gene Set Enrichment Analysis  

Gene Set Enrichment Analysis interperts gene expression data by focusing on gene sets, or sets of genes that share common traits and or biological function. This algorithm uses categorical or continuous phenotype data, such as an experiment testing ‘treatment’ vs ‘untreated’. The goal of GSEA is to determine if a gene set S is randomly distributed or found at the top or bottom of a ranked gene list L. 

For our analysis, we want to 
Take Savage DE genes comparisons and enrich them in Schulz data
Take DE genes from Schulz clusters/data and enrich them in Savage data
Take GO terms from Savage data and enrich them in Schulz data
Take GO terms from Schulz clusters and enrich them in Savage data

We used fgsea(), or fast gene set enrichment analysis. 

In order to prepare our results for GSEA pipline, we must manipulate GO data tables into pathways (list), and ranks (vector). 

# 6.1 GSEA: Savage  

Here we have the loaded GO analysis  of Savage data set. This set includes GO Biological Process, Molecular Function, and Cellular Component. 

```{r}

###############MAKING PATHWAY LIST FROM GO ANALYSIS - BIO, CELL,MOLECULAR###########################

####################BIO PROS GO###########################
MgSa_GObiopros <- read.table("MgSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GObiopros <- data.frame(MgSa_GObiopros, comparison = "MgSa_bio")
MgPv_GObiopros <- read.table("MgPv_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GObiopros <- data.frame(MgPv_GObiopros, comparison = "MgPv_bio")
PvSa_GObiopros <- read.table("PvSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GObiopros <- data.frame(PvSa_GObiopros, comparison = "PvSa_bio")
  
```
Here, to speed up the process, we bind all GO biological process for three comparisons MgSa, MgPv, and PvSa. We will separate the data frame using filter function using column 'comparison'.
Because the genes that are given by default in this data table are not in a list format, but rather a block of string. We need to split the genes in order to evaluate GSEA using string split them using functions gsub() and strsplit(). 
```{r}
  
all_bio <- rbind(MgSa_GObiopros,MgPv_GObiopros,PvSa_GObiopros)
all_bio$Result.gene.list[1]
all_bio$Result.gene.list <- gsub(',',',',all_bio$Result.gene.list,fixed=TRUE)
all_bio$Result.gene.list <- strsplit(all_bio$Result.gene.list, ",")
all_bio$Result.gene.list[1]
```
 
Here, using the filter function we filter data frame MgSa GO biological process, and then turn the resulting GO term data table into a list of GO terms and resulting gene names. Complete data filter and GO pathway creation for remaining GO Cellular, and Molecular pathways for MgSa, MgPv, and PvSa. 
```{r}
#MgSa Bio
MgSa_GObiopros <- data.frame(all_bio %>% dplyr :: filter(comparison == "MgSa_bio"))
MgSa_GObiopros_list <- as.list(MgSa_GObiopros)
names(MgSa_GObiopros_list$Result.gene.list) <- MgSa_GObiopros_list$Name 
MgSaGOlist_bio <- MgSa_GObiopros_list$Result.gene.list
MgSaGOlist_bio$`transmembrane transport`

```

```{r, echo = FALSE,include =  FALSE}
#MgPv Bio
MgPv_GObiopros <- data.frame(all_bio %>% filter(comparison == "MgPv_bio"))
MgPv_GObiopros_list <- as.list(MgPv_GObiopros)
names(MgPv_GObiopros_list$Result.gene.list) <- MgPv_GObiopros_list$Name
MgPvGOlist_bio <- MgPv_GObiopros_list$Result.gene.list
#PvSa Bio
PvSa_GObiopros <- data.frame(all_bio %>% filter(comparison == "PvSa_bio"))
PvSa_GObiopros_list <- as.list(PvSa_GObiopros)
names(PvSa_GObiopros_list$Result.gene.list) <- PvSa_GObiopros_list$Name
PvSaGOlist_bio <- PvSa_GObiopros_list$Result.gene.list

#####################CELL PROS#######################
  #MGSA
MgSa_GOcellpros <- read.table("MgSa_GOcellpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOcellpros <- data.frame(MgSa_GOcellpros, comparison = "MgSa_cell")
MgPv_GOcellpros <- read.table("MgPv_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOcellpros <- data.frame(MgPv_GOcellpros, comparison = "MgPv_cell")
PvSa_GOcellpros <- read.table("PvSa_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOcellpros <- data.frame(PvSa_GOcellpros, comparison = "PvSa_cell")
  
all_cell <- rbind(MgSa_GOcellpros, MgPv_GOcellpros,PvSa_GOcellpros)
all_cell$Result.gene.list <- gsub(',',',',all_cell$Result.gene.list,fixed=TRUE)
all_cell$Result.gene.list <- strsplit(all_cell$Result.gene.list, ",")

  #MGSA CELL
MgSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgSa_cell"))
MgSa_GOcellpros_list <- as.list(MgSa_GOcellpros)
names(MgSa_GOcellpros_list$Result.gene.list) <- MgSa_GOcellpros_list$Name
MgSaGOlist_cell <- MgSa_GOcellpros_list$Result.gene.list
  #MGPV CELL
MgPv_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgPv_cell"))
MgPv_GOcellpros_list <- as.list(MgPv_GOcellpros)
names(MgPv_GOcellpros_list$Result.gene.list) <- MgPv_GOcellpros_list$Name
MgPvGOlist_cell <- MgPv_GOcellpros_list$Result.gene.list
  #PVSA CELL
PvSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "PvSa_cell"))
PvSa_GOcellpros_list <- as.list(PvSa_GOcellpros)
names(PvSa_GOcellpros_list$Result.gene.list) <- PvSa_GOcellpros_list$Name
PvSaGOlist_cell <- PvSa_GOcellpros_list$Result.gene.list
#View(PvSaGOlist_cell)


##################### MOLE PROS #####################
MgSa_GOmolepros <- read.table("MgSa_GOmolecpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOmolepros <- data.frame(MgSa_GOmolepros, comparison = "MgSa_mol")
MgPv_GOmolepros <- read.table("MgPv_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOmolepros <- data.frame(MgPv_GOmolepros, comparison = "MgPv_mol")
PvSa_GOmolepros <- read.table("PvSa_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOmolepros <- data.frame(PvSa_GOmolepros, comparison = "PvSa_mol")
  
all_mol <- rbind(MgSa_GOmolepros,MgPv_GOmolepros, PvSa_GOmolepros)
all_mol$Result.gene.list <- gsub(',',',',all_mol$Result.gene.list,fixed=TRUE)
all_mol$Result.gene.list <- strsplit(all_mol$Result.gene.list, ",")

  #MGSA MOL
MgSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgSa_mol")) 
MgSa_GOmolepros_list <- as.list(MgSa_GOmolepros)
names(MgSa_GOmolepros_list$Result.gene.list) <- MgSa_GOmolepros$Name
MgSaGOlist_mole <- MgSa_GOmolepros_list$Result.gene.list
  #MGPV MOL
MgPv_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgPv_mol")) 
MgPv_GOmolepros_list <- as.list(MgPv_GOmolepros)
names(MgPv_GOmolepros_list$Result.gene.list) <- MgPv_GOmolepros$Name
MgPvGOlist_mole <- MgPv_GOmolepros_list$Result.gene.list
  #PVSA MOL
PvSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "PvSa_mol")) 
PvSa_GOmolepros_list <- as.list(PvSa_GOmolepros)
names(PvSa_GOmolepros_list$Result.gene.list) <- PvSa_GOmolepros$Name
PvSaGOlist_mole <- PvSa_GOmolepros_list$Result.gene.list



```

Creating ranks

To measure the enrichment of Savage DE genes in Schulz clusters, we need to create a ranked list based on a metric of differential expression. For this analysis, the metric used was -log10(pvlaue) * abs(logfold2change). If the p value of a resulting DE gene is very low, the -log10(pvalue) will be extremely large. Contrastly, a high logfold2change represents high expression, and a positive logfold2change shows genes are up regulated, and a negative logfold2change show genes are down regulated. Thus, the ranked vector of Savage DE genes will factor the up/down gene regulation and DE gene significance and magnitude.  


A. Making ranked metric list for GSEA: 
We want to complete these tasks for GSEA. First,we will be creating ranks for Savage data.
  1. Ranks for Savage data (three ranks = MgSa, MgPv, PvSa)
  2. Ranks for Schulz data (Three ranks = negative logfold, positive logfold, total)



To begin creating the ranked list, the results data table for all Savage comparisons will be row bound and differentiated by column 'comparison' to speed up coding and process. 

```{r}
#######MAKING RANKED METRIC LIST FOR SAVAGE DATA########

#making big data set 'allcomp' with all comparisons to make code easier. Splitting after by 'comparison' 
MGSA_df <- data.frame(Gene = rownames(MgSa), pvalue = MgSa$pvalue, padj = MgSa$padj, comparison = "MgSa",log2FoldChange= MgSa$log2FoldChange)
MGPV_df <- data.frame(Gene = rownames(MgPv), pvalue = MgPv$pvalue, padj = MgPv$padj, comparison = "MgPv", log2FoldChange= MgPv$log2FoldChange)
PVSA_df <- data.frame(Gene = rownames(PvSa), pvalue = PvSa$pvalue, padj = PvSa$padj, comparison = "PvSa",log2FoldChange= PvSa$log2FoldChange)
sav_allcomp <- rbind(MGSA_df,MGPV_df, PVSA_df)
```

Next, we will be creating the ranked metric, which is again the -log10(pvalue) * abs(sav_allcomp$log2FoldChange). Because we joined the DEGs for each comparison, we will need to separate them after calculating the metric, and then separatly rank each by using the function sort(). 
```{r}

sav_allcomp$logP <- -log10(sav_allcomp$pvalue) #calculating metric == -log10(pvalue)
sav_allcomp <-  sav_allcomp[which(abs(sav_allcomp$logP) != 0),] #filtering out p-values 
sav_allcomp$metric <- sav_allcomp$logP * abs(sav_allcomp$log2FoldChange)
sav_gsea_allcomp <- sav_allcomp[,c("Gene","metric","comparison")]

##filtering out big dataset -- creating data frames for each comparison 
gsea_MgSa_df<- sav_gsea_allcomp %>% filter(comparison == "MgSa") %>% dplyr :: select(-comparison) 
gsea_MgPv_df <- sav_gsea_allcomp %>% filter(comparison == "MgPv") %>% dplyr :: select(-comparison) 
gsea_PvSa_df <- sav_gsea_allcomp %>% filter(comparison == "PvSa") %>% dplyr :: select(-comparison) 
head(gsea_MgSa_df)
#creating stats and pathways for gsea
  #MgSa
gseaDat_MgSa <- filter(gsea_MgSa_df, !is.na(Gene))
gseaDat_MgSa <- gseaDat_MgSa %>% filter(metric != c(Inf, -Inf))
ranks_MgSa <- gsea_MgSa_df$metric
names(ranks_MgSa) <- gseaDat_MgSa$Gene
ranks_MgSa <- sort(ranks_MgSa)
head(ranks_MgSa)
```

```{r, echo = FALSE,include =  FALSE}
  #MgPv
gseaDat_MgPv <- filter(gsea_MgPv_df, !is.na(Gene))
gseaDat_MgPv <- gseaDat_MgPv %>% filter(metric != c(Inf, -Inf))
ranks_MgPv <- gsea_MgPv_df$metric
names(ranks_MgPv) <- gseaDat_MgPv$Gene
ranks_MgPv <- sort(ranks_MgPv)
#PvSa
gseaDat_PvSa <- filter(gsea_PvSa_df, !is.na(Gene))
gseaDat_PvSa <- gseaDat_PvSa %>% filter(metric != c(Inf, -Inf))
ranks_PvSa <- gsea_PvSa_df$metric
names(ranks_PvSa) <- gseaDat_PvSa$Gene
ranks_PvSa <- sort(ranks_PvSa)

```

B. Making metric rank for Schulz data
Similar to savage, we will create a ranked list of DEGs for Schulz data. We will be using the 0-12 time comparison, and separate the negative, positive, and total logfold2change.  

Here, we will take resSig_012, which represents the log2 of the fold change of treated 12h and untreated 0h, ib_12h / noo_ib, and create ranking metric -log10(pvalue) * abs(logfold2change). Because there are values of -+ Infinity for our metric, we needed to remove them for future analysis. 

This process was completed for positive and negative log fold, but is not shown in the knitted document.

```{r}
 
#Making metric rank for 0-12h comparison

#creating metric used for ranking DE of genes for TB schulz 0-12h timepoint contrast
#resSig$fcsign <- sign(resSig$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig <-  resSig[which(abs(resSig$fcsign) != 0),] #filtering out foldchanges = 0
resSig_012$logP = -log10(resSig_012$pvalue) 
resSig_012 <-  resSig_012[which(abs(resSig_012$logP) != 0),] 
resSig_012$metric= resSig_012$logP * abs(resSig_012$log2FoldChange)#calculating metric = log10(pvalue)/fcsign
resSig_012$Gene <- rownames(resSig_012) #creating column Gene for dataframe
gsea_schulz <-resSig_012[,c("Gene", "metric")]

#Creating data frame from gsea_schulz for gsea
gsea_schulz_df <- data.frame(gsea_schulz)
rownames(gsea_schulz_df) <- NULL
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != Inf),]
gsea_schulz_df[1:10,] 
#creating stats and pathways for gsea
gseaDat_schulz <- filter(gsea_schulz_df, !is.na(Gene))
ranks <- gsea_schulz_df$metric
names(ranks) <- gseaDat_schulz$Gene
ranks <- sort(ranks)
head(ranks)
```

```{r, echo = FALSE,include =  FALSE}
#####FOR LOG POS FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.pos$fcsign <- sign(resSig_log.pos$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.pos$logP = -log10(resSig_log.pos$pvalue) 
resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$logP) != 0),] 
resSig_log.pos$metric= resSig_log.pos$logP * abs(resSig_log.pos$log2FoldChange) #metric = -log10(pvalue) *abs(log2FoldChange)
resSig_log.pos$Gene <- rownames(resSig_log.pos) #creating column Gene for dataframe
gsea_schulz_log.pos <-resSig_log.pos[,c("Gene", "metric")]
 
  #creating data frame
gsea_schulz_df_log.pos <- data.frame(gsea_schulz_log.pos)
rownames(gsea_schulz_df_log.pos) <- NULL
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != Inf),]
gsea_schulz_df_log.pos[1:10,]

  #creating ranks for fgsea
gseaDat_schulz_log.pos <- filter(gsea_schulz_df_log.pos, !is.na(Gene))
ranks_log.pos <- gsea_schulz_df_log.pos$metric
names(ranks_log.pos) <- gseaDat_schulz_log.pos$Gene
ranks_log.pos <- sort(ranks_log.pos)
head(ranks_log.pos)
#####FOR LOG NEG FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.neg$fcsign <- sign(resSig_log.neg$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.neg$logP <-  -log10(resSig_log.neg$pvalue)
resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$logP) != 0),] 
resSig_log.neg$metric <-  resSig_log.neg$logP * abs(resSig_log.neg$log2FoldChange) #calculating metric = log10(pvalue) 
resSig_log.neg$Gene <- rownames(resSig_log.neg) #creating column Gene for dataframe
gsea_schulz_log.neg <-resSig_log.neg[,c("Gene", "metric")]

  #creating data frame
gsea_schulz_df_log.neg <- data.frame(gsea_schulz_log.neg)
rownames(gsea_schulz_df_log.neg) <- NULL
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != -Inf),] #removing metric   where = -Inf
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != Inf),]
gsea_schulz_df_log.neg[1:10,]
  #creating ranks for fgsea
gseaDat_schulz_log.neg <- filter(gsea_schulz_df_log.neg, !is.na(Gene))
ranks_log.neg <- gsea_schulz_df_log.neg$metric
names(ranks_log.neg) <- gseaDat_schulz_log.neg$Gene
ranks_log.neg <- sort(ranks_log.neg)
head(ranks_log.neg)

```

Now, we will complete GSEA on Savage DE genes that are enriched in Schulz DE genes 0-12 hours. 

```{r}

################################GSEA on all SAV DE genes########################################
####need to make list of all 'pathways'
sav_all_list <- c()
  #for MgSa
MgSa_list <- rownames(MgSa)
  #for MgPv
MgPv_list <- rownames(MgPv)
  #for PvSa
PvSa_list <- rownames(PvSa)
 
#creating full list for all savage 
sav_all_list$MgSa <- MgSa_list
sav_all_list$MgPv <- MgPv_list
sav_all_list$PvSa <- PvSa_list
```

```{r}
#FGSEA on SAV DE GENES (NO GO)

fgseaRes_all <- fgsea(pathways = as.list(sav_all_list), stats = ranks, minSize = 1,  nperm = 1000)
fgseaRes_all

plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks ) + labs(title ="MgSa")
```

```{r, include =  FALSE}
fgseaRes_all_pos <- fgsea(pathways = as.list(sav_all_list), stats = ranks_log.pos, minSize = 1,  nperm = 1000)
fgseaRes_all_pos

plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks_log.pos) + labs(title ="MgSa pos log fold")
```

```{r,include =  FALSE}
fgseaRes_all_neg <- fgsea(pathways = as.list(sav_all_list), stats = ranks_log.neg, minSize = 1,  nperm = 1000)
fgseaRes_all_neg

plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks_log.neg) + labs(title ="MgPv Negative log fold")
```

```{r, echo = FALSE,include =  FALSE}
##########NEG FOLD CHANGE ENRICHMENT#########
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks_log.neg) + labs(title = "MgSa Negative log fold")
plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks_log.neg) + labs(title ="MgPv Negative log fold")
plotEnrichment(pathway = sav_all_list$PvSa,
               stats  = ranks_log.neg) + labs(title ="PvSa Negative log fold")
##########POS FOLD CHANGE ENRICHMENT#########
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks_log.pos) + labs(title ="MgSa pos log fold")
plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks_log.pos) + labs(title ="MgPv pos log fold")
plotEnrichment(pathway = sav_all_list$PvSa,
               stats  = ranks_log.pos) + labs(title ="PvSa pos log fold")
##########TOTAL ENRICHMENT##################
plotEnrichment(pathway = sav_all_list$MgSa,
               stats  = ranks ) + labs(title ="MgSa")
plotEnrichment(pathway = sav_all_list$MgPv,
               stats  = ranks ) + labs(title ="MgPv")
plotEnrichment(pathway = sav_all_list$PvSa,
               stats  = ranks ) + labs(title ="PvSa")



```


Here, we have GO analysis results from three comparisons of savage data, MgSa, MgPv, and PvSa. We will test these pathways on our data, separated into negative and positive log fold change, and ranked by the metric -log(pvalue)*abs(logfold2change). We will perform fgsea on each pathway, for positive, and negative ranked DE genes from our time point 0 to 12hours. 

```{r, echo = FALSE,include =  FALSE}
 ########################FGSEA -- SAV GO DATA ENRICHED IN OUR DATA################################
 
#In order to complete GSEA, we must create pathways, or gene lists that help us determine if that particular gene set is enriched in a gene expression data set. 

all_list <- c()
all_list$MgSa_bio <- MgSaGOlist_bio
all_list$MgPv_bio <- MgPvGOlist_bio
all_list$PvSa_bio <- PvSaGOlist_bio
all_list$MgSa_cell <- MgSaGOlist_cell
all_list$MgPv_cell <- MgPvGOlist_cell
all_list$PvSa_cell <- PvSaGOlist_cell
all_list$MgSa_mole <- MgSaGOlist_mole
all_list$MgPv_mole <- MgPvGOlist_mole
all_list$PvSa_mole <- PvSaGOlist_mole

fgsea_all_pos <- c()
fgsea_all_neg <- c()
for (i in 1:9){
fgsea_all_pos[[i]] = fgsea(pathways = as.list(all_list[[i]]), stats = ranks_log.pos, minSize = 15,  nperm = 1000)
fgsea_all_neg[[i]] = fgsea(pathways = as.list(all_list[[i]]), stats = ranks_log.neg, minSize = 15,  nperm = 1000)
}
names(fgsea_all_neg) <- names(all_list)
names(fgsea_all_pos) <- names(all_list)
 
```

Here, we have GSEA of PvSa Biological Process GO term and genes enriched in Schulz positive log DEGs. 
```{r}
 
#fgsea_all_pos[3]
plotEnrichment(all_list$MgSa_mole[[head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway)
```

Here, MgSa Cellular Component GO terms and genes enriched in Schulz negative log DEGs.
```{r}
#fgsea_all_neg[4]
plotEnrichment(all_list$MgSa_cell[[head(fgsea_all_pos$MgSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_cell[order(pval), ], 1)$pathway)
```
Here, MgPv Cellular Component GO DEGs enriched in Schuls negative log DEGs
```{r}
#fgsea_all_neg[5]
plotEnrichment(all_list$MgPv_cell[[head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway)
```
Here, PvSa Cellular Component DEGs enriched in Schulz negative log DEGs
```{r}
#fgsea_all_neg[6]
plotEnrichment(all_list$PvSa_cell[[head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway)
```

```{r, echo = FALSE,include =  FALSE}
#####################MGSA ENRICHMENT########################

########POSLOG###########
plotEnrichment(all_list$MgSa_bio[[head(fgsea_all_pos$MgSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgSa_cell[[head(fgsea_all_pos$MgSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgSa_mole[[head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgSa_mole[order(pval), ], 1)$pathway)
########NEG LOG###########
plotEnrichment(all_list$MgSa_bio[[head(fgsea_all_neg$MgSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgSa_cell[[head(fgsea_all_neg$MgSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_cell[order(pval), ], 1)$pathway)

#plotEnrichment(all_list$MgSa_mole[[head(fgsea_all_neg$MgSa_mole[order(pval), ], 1)$pathway]],
               #ranks_log.neg) + labs(title=head(fgsea_all_neg$MgSa_mole[order(pval), ], 1)$pathway)

#####################MGPV ENRICHMENT########################

########POS LOG###########
plotEnrichment(all_list$MgPv_bio[[head(fgsea_all_pos$MgPv_bio[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgPv_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_cell[[head(fgsea_all_pos$MgPv_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgPv_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_mole[[head(fgsea_all_pos$MgPv_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$MgPv_mole[order(pval), ], 1)$pathway)
########NEG LOG###########
plotEnrichment(all_list$MgPv_bio[[head(fgsea_all_neg$MgPv_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_cell[[head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$MgPv_mole[[head(fgsea_all_neg$MgPv_mole[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$MgPv_mole[order(pval), ], 1)$pathway)
 
#####################PVSA ENRICHMENT########################

########POS LOG###########
plotEnrichment(all_list$PvSa_bio[[head(fgsea_all_pos$PvSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$PvSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_cell[[head(fgsea_all_pos$PvSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$PvSa_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_mole[[head(fgsea_all_pos$PvSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.pos) + labs(title=head(fgsea_all_pos$PvSa_mole[order(pval), ], 1)$pathway)

########NEG LOG###########
plotEnrichment(all_list$PvSa_bio[[head(fgsea_all_neg$PvSa_bio[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_bio[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_cell[[head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_cell[order(pval), ], 1)$pathway)

plotEnrichment(all_list$PvSa_mole[[head(fgsea_all_neg$PvSa_mole[order(pval), ], 1)$pathway]],
               ranks_log.neg) + labs(title=head(fgsea_all_neg$PvSa_mole[order(pval), ], 1)$pathway)

```
 
# 6.2 GSEA: Fuzzy - Running GSEA - Preparing Schulz Clusters for pathways  


# 7 Conclusion   

Through this analysis of Schulz's data set of Trypanosoma Brucei, there was much done and much more to be done. In analyzing the clusters:

GO analysis of Fuzzy clusters in bromodomain-inhibited T. brucei suggest a developmental transition away from PF and towards BF
○ Motility: Cluster 1 GO terms indicate upregulation of motility related genes. T. brucei movement through host tissues is essential for development & pathogenesis, particularly in migrating through the tissues of the insect host (Dimitrova et al. 2017).
○ Glycosome & hexokinase activity: Cluster 3 GO terms indicate upregulation of glycolic and glycosomal genes. The bloodstream is a glucose-rich environment; in BF, glycolysis is confined to the glycosome and is the sole source of ATP (Michels et al. 2006).
○ Stress Granule: Cluster 6 GO terms indicate downregulation in genes involved in the cytoplasmic stress granules. These granules are RNA-protein complexes formed during Carbon-starvation in the insect intestinal tract (PF).
● GSEA on Savage DEG GO terms on Schulz 0-12 hours DEGs show enrichment in membrane and transport function indicating an upregulation of cell surface protein genes in T.brucei PF.
○ This increased expression of surface proteins suggests a potential BF epitope change, as T.brucei PF does not exhibit antigenic variation in cell surface genes.
● Bromodomain proteins appear responsible for maintenance of both PF and BF fates

To continue this project, we would need to continue to identify and assign biological meaning to DEGs, and look more into GO analysis. Furthermore, we will need to look into clusering algorithms and make sure that each person will get the same result when using the function, and that the biologist will agree and be able to interpert our results. We will mainly be looking at fuzzy clustering algorithm, and identify either mistakes, or better ways to cluster the DEGs. 

 
# Citations  

Fischer, et al. “Impulse Model-Based Differential Expression Analysis of Time Course Sequencing Data.” OUP Academic, Oxford University Press, 8 Aug. 2018, academic.oup.com/nar/article/46/20/e119/5068248.

 Conesa, Ana, and Nueda Mar ́ıa  J. “MaSigPro User’s Guide.” Bioconductor.org, 4 Sept. 2017, www.bioconductor.org/packages/release/bioc/vignettes/maSigPro/inst/doc/maSigProUsersGuide.pdf.







