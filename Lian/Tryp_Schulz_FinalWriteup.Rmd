---
title: "Tryp_schulz_FinalWriteup"
author: "Lian Morales"
date: "7/22/2019"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
#Data Manipulation
library("dplyr")
library("tidyr")
library(readr)
library(devtools)
library("vsn")
library("hexbin")
library("tidyverse")
library(stringr)
library("Hmisc")
#DEG tools 
library("DESeq2")
library(cluster)
library("mclust")
library(ImpulseDE2)
library(maSigPro)
library(edgeR)
#for visualzation
library(VennDiagram)
library(ggplot2)
library("corrplot")
#for GSEA
library(doParallel)
library(Biobase)
library(biomaRt)
library(fgsea)
library(BiocParallel)
```

#Table of Contents
1. Background
1.1 Abstract
1.2 Goals
2. Methods
2.1 Normalization
2.2 Differential Expression Analysis
2.3 Clustering
3. Comparing Data 
3.1 Savage Data
3.2 Savage Methods
4. Gene Ontology Analysis
4.1 Schulz GO
4.2 Savage GO
5.Gene Set Enrichment Analysis
5.1 Clusters
5.2 Savage 
6. Conclusion
7. Acknowledgements

#1. Background 

#1.1 Abstract
West African Sleeping Sickness is a deadly disease contracted by the bite of an infected Tsetse fly carriying the protozoan parasite Trypanosoma Brucei. This sickness is fatal and often terminal in mammals and humans, as parasites proliferate in lymphatic, blood, nervous systems, and eventually the brain. Syptoms include disrupted sleep, behavioral changes,neurological damage, and death if left untreated. Due to the limited studies of this illness and harmful drug treatments, motivation to understand the complexity and nature of Trypanosoma Brucei become pertinent to world wide health and safety. 

Trypanosome surface proteins can directly interact with the host environment, allowing parasites to effectively establish and maintain infections(Savage). During its infectious cycle, the parasite maintains several life stages throughout changing environments of insect and mammal. When living in the fly, the parasite's surface is covered with an invariant procylin, or proteins developed in the surface coating of Trypanosoma brucei in the Procyclic form(PF). However, upon living in the mammal, the parasite resides extracellularly in the bloodstream and becomes densly covered with highly immunogenic Variant Surface Glycoprotein (VSG). In this bloodstream form (BF), the parasite can vary its outer surface using approximatley 2,500 distinct VSG genes. As a result, Trypanosoma Brucei can evade human/mammal antibody immune response and remain virulent by constantly interchanging VSG genes.

For BF in mammals, the role of histone acetyl-lysine recognizing bromodomain proteins, have shown control of stem cell fate, this leading to the hypothesis that bromodomain proteins may maintain the BF cell fate in trypanosomes. Histone lysine acetylation is central to epigenetic control of gene transcription. Thus, boromodomain inhibition dirupts two major BF specific immune evasion mechanisms that trypanosomes harness to evade mamilian antibody immune response. Of these functions, monoalleic expression of varied VSG disrupted, and rapid internalization of antibodies bound to VSG on the surface of the trypanosome is blocked. Through these results, bromodomain inhibition in BF trypanosomes reveals changes in the transciptome similar to PF trypanosomes. Importantly, bromodomain inhibition leads to a decrease in virulence in a mouse model of infection, establishing these proteins as potential therapeutic drug targets for trypanosomiasis.

This summer 2019, we looked at the result of research studying the effects of bromodomain inhibition in PF trypanosomes. Building off of past research, and understanding bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, we measured gene expression in WT PF and bromodomain-inhibited PF over 2 week time course, Determined differentially expressed genes (DEGs) between these two conditions, and finally help predict the effect of bromodomain inhibition on gene expression in insect form through data analysis.  
#1.2 Goals 

Building off of past research, and understanding bromodomain inhibition in BF leads to transcriptomic and epitope change towards PF, what is the result of inhibiting bromodomain in PF trypanosome? 

#2. Methods
To begin the analysis of Schulz data, we must understand the experiment's variables, conditions, and hypothesis. Schulz's data is a time course model with 10 samples with three repetitions. 
#2. RNA-Seq Overview
RNA Sequencing (RNA-seq) is a way to measure gene expression in an organism. The RNA is extracted and RNA reads (sequences of A, G, C, and U) are aligned to the organism's genome. The higher the number of reads mapped to a certain gene, the more we can say that gene is expressed.  

#3. Normalize Raw Counts
We must normalize the counts because each sample is sequenced at a different depth in RNA Seq. The sequencing depth of each sample refers to the total raw read count (column sum) of that sample. If we simply used the raw read counts from the data table given us by RNASeq, we wouldn't be comparing apples to apples because of that difference in sequencing depth.
#3.1 Starting with the raw read counts

```{r}
TBcounts <- read.table("18-5-23_Proc_ibet_TC_for_deseq.txt",header = TRUE) %>% dplyr ::select(-ib_3h_1) 
TBcounts <- TBcounts %>% dplyr :: distinct(gene, .keep_all = TRUE) 
#NORMALIZATION BY DESEQ2
rownames(TBcounts) <- TBcounts$gene #renames the gene row
TBcounts <- TBcounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
#creating new data frame for DESeq to analyze
tb_new <- data.frame(rownames = colnames(TBcounts),
                     reps = as.factor(c(1,2,3,1,2,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3)),
                    stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3))))
rownames(tb_new) <- tb_new$rownames
tb_new <- tb_new %>% dplyr ::select(-rownames)

```
 As you can see in the code above, the breakdown of our data invlolves separating the repetitions of the samples and times, or stages of the experiment. In the first line, we see that the treated sample 1 at 3 hours(ib_3h_1) is not included in our data analysis. This is becuase it is an outlier determined by Professor Schulz. 

#3.2 Computational methods 

Based on the large amount of genes in Schulz’s data, using more than one method to identify DEGs must be used to provide accurate results for our analysis. Due to the large amount of differential expression algorithms, the choice were limited down to 3 - DESeq2, ImpulseDE2, and maSigPro. 

#DESeq2:
DESeq normalizes raw count data using the algorithm Relative Log Expression(RLE). It first takes the geometric mean of all sample values, or the raw counts for each gene in a particular sample. This creates the reference sample of the data set. Then, DESeq2 takes the median of the number of observed reads in condition k and replicate r  and divides this value by the reference sample. As the algorithm completes this for all genes, the resulting vector is the ‘size factor’ of the particular sample. Size factors represent how deeply the sample is sequenced, and the ratio of the size factors of two different samples is an approximation of the ratio of their sequencing depths. 

#edgeR:
edgeR normalizes raw counts using Trimmed Mean Method(TMM). TMM first prenomalizes by library size, by dividing the observed number of reads for gene g in condition k and replicate r by the total number of reads for condition k and replicate r. For TMM, the arbitraty reference sample is condition and replicate 1, however one can specify what reference sample to use.  
For TMM, it takes the set of not trimmed genes with valid fold change and the absolute expression levels (cf. Robinson and Oshlack, 2010) and uses this value to calculate the relative scaling factor. Additionally, TMM scales this factor by multiplying it to one, thus giving a vector of normalization factor. These normalization factors are used as offset parameters in the statistical model for differential gene expression analysis. 

In order to ascertain the best normalization method for out data, our first step was comparing methods edgeR and DESeq2. The result of this comparison was that DESeq2 and edgeR gave very similar results, with a small amount of different DEGS. As a result, our choice between DESeq2 and edgeR was more arbitrary, as DESeq2’s algorithm was preferable to fast run time and simple easy input. However, to understand the main differences and similarities between these two specific methods, comparing DESeq2 size factors and edgeR normalization factors and creating a VennDiagram of DEG’s identified by each method allowed for a clearer understanding of each algorithm, as well as our data. 

#3.3 DESeq2 Normalization
```{r}
##dds stands for the DESeq Data Set
ddsFullCountTable <- DESeqDataSetFromMatrix(countData = TBcounts,
                                            colData = tb_new, 
                                            design = ~ reps + stage)

TBcounts_dds <- DESeq(ddsFullCountTable)

#calculating norm counts
##DESeq2 :: allows to specify where this fcn comes from
norm_counts <- as.data.frame(counts(TBcounts_dds, normalized = TRUE)) %>%
  mutate(gene = rownames(TBcounts))
 

```
#3.4 edgeR Normalization

Similar to DESeq, we will need to create a new data frame detailing the samples, time, and repetitions. For this data set, stage = treatment and time, and rep = sample repetition. 

For edgeR, the function calcNormFactors() calculates normalized counts, and return library size of each sample, normalization factor, and group of each sample. In this example, variable 'tb_normfact' represents the normalization factors that calcNormFactors() of Schulz raw counts outputs. In order to compare DESeq2's size factor and edgeR's normalization factor, we must multiply the normalization factor by  the library size for each sample.  In edgeR, the equivalent to the size factor is actually the effective library size. That is, the normalization factor captures sample-specific bias beyond differences in library size. 
  

```{r, include = FALSE}
#DE WITH EDGER
TBcounts_ER <- read.table("18-5-23_Proc_ibet_TC_for_deseq.txt",header = TRUE) %>% dplyr ::select(-ib_3h_1) 
TBcounts_ER <- TBcounts_ER %>% dplyr :: distinct(gene, .keep_all = TRUE) 
#NORMALIZATION BY DESEQ2
rownames(TBcounts_ER) <- TBcounts_ER$gene #renames the gene row
TBcounts_ER <- TBcounts_ER %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
 
#for easy data manipulation, creating DGE list from TBcounts and stages
#norm.factors is a numeric vector containing normalization factors (optional, defaults to all 1)
stage = as.factor(c(rep("noo_ib",3), rep("ib_3h", 2), rep("ib_6h",3), rep("ib_12h",3),rep("ib_24h",3),rep("ib_48h",3),rep("ib_3d",3),rep("ib_7d",3),rep("ib_10d",3),rep("ib_14d",3)))

#making variable 'rep' for the number of repetitions for each sample
rep <- as.factor(c(1,2,3,1,2,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3))
time <- c(rep(0,3), rep(3,2), rep(6,3,), rep(12,3), rep(24,3), rep(48,3), rep(72,3), rep(168,3), rep(240,3), rep(336,3))
tbcounts_dge <- DGEList(counts = TBcounts_ER, norm.factors = rep(1,ncol(TBcounts_ER)), group = stage, remove.zeros = TRUE)

#creating design matrix of reps and stage
design <- model.matrix(~ rep + stage)
rownames(design) <- colnames(TBcounts_ER)

#FILTER data -- getting rid of non expressed genes
keep <- filterByExpr(tbcounts_dge)
table(keep)
tbcounts_dge <- tbcounts_dge[keep, ,keep.lib.sizes = FALSE]
 
#NORMALIZE DATA - USING CALCNORMFACTORS()

tb_norm <- calcNormFactors(tbcounts_dge, method = "TMM", refColumn = NULL)
#separating the counts and samples
tbcounts <- tb_norm$counts
tb_normfact <- tb_norm$samples$norm.factors
 
#getting the norm counts
tb_normCounts <- cpm(tbcounts_dge)
```


```{r}
tb_norm_sf <- data.frame(tb_normfact* colSums(TBcounts_ER))
colnames(tb_norm_sf) <- "TMM.size.fact"
size.DESeq2 <- TBcounts_dds$sizeFactor 
size.edgeR <- tb_norm_sf$TMM.size.fact
plot(size.DESeq2, size.edgeR, main = "Size Factor DESeq & edgeR")
 
```

 
```{r}
#DE ANALYSIS - EDGER - getting the DE genes

#comparing 6h to noo, under hypothesis that 6h-noo = 0 
design <- model.matrix(~0 + stage)
rownames(design) <- colnames(tb_norm)
con <- makeContrasts(stageib_6h-stagenoo_ib , levels= design)
est_disp <- estimateDisp(tb_norm, design, robust=TRUE)
fit <- glmQLFit(est_disp, design, robust=TRUE)
qlf <- glmQLFTest(fit, contrast = con) 
summary(decideTests(qlf)) #looks at the number of up and down regulated genes
topTags(qlf) #looking at the top de genes

#now want to look at all de genes from toptags
out <- topTags(qlf, n=Inf, adjust.method="BH")  
keep <- out$table$FDR <= 0.01 #filtering genes with FDR 0.01
de_table <- out[keep,] #de_table for the table of DE genes

```


Our analysis compares the 0 time point to the 12 hour time point, because we are more interested in earlier time points due to the increased gene expression shown from 0-12 hours. 

For DESeq2, the results for a comparison of any two levels of a variable can be calculated using the contrast argument to the results function. The function requires three values: the name of the variable, the name of the level in the numerator, and the name of the level in the denominator. We will complete the same analysis (not shown) on comparisons MG/PV and PV/SA 
Here we extract results for the log2 of the fold change of treated 12h and untreated 0h, ib_12h / noo_ib. 


```{r}
#COMPARING - DE ANALYSIS - FOR GSEA

#comparing stages noo_ib and ib_12h --- the stage of non inhibited bromodomain at time 0 to inhibited bromodomain at time point 12 hours
TBcountsRes <- results( TBcounts_dds ,contrast = c("stage","ib_12h", "noo_ib"))
TBcountsRes
```

In order to correct for multiple testing, DESeq2 uses Benjamini-Hochberg (BH) adjustment, which is a method that decreases the false discovery rate(FDR). Due to the fact that small p-values often happen by chance, the tool helps remove the possibility of falsely rejecting the try null hypothesis. For example, if one had a very low p-value(<.05), it would mean that there is only a 5% chance that you would get your observed result granted the null was true. Thus, with a pvalue of 0.05, it is highly unlikely that your null is incorrect. So, in order to eliminate the possibility of FDR, the BH adjustment adjusts for the probability of a FDR. For example, if one called all genes that are signigicant are those with a p value less than or equal to a gene’s p value threshold, the BH method calculates the fraction of false positives among those genes. These values, called the BH-adjusted p values, are given in the column padj of the results object.

For our data, we considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Schulz dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  
 
For further analysis, we group the positive, and negative logfold2 changes. This is because down regulated genes have negative logfold2change and upregulated genes have a positive logfold2change. Therefore, by splitting up the data into up and down regulated genes, we can succesfully, and more clearly identify biological pathways for future analysis, such as Gene Ontology and Gene Set Enrichment Analysis.
```{r}
#resSig_012 stands for the results of the signigicant genes expressed in comparison of noo_ib and ib_12h
resSig_012 <- TBcountsRes[ which(TBcountsRes$padj < 0.01 ), ]
resSig_012 <- resSig_012[complete.cases(resSig_012),]
resSig_012$gene <- rownames(resSig_012)
resSig_012$fcsign <- sign(resSig_012$log2FoldChange) #fcsign stands for the log2foldchange sign
resSig_012

#creating negative and positive logfold change data sets
resSig_log.pos <- resSig_012[which(resSig_012$fcsign != -1),]
resSig_log.neg <- resSig_012[which(resSig_012$fcsign == -1),]
```

```{r}
ind <- match(norm_counts$gene,resSig_012$gene)
 
norm_counts$sig <- resSig_012$gene[ind]

norm_counts$padj <- resSig_012$padj[ind]

norm_counts$pval <- resSig_012$pvalue[ind]

norm_counts$log2FoldChange <- resSig$log2FoldChange[ind]

norm_counts <- norm_counts %>%
  filter(!is.na(sig))

pos_DEGs_metrics <- norm_counts %>%
  filter(log2FoldChange > 0)
rownames(pos_DEGs_metrics) <- pos_DEGs_metrics$gene
pos_DEGs <- pos_DEGs_metrics %>%
  dplyr :: select(-c(gene, sig, padj,pval,log2FoldChange))

neg_DEGs_metrics <- norm_counts %>%
  filter(log2FoldChange < 0)
rownames(neg_DEGs_metrics) <- neg_DEGs_metrics$gene
neg_DEGs <- neg_DEGs_metrics %>%
  dplyr :: select(-c(gene, sig, padj,pval,log2FoldChange))

rownames(norm_counts) <- norm_counts$gene
norm_counts <- norm_counts %>%
  dplyr :: select(-c(gene, sig, padj, pval, log2FoldChange))

norm_counts

```



```{r}
#making venn diagram
area1 <- length(rownames(resSig_012))    
area2 <- length(rownames(de_table))  
cross <- length(intersect(rownames(resSig_012), rownames(de_table)))
 
grid.newpage()
draw.pairwise.venn(area1= area1, area2 = area2, cross.area = cross, category = c("DESeq","edgeR"))
```

#5 Impulse 

```{r}
time <- c(rep(0,3), rep(3,2), rep(6,3,), rep(12,3), rep(24,3), rep(48,3), rep(72,3), rep(168,3), rep(240,3), rep(336,3))

impulse_design <- data.frame(Sample = colnames(TBcounts), Condition = rep("case", 29), Time = time)
#edit count matrix and filter s.t. average count is double digits
TBcounts <- as.matrix(TBcounts)

#may take awhile to run ImpulseDE2 (~20 mins), using q-value threshold of 0.01
tryp_impulse <- ImpulseDE2 :: runImpulseDE2(TBcounts, impulse_design,boolCaseCtrl = FALSE, vecConfounders = NULL, scaNProc = 8, scaQThres = 0.01)

```

#6. maSigPro
```{r}
#################################################################################################################################
#Serial expression tool: NEXT maSigPro
#################################################################################################################################

#set up design
times<-c(rep(0,3),rep(3,2),rep(6,3),rep(12,3),rep(24,3),rep(48,3),rep(72,3),rep(168,3),rep(240,3),rep(336,3))
replicates<-c(1:3, 1:2, rep(1:3, 8))
group<-rep(1,29)
ss.edesign<-cbind(times, replicates, group)
rownames(ss.edesign)<-colnames(TBcounts)

#Run maSigPro on DESeq2 normalized counts, theta=1000...
tccount1<-as.data.frame(counts(TBcounts_dds, normalized=TRUE))
ss.edesign<-as.data.frame(ss.edesign)
newdesign<-make.design.matrix(ss.edesign, degree=9, time.col=1, repl.col=2, group.cols=3)

#run maSigPro w/ Q=0.01
results<-maSigPro(tccount1, ss.edesign, vars="all", Q=0.01)
maSigProGenes<-results$p.vector[results$p.vector<0.01,]
maSigProGenes<-names(maSigProGenes)

```

#6 Creating Venn Diagram
```{r, echo = FALSE}
#Creating VennDiagram 

#Impluse and DESeq2
area <- length(intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)))
grid.newpage()
draw.pairwise.venn(area1= length(rownames(resSig_012)), area2 = length(tryp_impulse$vecDEGenes), cross.area = area, category = c("DESeq2 (0h-12h comparison)","ImpulseDE2 (serial analysis)"),lty = rep("blank",2),fill = c("light blue", "light green"))


#three way comparison - Impulse, maSigPro, DESeq2
area1 <- length(intersect(rownames(resSig_012),maSigProGenes))
area2<- length(intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)))
area3 <- length(intersect(maSigProGenes, tryp_impulse$vecDEGenes))
area123<-length(intersect(intersect(maSigProGenes, tryp_impulse$vecDEGenes), intersect(maSigProGenes,rownames(resSig_012))))
grid.newpage()
draw.triple.venn(area1= length(rownames(resSig_012)), area2 = length(maSigProGenes), area3= length(tryp_impulse$vecDEGenes), n12=area1, n23=area3, n13=area2, n123=area123, category = c("DESeq2 (0h-12h)","maSigPro (serial)", "ImpulseDE2 (serial)"), lty = rep("blank",3), fill = c("light blue", "light green", "pink"))

```

#6 Creating DEG list from three way intersection - Impulse, maSigPro, DESeq2

```{r}

###################################################################################################################################
#Generate Final DEGList
###################################################################################################################################

tryp_DEGs<-unique(c(intersect(rownames(resSig_012),maSigProGenes), intersect(tryp_impulse$vecDEGenes,rownames(resSig_012)), intersect(maSigProGenes, tryp_impulse$vecDEGenes)))
write.csv(tryp_DEGs, "tryp_DEGs.csv")

```
#7. Clustering 
```{r}

```

#7. Grouping Methods

In order to answer the biological questions of our data, we need to take statisitcal steps to gather information in order to prove or answer the hypothesis at hand. Clustering our data is an example of this method. Here we are taking the fuzzy cluster GO analysis results, and preparing them for GSEA pipeline. 
(cluster code here)
The two methods that we chose to cluster our data were Partitioning Around Medoids(PAM), and Fuzzy clustering. Choices for these are due to the efficiency of both algorithms, and time constraints of finding and running other methods. (Impulse)

PAM clustering, or **k-medoids** is a clustering algorithm similar to the **k-means** algorithm. Both k-means and k-medoids algorithms are partitional, or break the dataset into groups, and both attempt to minimize the distance between points labeled to be in a cluster, and a point designated as the center of that cluster. K-medoids uses data points as centers, and can be used with arbitrary distances. 
K-medoids clusters the data set of **n** objects into **k** clusters, with the number of 6 **k** clusters for our data set. This number ________ (chosen arbitrarily?)
In order to format our data to creat PAM clusters, we must create a dissimilarity matrix of the 


```{r}
k = 6

dissimilarity_matrix <- 1 - cor(t(norm_counts),method = "pearson")

DESeq_clusters <- cluster::pam(x = dissimilarity_matrix, k = k, pamonce = 5)

DESeq_clusters <- data.frame("cluster" = DESeq_clusters$clustering, "gene" = names(DESeq_clusters$clustering))

DESeq_medoids <- data.frame("medoids" = (DESeq_clusters$medoids))

norm_counts <- norm_counts %>%
  mutate("gene" = rownames(norm_counts))

DESeq_cluster_df <- left_join(norm_counts, DESeq_clusters, by = "gene")

DESeq_cluster_counts <- DESeq_cluster_df #%>%
  select(-c(padj,pval,log2FoldChange))

DESeq_cluster_metric <- DESeq_cluster_df %>%
  mutate("stat" = (-log10(DESeq_cluster_df$padj))) %>%
  select(gene, stat, cluster) %>%
  filter(stat != "-Inf") %>%
  filter(stat != "Inf")

DESeq_Pathways_list <-DESeq_cluster_metric$stat

names(DESeq_Pathways_list) <- DESeq_cluster_metric$gene

DESeq_cluster_list <- c()
DESeq_cluster_list <- split(DESeq_cluster_metric, DESeq_cluster_df$cluster)


DESeq_clusters <- c()
for (i in 1:k) {
  DESeq_clusters[[i]] <- DESeq_cluster_list[[i]]$stat
  names(DESeq_clusters[[i]]) <- DESeq_cluster_list[[i]]$gene
}

counts_gath_norm <- DESeq_cluster_counts %>%
  gather(-c(gene,cluster), key="sample", value = "rawcount") %>%
  mutate(sample2 = sample) %>%
  separate(sample2, c("treat", "time", "rep"), "_") %>%
  mutate(time = ifelse(time == "ib", 0, 
                        ifelse(time == "3h", 3, 
                               ifelse(time == "6h", 6,
                                      ifelse(time == "12h", 12,
                                             ifelse(time == "24h", 24,
                                                    ifelse(time == "48h", 48,
                                                           ifelse(time == "3d", 72,
                                                                  ifelse(time == "7d", 168,
                                                                         ifelse(time == "10d", 240, 336))))))))))
counts_gath_norm

counts_sum_norm <- counts_gath_norm %>%
  group_by(gene, treat, time, cluster) %>%
  dplyr::summarise(avecount = mean(rawcount))
counts_sum_norm_head <- counts_sum_norm %>%
  filter(time <= 12)

cluster_lists <- c()
cluster_lists[1] <- counts_sum_norm %>% filter(cluster == 1)
list_1 <- paste(cluster_lists[[1]], sep = "")
write.csv(list_1, file = "tryp_cluster_1.csv")

cluster_lists[2] <- counts_sum_norm %>% filter(cluster == 2)
list_2 <- paste(cluster_lists[[2]], sep = "")
write.csv(list_2, file = "tryp_cluster_2.csv")

cluster_lists[3] <- counts_sum_norm %>% filter(cluster == 3)
list_3 <- paste(cluster_lists[[3]], sep = "")
write.csv(list_3, file = "tryp_cluster_3.csv")

cluster_lists[4] <- counts_sum_norm %>% filter(cluster == 4)
list_4 <- paste(cluster_lists[[4]], sep = "")
write.csv(list_4, file = "tryp_cluster_4.csv")

cluster_lists[5] <- counts_sum_norm %>% filter(cluster == 5)
list_5 <- paste(cluster_lists[[5]], sep = "")
write.csv(list_5, file = "tryp_cluster_5.csv")

cluster_lists[6] <- counts_sum_norm %>% filter(cluster == 6)
list_6 <- paste(cluster_lists[[6]], sep = "")
write.csv(list_6, file = "tryp_cluster_6.csv")

## for specific cluster
#counts_sum_norm_cluster <- counts_sum_norm[ which(counts_sum_norm$cluster == 5),]

cluster_1_bp <- read_delim("cluster_1.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Biological Processes")
cluster_1_cc <- read_delim("cluster_1_cc.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Cellular Component")
cluster_1_mf <- read_delim("cluster_1_mf.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Molecular Function")
cluster_1 <- bind_rows(cluster_1_bp, cluster_1_cc, cluster_1_mf)
cluster_1 <- cluster_1 %>% filter(cluster_1$Benjamini < .05)
cluster_1$`Result gene list` <- strsplit(cluster_1$`Result gene list`, ",")
cluster_1_list_bp <- cluster_1 %>%
  filter(Type == "Biological Processes") %>%
  as.list()
names(cluster_1_list_bp$`Result gene list`) <- cluster_1_list_bp$Name
cluster_1_list_bp <- cluster_1_list_bp$`Result gene list`

cluster_2_bp <- read_delim("cluster_2.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Biological Processes")
cluster_2_cc <- read_delim("cluster_2_cc.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Cellular Component")
cluster_2_mf <- read_delim("cluster_2_mf.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Molecular Function")
cluster_2 <- bind_rows(cluster_2_bp, cluster_2_cc, cluster_2_mf)
cluster_2 <- cluster_2 %>% filter(cluster_2$Benjamini < .05)
cluster_2$`Result gene list` <- strsplit(cluster_2$`Result gene list`, ",")
cluster_2_list_bp <- cluster_2 %>%
  filter(Type == "Biological Processes") %>%
  as.list()
names(cluster_2_list_bp$`Result gene list`) <- cluster_2_list_bp$Name
cluster_2_list_bp <- cluster_2_list_bp$`Result gene list`

cluster_3_bp <- read_delim("cluster_3.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Biological Processes")
cluster_3_cc <- read_delim("cluster_3_cc.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Cellular Component")
cluster_3_mf <- read_delim("cluster_3_mf.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Molecular Function")
cluster_3 <- bind_rows(cluster_3_bp, cluster_3_cc, cluster_3_mf)
cluster_3 <- cluster_3 %>% filter(cluster_3$Benjamini < .05)
cluster_3$`Result gene list` <- strsplit(cluster_3$`Result gene list`, ",")
cluster_3_list_bp <- cluster_3 %>%
  filter(Type == "Biological Processes") %>%
  as.list()
names(cluster_3_list_bp$`Result gene list`) <- cluster_3_list_bp$Name
cluster_3_list_bp <- cluster_3_list_bp$`Result gene list`

cluster_4_bp <- read_delim("cluster_4.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Biological Processes")
cluster_4_cc <- read_delim("cluster_4_cc.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Cellular Component")
cluster_4_mf <- read_delim("cluster_4_mf.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Molecular Function")

cluster_5_bp <- read_delim("cluster_5.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Biological Processes")
cluster_5_cc <- read_delim("cluster_5_cc.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Cellular Component")
cluster_5_mf <- read_delim("cluster_5_mf.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Molecular Function")

cluster_6_bp <- read_delim("cluster_6.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Biological Processes")
cluster_6_cc <- read_delim("cluster_6_cc.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Cellular Component")
cluster_6_mf <- read_delim("cluster_6_mf.csv", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  mutate("Type" = "Molecular Function")


  
###########CC

GO_clusters <- list(data.frame(cluster_1), data.frame(cluster_2), data.frame(cluster_3), data.frame(cluster_4), data.frame(cluster_5), data.frame(cluster_6))


counts_sum_norm_head %>%
  ggplot(aes(x=time, y=avecount, group=gene, color = as.factor(cluster))) +
  geom_line() +
  ylim(0,10000) +
  facet_wrap(~cluster) +
  theme(legend.position = "none")
```

#8. Savage Data - DESeq2 pipeline

In order to answer Schulz's question of bromodomain inhibition impact on trypanosome PF, we must compare our results to Savage 2015 data, which includes trypanosoma DE genes gathered from enviromental based experiments in the Tsetse fly. The results of Savage 2015 data details the biological change in trypanosoma based on enviromental conditions. By comparing our DE genes to Savage enviromnet based DE genes, we can come to conclusions about what form the bromodomain inhibited PF will revert to, if at all. 
By comparing MG to SA, the resulting DE genes are those that exemplify the difference between BF and PF. These genes are very important in our understanding of the changes that Schulz samples undergo. For example, if there is a high amount of correlation between DE genes in MG to SA and 0h - 12h, we can hypothesize that bromodomain inhibition in PF causes a revert to the BF. 

Thus, by completing DESeq and future biological analysis on Savage data, we can come to a more concrete conclusion of bromodomain function in trypanosoma. 
 

Similar to analyzing our data, we must analyze 2015 Savage data, using the same pipeline: 
  1. Run raw read counts
  2. Filter/Quality Control
  3. Run Differental Gene Expression Analysis using DESEq2.
  
First, we must read in our data table. Variable 'savagecounts' represents this data table of Savage raw read counts. 
Similar to our data, we must manipulate our savagecounts data table for DESeq2. 
```{r, include  = FALSE}
#DESEQ ON SAVAGE DATA - THREE COMPARISON MGSA MGPV PVSA

savagecounts <- read.table("18-5-24_dedup_Savage_deseq_counts.txt", header = TRUE)

 
#Creating Data matrix 
rownames(savagecounts) <- savagecounts$gene #renames the gene row
savagecounts <- savagecounts %>% dplyr :: select(-"gene") #this gets rid of the name gene in table
coldata <- data.frame(rownames = colnames(savagecounts),
                    reps = as.factor(c(1, 2, 3, 1, 2, 3 ,4,
                                     1, 2 ,3)), 
                    stage = as.factor(c(rep("MG",3),rep("PV",4), rep("SA",3))))

ddsFullCountTable <- DESeqDataSetFromMatrix(
   countData = savagecounts,
   colData = coldata,
   design = ~ reps + stage)
#DESeq2 getting DE genes
savagecounts_dds <- DESeq(ddsFullCountTable )

```  
 
 As you can see in the above chunk, savage data was run through the same pipeline, creating a new data frame for DESeq2 with variables reps, which are the repetition of the samples, and stage, which now represents the location of where the trypanosome was sampled: Migut, Proventiculus, Salivary gland.
#8. Savage Data  
Here we are completing DESEq results on Savage data. We have a adjusted pvalue (padj) filter of < 0.01, a log2foldchange > 1.5. 
The comparisons we completed are:
1. MgSa (Midgut and Salivary Gland)
$~$
2. MgPv (Migut and Proventiculus)
$~$
3. PvSa (Proventiculus and Salivary Gland)
$~$
 We will complete the same analysis on Schulz data on the comparisons MG/SA, MG/PV and PV/SA. 
Here we extract results for the log2 of the fold change of MG and SA. 
```{r}
#Comparisons of all 
  #padj filter < 0.01
  #abs(log2fold) filter > 1.5
#MG and SA############################################################################
savageRes_MgSa <- results( savagecounts_dds ,contrast = c("stage",  "MG","SA"))
savageRes_MgSa
```
 
For Schulz data, we also considered a fraction of 1% false positives acceptable, due to the accuracy we need in the DE genes for Savage to compare to our dataset. We consider all genes with an adjusted p value below 1%=0.01 as significant.  

Similar to filtering the padj, we want to filter the logfold2change. If a gene has a high absolute value log2foldchange, it means the gene is highly expressed. In order to cut down the amount of DE genes, filtering of this parameter will select only the higly expressed genes for our analysis of Savage data against our own. The cutoff logfold2 value 1.5 was arbitrarly chosen based on needing ~200-500 DE genes for further analysis. 

```{r}
resSig <- savageRes_MgSa[ which(savageRes_MgSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgSa <- resSig
head(MgSa) 
```
Here is the padj and logfold2 filtered results of the log2 of the fold change of MG and SA.
The rownames of this table are the DE genes calculated from the results function. 

We completed the same analysis on comparisons MG/PV and PV/SA (not shown) with same parameters and filtering. 
```{r, echo = FALSE}
#MG and PV############################################################################
savageRes_MgPv <- results( savagecounts_dds ,contrast = c("stage",  "MG","PV"))
resSig <- savageRes_MgPv[ which(savageRes_MgPv$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
MgPv <- resSig

#PV and SA############################################################################
savageRes_PvSa <- results( savagecounts_dds ,contrast = c("stage",  "PV","SA"))
resSig <- savageRes_PvSa[ which(savageRes_PvSa$padj < 0.01 ), ]
resSig <- resSig[which(abs(resSig$log2FoldChange) > 1.5),]
PvSa <- resSig

 
```


#8. GO analysis 
In order to assign biological meaning to our results, we must understand the biological background behind our DE genes. GO analysis, or Gene Ontology term enrichment is a way to charachterize genes through assigning them to cell/organism specific pathways. The Gene Ontology system of classification assigns genes to a set of predefined pathways depending on their functional characteristics. For example, if a gene FasR is categorized as being a receptor, bing involved in apoptosis and located on the plasma membrane. Thus, by being able to group our DE genes by biologocal funciton, we can come to a fuller conclusion of our data using biological results.

For GO on Schulz and savage data, we used a database https://tritrypdb.org/tritrypdb/, and completed GeneId search for our DE genes, which give additional information on the specific information on each gene. Then, after completing Geneid search, click on the tab "Analyze Results" and then GO. For our data, we completed Cellular Component, Molecular Function, and Biological Process GO enrichment. The downloaded tabs are in the folder labled "GO_Terms"
 
https://en.wikipedia.org/wiki/Gene_Ontology_Term_Enrichment

Here, we must upload the files into the trypanosome database, by taking all the rownames of the DESeq2 results analysis. Then, after writing the file, the quotations and 'x' must be deleted in order to run Geneid analysis in the data base. 
This is comparison MG/SA, other comparisons MG/PV and PV/SA are not shown but completed. 

```{r}
###here we need to preform GO on these genes. Upload to tryp database under New search : metabolic pathways, and enter this txt file. Then, make sure to get is downloaded as a csv.
  #GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(MgSa), collapse="\t")
write.table(file_to_write, file="MgSa_gene") #look up in file directory, then delete quotation marks as well as the first rows that are not genes
```

```{r, include = FALSE}
#creating file for GO/PATHWAY ANALYSIS
file_to_write<-paste(rownames(MgPv), collapse="\t")
write.table(file_to_write, file="MgPv_gene")

#creating file for GO/PATHWAY ANALYSIS
 file_to_write<-paste(rownames(PvSa), collapse="\t")
write.table(file_to_write, file="PvSa_gene")

```

#9 GSEA analysis
Gene Set Enrichment Analysis interpers gene expression data by focusing on gene sets, or sets of genes that share common traits and or biological function. This alrogith uses categorical or continuous phenotype data, such as an experiment testing ‘treatment’ vs ‘untreated’. The goal of GSEA is to determine if a gene set S is randomly distributed or found at the top or bottom of a ranked gene list L. 

For our analysis, we want to 
Take Savage DE genes comparisons and enrich them in Schulz data
Take DE genes from Schulz clusters/data and enrich them in Savage data
Take GO terms from Savage data and enrich them in Schulz data
Take GO terms from Schulz clusters and enrich them in Savage data

We used fgsea(), or fast gene set enrichment analysis. 

In order to prepare our results for GSEA pipline, we must manipulate GO data tables into pathways (list), and ranks (vector). 

```{r}

###############MAKING PATHWAY LIST FROM GO ANALYSIS - BIO, CELL,MOLECULAR###########################

####################BIO PROS GO###########################
MgSa_GObiopros <- read.table("MgSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GObiopros <- data.frame(MgSa_GObiopros, comparison = "MgSa_bio")
MgPv_GObiopros <- read.table("MgPv_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GObiopros <- data.frame(MgPv_GObiopros, comparison = "MgPv_bio")
PvSa_GObiopros <- read.table("PvSa_GObiopros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GObiopros <- data.frame(PvSa_GObiopros, comparison = "PvSa_bio")
  
```
Here, to speed up the process, we bind all GO biological process for three comparisons MgSa, MgPv, and PvSa. We will separate the data frame using fiulter function using column 'comparison'.
Because the genes that are given by default in this data table are not in a list format, but rather a block of string. We need to split the genes in order to evaluate GSEA using string split them using functions gsub() and strsplit(). 
```{r}
  
all_bio <- rbind(MgSa_GObiopros,MgPv_GObiopros,PvSa_GObiopros)
all_bio$Result.gene.list[1]
all_bio$Result.gene.list <- gsub(',',',',all_bio$Result.gene.list,fixed=TRUE)
all_bio$Result.gene.list <- strsplit(all_bio$Result.gene.list, ",")
all_bio$Result.gene.list[1]
```
 
 Here, using the filter funciton we filter data frame MgSa GO biological process, and then turn the resulting GO term data table into a list of GO terms and resulting gene names. Complete data filter and GO pathway creation for remaining GO Cellular, and Molecular pathways for MgSa, MgPv, and PvSa. 
```{r}
#MgSa Bio
MgSa_GObiopros <- data.frame(all_bio %>% dplyr :: filter(comparison == "MgSa_bio"))
MgSa_GObiopros_list <- as.list(MgSa_GObiopros)
names(MgSa_GObiopros_list$Result.gene.list) <- MgSa_GObiopros_list$Name 
MgSaGOlist_bio <- MgSa_GObiopros_list$Result.gene.list
MgSaGOlist_bio$`transmembrane transport`

```

```{r, include = FALSE}
#MgPv Bio
MgPv_GObiopros <- data.frame(all_bio %>% filter(comparison == "MgPv_bio"))
MgPv_GObiopros_list <- as.list(MgPv_GObiopros)
names(MgPv_GObiopros_list$Result.gene.list) <- MgPv_GObiopros_list$Name
MgPvGOlist_bio <- MgPv_GObiopros_list$Result.gene.list
#PvSa Bio
PvSa_GObiopros <- data.frame(all_bio %>% filter(comparison == "PvSa_bio"))
PvSa_GObiopros_list <- as.list(PvSa_GObiopros)
names(PvSa_GObiopros_list$Result.gene.list) <- PvSa_GObiopros_list$Name
PvSaGOlist_bio <- PvSa_GObiopros_list$Result.gene.list

#####################CELL PROS#######################
  #MGSA
MgSa_GOcellpros <- read.table("MgSa_GOcellpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOcellpros <- data.frame(MgSa_GOcellpros, comparison = "MgSa_cell")
MgPv_GOcellpros <- read.table("MgPv_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOcellpros <- data.frame(MgPv_GOcellpros, comparison = "MgPv_cell")
PvSa_GOcellpros <- read.table("PvSa_GOcellularpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOcellpros <- data.frame(PvSa_GOcellpros, comparison = "PvSa_cell")
  
all_cell <- rbind(MgSa_GOcellpros, MgPv_GOcellpros,PvSa_GOcellpros)
all_cell$Result.gene.list <- gsub(',',',',all_cell$Result.gene.list,fixed=TRUE)
all_cell$Result.gene.list <- strsplit(all_cell$Result.gene.list, ",")

  #MGSA CELL
MgSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgSa_cell"))
MgSa_GOcellpros_list <- as.list(MgSa_GOcellpros)
names(MgSa_GOcellpros_list$Result.gene.list) <- MgSa_GOcellpros_list$Name
MgSaGOlist_cell <- MgSa_GOcellpros_list$Result.gene.list
  #MGPV CELL
MgPv_GOcellpros <- data.frame(all_cell %>% filter(comparison == "MgPv_cell"))
MgPv_GOcellpros_list <- as.list(MgPv_GOcellpros)
names(MgPv_GOcellpros_list$Result.gene.list) <- MgPv_GOcellpros_list$Name
MgPvGOlist_cell <- MgPv_GOcellpros_list$Result.gene.list
  #PVSA CELL
PvSa_GOcellpros <- data.frame(all_cell %>% filter(comparison == "PvSa_cell"))
PvSa_GOcellpros_list <- as.list(PvSa_GOcellpros)
names(PvSa_GOcellpros_list$Result.gene.list) <- PvSa_GOcellpros_list$Name
PvSaGOlist_cell <- PvSa_GOcellpros_list$Result.gene.list
#View(PvSaGOlist_cell)


##################### MOLE PROS #####################
MgSa_GOmolepros <- read.table("MgSa_GOmolecpros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgSa_GOmolepros <- data.frame(MgSa_GOmolepros, comparison = "MgSa_mol")
MgPv_GOmolepros <- read.table("MgPv_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  MgPv_GOmolepros <- data.frame(MgPv_GOmolepros, comparison = "MgPv_mol")
PvSa_GOmolepros <- read.table("PvSa_GOmolepros.tab", sep = "\t",header = TRUE) %>% dplyr :: select(Name, Result.gene.list)
  PvSa_GOmolepros <- data.frame(PvSa_GOmolepros, comparison = "PvSa_mol")
  
all_mol <- rbind(MgSa_GOmolepros,MgPv_GOmolepros, PvSa_GOmolepros)
all_mol$Result.gene.list <- gsub(',',',',all_mol$Result.gene.list,fixed=TRUE)
all_mol$Result.gene.list <- strsplit(all_mol$Result.gene.list, ",")

  #MGSA MOL
MgSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgSa_mol")) 
MgSa_GOmolepros_list <- as.list(MgSa_GOmolepros)
names(MgSa_GOmolepros_list$Result.gene.list) <- MgSa_GOmolepros$Name
MgSaGOlist_mole <- MgSa_GOmolepros_list$Result.gene.list
  #MGPV MOL
MgPv_GOmolepros <- data.frame(all_mol %>% filter(comparison == "MgPv_mol")) 
MgPv_GOmolepros_list <- as.list(MgPv_GOmolepros)
names(MgPv_GOmolepros_list$Result.gene.list) <- MgPv_GOmolepros$Name
MgPvGOlist_mole <- MgPv_GOmolepros_list$Result.gene.list
  #PVSA MOL
PvSa_GOmolepros <- data.frame(all_mol %>% filter(comparison == "PvSa_mol")) 
PvSa_GOmolepros_list <- as.list(PvSa_GOmolepros)
names(PvSa_GOmolepros_list$Result.gene.list) <- PvSa_GOmolepros$Name
PvSaGOlist_mole <- PvSa_GOmolepros_list$Result.gene.list



```

Creating ranks

To measure the enrichment of Savage DE genes in Schulz clusters, we need to create a ranked list based on a metric of differental expression. For this analysis, the metric used was -log10(pvlaue) * abs(logfold2change). If the pvalue of a resulting DE gene is very low, the -log10(pvalue) will be extremely large. Contrastly, a high logfold2change represents high expression, and a positive logfold2change shows genes are up regulated, and a negative logfold2change show genes are down regulated. Thus, the ranked vector of Savage DE genes will factor the up/down gene regulation and DE gene significance and magnitude.  

To begin creating the ranked list, the results data table for all Savage comparisons will be row binded and differitated by colum 'comparison' to speed up coding and process. 

1. Ranks for Savage data (three ranks = MgSa, MgPv, PvSa)
2. Ranks for Schulz data (Three ranks = negative logfold, positive logfold, total)

1. Making ranked metric list for savage data

```{r}
#######MAKING RANKED METRIC LIST FOR SAVAGE DATA########

#making big data set 'allcomp' with all comparisons to make code easier. Splitting after by 'comparison' 
MGSA_df <- data.frame(Gene = rownames(MgSa), pvalue = MgSa$pvalue, padj = MgSa$padj, comparison = "MgSa",log2FoldChange= MgSa$log2FoldChange)
MGPV_df <- data.frame(Gene = rownames(MgPv), pvalue = MgPv$pvalue, padj = MgPv$padj, comparison = "MgPv", log2FoldChange= MgPv$log2FoldChange)
PVSA_df <- data.frame(Gene = rownames(PvSa), pvalue = PvSa$pvalue, padj = PvSa$padj, comparison = "PvSa",log2FoldChange= PvSa$log2FoldChange)
sav_allcomp <- rbind(MGSA_df,MGPV_df, PVSA_df)
```


```{r}

sav_allcomp$logP <- -log10(sav_allcomp$pvalue) #calculating metric == -log10(pvalue)
sav_allcomp <-  sav_allcomp[which(abs(sav_allcomp$logP) != 0),] #filtering out p-values 
sav_allcomp$metric <- sav_allcomp$logP * abs(sav_allcomp$log2FoldChange)
sav_gsea_allcomp <- sav_allcomp[,c("Gene","metric","comparison")]

##filtering out big dataset -- creating data frames for each comparison 
gsea_MgSa_df<- sav_gsea_allcomp %>% filter(comparison == "MgSa") %>% dplyr :: select(-comparison) 
gsea_MgPv_df <- sav_gsea_allcomp %>% filter(comparison == "MgPv") %>% dplyr :: select(-comparison) 
gsea_PvSa_df <- sav_gsea_allcomp %>% filter(comparison == "PvSa") %>% dplyr :: select(-comparison) 
head(gsea_MgSa_df)
#creating stats and pathways for gsea
  #MgSa
gseaDat_MgSa <- filter(gsea_MgSa_df, !is.na(Gene))
gseaDat_MgSa <- gseaDat_MgSa %>% filter(metric != c(Inf, -Inf))
ranks_MgSa <- gsea_MgSa_df$metric
names(ranks_MgSa) <- gseaDat_MgSa$Gene
ranks_MgSa <- sort(ranks_MgSa)
head(ranks_MgSa)
  #MgPv
gseaDat_MgPv <- filter(gsea_MgPv_df, !is.na(Gene))
ranks_MgPv <- gsea_MgPv_df$metric
names(ranks_MgPv) <- gseaDat_MgPv$Gene
ranks_MgPv <- sort(ranks_MgPv)
#PvSa
gseaDat_PvSa <- filter(gsea_PvSa_df, !is.na(Gene))
ranks_PvSa <- gsea_PvSa_df$metric
names(ranks_PvSa) <- gseaDat_PvSa$Gene
ranks_PvSa <- sort(ranks_PvSa)

```

2. Making metric rank for Schulz data - 012 comparison, neg/pos/total logfold2change.

Here, we will take the data (((list)))!!!! resSig_012, which represents the log2 of the fold change of treated 12h and untreated 0h, ib_12h / noo_ib, and similar to Savage results, we will use ranking metric -log10(pvalue) * abs(logfold2change)

```{r}
 
#Making metric rank for 0-12h comparison

#creating metric used for ranking DE of genes for TB schulz 0-12h timepoint contrast
#resSig$fcsign <- sign(resSig$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig <-  resSig[which(abs(resSig$fcsign) != 0),] #filtering out foldchanges = 0
resSig_012$logP = -log10(resSig_012$pvalue) 
resSig_012 <-  resSig_012[which(abs(resSig_012$logP) != 0),] 
resSig_012$metric= resSig_012$logP * abs(resSig_012$log2FoldChange)#calculating metric = log10(pvalue)/fcsign
resSig_012$Gene <- rownames(resSig_012) #creating column Gene for dataframe
gsea_schulz <-resSig_012[,c("Gene", "metric")]
```

Similar to Savage, we must 
```{r}
#Creating data frame from gsea_schulz for gsea
gsea_schulz_df <- data.frame(gsea_schulz)
rownames(gsea_schulz_df) <- NULL
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != Inf),]
gsea_schulz_df[1:10,] 
#creating stats and pathways for gsea
gseaDat_schulz <- filter(gsea_schulz_df, !is.na(Gene))
ranks <- gsea_schulz_df$metric
names(ranks) <- gseaDat_schulz$Gene
ranks <- sort(ranks)
head(ranks)
```

```{r, include = FALSE}
#####FOR LOG POS FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.pos$fcsign <- sign(resSig_log.pos$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.pos$logP = -log10(resSig_log.pos$pvalue) 
resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$logP) != 0),] 
resSig_log.pos$metric= resSig_log.pos$logP * abs(resSig_log.pos$log2FoldChange) #metric = -log10(pvalue) *abs(log2FoldChange)
resSig_log.pos$Gene <- rownames(resSig_log.pos) #creating column Gene for dataframe
gsea_schulz_log.pos <-resSig_log.pos[,c("Gene", "metric")]
 
  #creating data frame
gsea_schulz_df_log.pos <- data.frame(gsea_schulz_log.pos)
rownames(gsea_schulz_df_log.pos) <- NULL
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != Inf),]
gsea_schulz_df_log.pos[1:10,]

  #creating ranks for fgsea
gseaDat_schulz_log.pos <- filter(gsea_schulz_df_log.pos, !is.na(Gene))
ranks_log.pos <- gsea_schulz_df_log.pos$metric
names(ranks_log.pos) <- gseaDat_schulz_log.pos$Gene
ranks_log.pos <- sort(ranks_log.pos)
head(ranks_log.pos)
#####FOR LOG NEG FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.neg$fcsign <- sign(resSig_log.neg$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.neg$logP <-  -log10(resSig_log.neg$pvalue)
resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$logP) != 0),] 
resSig_log.neg$metric <-  resSig_log.neg$logP * abs(resSig_log.neg$log2FoldChange) #calculating metric = log10(pvalue) 
resSig_log.neg$Gene <- rownames(resSig_log.neg) #creating column Gene for dataframe
gsea_schulz_log.neg <-resSig_log.neg[,c("Gene", "metric")]

  #creating data frame
gsea_schulz_df_log.neg <- data.frame(gsea_schulz_log.neg)
rownames(gsea_schulz_df_log.neg) <- NULL
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != -Inf),] #removing metric   where = -Inf
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != Inf),]
gsea_schulz_df_log.neg[1:10,]
  #creating ranks for fgsea
gseaDat_schulz_log.neg <- filter(gsea_schulz_df_log.neg, !is.na(Gene))
ranks_log.neg <- gsea_schulz_df_log.neg$metric
names(ranks_log.neg) <- gseaDat_schulz_log.neg$Gene
ranks_log.neg <- sort(ranks_log.neg)
head(ranks_log.neg)


```


#10 - Running GSEA - Preparing Schulz Clusters for pathways
  Schulz clusters enriched in Savage comparisons. 
```{r}  
############################FGSEA ON 2019 CLUSTERS#############################
#In order to answer the biological questions of our data, we need to take statisitcal steps to gather information in order to prove, or answer the hypothesis at hand. Clustering our data is an example of this method. Here we are taking the fuzzy cluster GO analysis results, and preparing them for GSEA pipeline. 

#Reading in huge file with all GO terms of cluster.s 
fuzzyClust <- read.table("fuzzyclusters_GO.tab") %>% dplyr :: select(Name, Result.gene.list, Cluster,Type)
fuzzyClust$Result.gene.list <- gsub(',',',',fuzzyClust$Result.gene.list,fixed=TRUE)
fuzzyClust$Result.gene.list <- strsplit(fuzzyClust$Result.gene.list, ",")


#cluster1 <- data.frame(GO[1]) %>%dplyr::select(Cluster1.Name,Cluster1.Result.gene.list,Cluster1.Type) 
#cluster1$Cluster1.Result.gene.list <- gsub(',',',',cluster1$Cluster1.Result.gene.list,fixed=TRUE)
#cluster1$Cluster1.Result.gene.list <- strsplit(cluster1$Cluster1.Result.gene.list, ",")

clust1_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 1)
clust1_bio_list <- as.list(clust1_bio)
names(clust1_bio_list$Result.gene.list) <- clust1_bio_list$Name
clust1_bio <- clust1_bio_list$Result.gene.list
clust1_bio$`microtubule-based movement`
```

```{r, include = FALSE}
clust1_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 1)
clust1_cell_list <- as.list(clust1_cell)
names(clust1_cell_list$Result.gene.list) <- clust1_cell_list$Name
clust1_cell <- clust1_cell_list$Result.gene.list
#View(fuzzylist_1_cell)

clust1_mol <- fuzzyClust %>% filter(Type == "Molecular Function",Cluster == 1)
clust1_mol_list <- as.list(clust1_mol)
names(clust1_mol_list$Result.gene.list) <- clust1_mol_list$Name
clust1_mol <- clust1_mol_list$Result.gene.list

#########CLUSTER 2######### 
 
clust2_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 2)
clust2_bio_list <- as.list(clust2_bio)
names(clust2_bio_list$Result.gene.list) <- clust2_bio_list$Name
clust2_bio <- clust2_bio_list$Result.gene.list
#View(clust2_bio)

clust2_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 2)
clust2_cell_list <- as.list(clust2_cell)
names(clust2_cell_list$Result.gene.list) <- clust2_cell_list$Name
clust2_cell <- clust2_cell_list$Result.gene.list
#View(fuzzylist_2_cell)

#clust2_mol <- cluster2 %>% filter(Cluster2.Type == "Molecular Function")
#clust2_mol_list <- as.list(clust2_mol)
#names(clust2_mol_list$Cluster2.Result.gene.list) <- clust2_mol_list$Cluster2.Name
#fuzzylist_2_mol <- clust2_mol_list$Cluster2.Result.gene.list
#View(fuzzylist_2_mol)

#cluster3 <- data.frame(GO[3])%>%dplyr::select(Cluster3.Name,Cluster3.Result.gene.list,Cluster3.Type) 
#clust3_bio <- cluster3 %>% filter(Cluster3.Type == "Biological Process")
#clust3_cell <- cluster3 %>% filter(Cluster3.Type == "Cellular Component")
#clust3_mol <- cluster3 %>% filter(Cluster3.Type == "Molecular Function")

clust4_bio <- fuzzyClust %>% filter(Type == "Biological Process", Cluster == 4)
clust4_bio_list <- as.list(clust4_bio)
names(clust4_bio_list$Result.gene.list) <- clust4_bio_list$Name
clust4_bio <- clust4_bio_list$Result.gene.list
#View(fuzzylist_4_bio)

clust4_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 4)
clust4_cell_list <- as.list(clust4_cell)
names(clust4_cell_list$Result.gene.list) <- clust4_cell_list$Name
clust4_cell <- clust4_cell_list$Result.gene.list
#View(fuzzylist_4_cell)

clust4_mol <- fuzzyClust %>% filter(Type == "Molecular Function", Cluster == 4)
clust4_mol_list <- as.list(clust4_mol)
names(clust4_mol_list$Result.gene.list) <- clust4_mol_list$Name
clust4_mol <- clust4_mol_list$Result.gene.list
#View(clust4_mol)
#cluster5 <- data.frame(GO[5])%>%dplyr::select(Cluster5.Name,Cluster5.Result.gene.list,Cluster5.Type) 
#clust5_bio <- cluster5 %>% filter(Cluster5.Type == "Biological Process")
#clust5_cell <- cluster5 %>% filter(Cluster5.Type == "Cellular Component")
#clust5_mol <- cluster5 %>% filter(Cluster5.Type == "Molecular Function")
 

#clust6_bio <- cluster6 %>% filter(Cluster6.Type == "Biological Process")
clust6_cell <- fuzzyClust %>% filter(Type == "Cellular Component", Cluster == 6) 
clust6_cell_list <- as.list(clust6_cell)
names(clust6_cell_list$Result.gene.list) <- clust6_cell_list$Name
clust6_cell <- clust6_cell_list$Result.gene.list
```

AGH I keep getting an error...
```{r}
#making Result.gene.list entry into list 
 
all_fuzzy <- c()
all_fuzzy$bio1 <-  clust1_bio 
all_fuzzy$bio2 <- clust2_bio
all_fuzzy$bio4 <- clust4_bio

all_fuzzy$cell1 <- clust1_cell
all_fuzzy$cell2 <- clust2_cell
all_fuzzy$cell4 <- clust4_cell
all_fuzzy$cell6 <- clust6_cell

all_fuzzy$mol1 <- clust1_mol
all_fuzzy$mol4 <- clust4_mol
 
 
fgsea_mgsa_fuzzy <- c()
fgsea_mgpv_fuzzy <- c()
fgsea_pvsa_fuzzy <- c()
#ranks_MgSa <- sort(ranks_MgSa)
#bplapply(c(pathways = as.list(all_fuzzy$cell6), stats = ranks_MgSa, minSize = 1,  nperm = 1000), fgsea, BPPARAM = SnowParam())
#View(all_fuzzy$bio1)

for (i in 1:9){
   
#fgsea_mgsa_fuzzy[[i]] = fgsea(pathways = as.list(all_fuzzy[[i]]), stats = ranks_MgSa, minSize = 1,  nperm = 100)
#fgsea_mgpv_fuzzy[[i]] = fgsea(pathways = as.list(all_fuzzy[[i]]), stats = ranks_MgPv, minSize = 1,  nperm = 100)
#fgsea_pvsa_fuzzy[[i]] = fgsea(pathways = as.list(all_fuzzy[[i]]), stats = ranks_PvSa, minSize = 1,  nperm = 100)
fgsea_mgsa_fuzzy[[i]] = bplapply(c(as.list(all_fuzzy[[i]]),ranks_MgSa, minSize = 1,  nperm = 1000), fgsea, BPPARAM = SnowParam())
#fgsea_mgpv_fuzzy[[i]] = bplapply(c(as.list(all_fuzzy[i]), ranks_MgPv, minSize = 1,  nperm = 1000), fgsea, BPPARAM = SnowParam())
#fgsea_pvsa_fuzzy[[i]] = bplapply(c(as.list(all_fuzzy[i]), ranks_PvSa, minSize = 1,  nperm = 1000), fgsea, BPPARAM = SnowParam())
}
 
class(all_fuzzy[[1]])

bplapply(c((as.list(sav_all_list)),ranks, minSize = 1,  nperm = 1000), fgsea, BPPARAM = SnowParam())
fgsea(sav_all_list, ranks_log.neg, minSize = 1, nperm = 100)
View(sav_all_list)
names(fgsea_mgsa_fuzzy) <- names(all_fuzzy)
names(fgsea_mgpv_fuzzy) <- names(all_fuzzy)
names(fgsea_pvsa_fuzzy) <- names(all_fuzzy)

```

```{r, include = FALSE}
#GSEA -- MAKING DATA TABLES AND RUNNING FGSEA
  #Making metric rank for 0-12h comparison

#creating metric used for ranking DE of genes for TB schulz 0-12h timepoint contrast
#resSig$fcsign <- sign(resSig$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig <-  resSig[which(abs(resSig$fcsign) != 0),] #filtering out foldchanges = 0
resSig$logP = -log10(resSig$pvalue) 
resSig <-  resSig[which(abs(resSig$logP) != 0),] 
resSig$metric= resSig$logP * abs(resSig$log2FoldChange)#calculating metric = log10(pvalue)/fcsign
resSig$Gene <- rownames(resSig) #creating column Gene for dataframe
gsea_schulz <-resSig[,c("Gene", "metric")]

#Creating data frame from gsea_schulz for gsea
gsea_schulz_df <- data.frame(gsea_schulz)
rownames(gsea_schulz_df) <- NULL
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df <- gsea_schulz_df[which(gsea_schulz_df$metric != Inf),]
gsea_schulz_df[1:10,] 
#creating stats and pathways for gsea
gseaDat_schulz <- filter(gsea_schulz_df, !is.na(Gene))
ranks <- gsea_schulz_df$metric
names(ranks) <- gseaDat_schulz$Gene
ranks <- sort(ranks)
head(ranks)

#####FOR LOG POS FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.pos$fcsign <- sign(resSig_log.pos$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.pos$logP = -log10(resSig_log.pos$pvalue) 
resSig_log.pos <-  resSig_log.pos[which(abs(resSig_log.pos$logP) != 0),] 
resSig_log.pos$metric= resSig_log.pos$logP * abs(resSig_log.pos$log2FoldChange) #metric = -log10(pvalue) *abs(log2FoldChange)
resSig_log.pos$Gene <- rownames(resSig_log.pos) #creating column Gene for dataframe
gsea_schulz_log.pos <-resSig_log.pos[,c("Gene", "metric")]
 
  #creating data frame
gsea_schulz_df_log.pos <- data.frame(gsea_schulz_log.pos)
rownames(gsea_schulz_df_log.pos) <- NULL
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != -Inf),] #removing metric where = -Inf
gsea_schulz_df_log.pos <- gsea_schulz_df_log.pos[which(gsea_schulz_df_log.pos$metric != Inf),]
gsea_schulz_df_log.pos[1:10,]

  #creating ranks for fgsea
gseaDat_schulz_log.pos <- filter(gsea_schulz_df_log.pos, !is.na(Gene))
ranks_log.pos <- gsea_schulz_df_log.pos$metric
names(ranks_log.pos) <- gseaDat_schulz_log.pos$Gene
ranks_log.pos <- sort(ranks_log.pos)
head(ranks_log.pos)
#####FOR LOG NEG FOLD CHANGE######
#CREATING RANKS AND DATA FRAME FOR GSEA
#resSig_log.neg$fcsign <- sign(resSig_log.neg$log2FoldChange) #fcsign stands for the log2foldchange sign
#resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$fcsign) != 0),] #filtering out foldchanges = 0
resSig_log.neg$logP <-  -log10(resSig_log.neg$pvalue)
resSig_log.neg <-  resSig_log.neg[which(abs(resSig_log.neg$logP) != 0),] 
resSig_log.neg$metric <-  resSig_log.neg$logP * abs(resSig_log.neg$log2FoldChange) #calculating metric = log10(pvalue) 
resSig_log.neg$Gene <- rownames(resSig_log.neg) #creating column Gene for dataframe
gsea_schulz_log.neg <-resSig_log.neg[,c("Gene", "metric")]

  #creating data frame
gsea_schulz_df_log.neg <- data.frame(gsea_schulz_log.neg)
rownames(gsea_schulz_df_log.neg) <- NULL
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != -Inf),] #removing metric   where = -Inf
gsea_schulz_df_log.neg <- gsea_schulz_df_log.neg[which(gsea_schulz_df_log.neg$metric != Inf),]
gsea_schulz_df_log.neg[1:10,]
  #creating ranks for fgsea
gseaDat_schulz_log.neg <- filter(gsea_schulz_df_log.neg, !is.na(Gene))
ranks_log.neg <- gsea_schulz_df_log.neg$metric
names(ranks_log.neg) <- gseaDat_schulz_log.neg$Gene
ranks_log.neg <- sort(ranks_log.neg)
head(ranks_log.neg)

```




